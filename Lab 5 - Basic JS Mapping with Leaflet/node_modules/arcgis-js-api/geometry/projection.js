/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["require","exports","../core/Error","../core/promiseUtils","../core/accessorSupport/tracking","../core/accessorSupport/tracking/SimpleObservable","../core/libs/gl-matrix-2/factories/vec3f64","./ellipsoidUtils","./Extent","./Multipoint","../chunks/pe","./Point","./Polygon","./Polyline","./SpatialReference","./projection/projectBuffer","./projection/projectors","./projection/projectXYZToVector","./support/GeographicTransformation","./support/spatialReferenceUtils","./support/zscale"],(function(e,n,r,t,l,o,i,a,u,s,c,f,p,m,h,d,g,y,j,R,P){"use strict";let x=null,w=null,S=null,Z={};const M=new o.SimpleObservable;function v(){return!!x&&c.isLoaded()}function z(){return!!v()||(l.trackAccess(M),L(),!1)}function C(e,n){return!e||!n||(_(e,n)||z())}function E(e,n){return!_(e,n)&&!v()}function L(n){return null==S&&(S=Promise.all([c.load(),new Promise(((n,r)=>e(["../chunks/geometryEngineBase"],n,r))).then((e=>e.geometryEngineBase)),new Promise(((n,r)=>e(["./geometryAdapters/hydrated"],n,r)))])),S.then((([,e,{hydratedAdapter:r}])=>{t.throwIfAborted(n),w=r,x=e.default,x._enableProjection(c.pe),M.notify()}))}function T(e,n,r=null,t=null){return Array.isArray(e)?0===e.length?[]:b(w,e,e[0].spatialReference,n,r,t):b(w,[e],e.spatialReference,n,r,t)[0]}function b(e,n,r,t,l=null,o=null){if(null==r||null==t)return n;if(_(r,t,l))return n.map((e=>X(e,r,t)));if(null==l&&a.isSphericalECEF(r)){return n.map((e=>X(e,r,h.WGS84))).map((e=>O(e,t)))}if(null==l&&a.isSphericalECEF(t)){return n.map((e=>O(e,h.WGS84))).map((e=>X(e,h.WGS84,t)))}if(null==l){const e=j.cacheKey(r,t);void 0!==Z[e]?l=Z[e]:(null==(l=G(r,t,void 0))&&(l=new j),Z[e]=l)}if(null==x||null==e)throw new W;return null!=o?x._project(e,n,r,t,l,o):x._project(e,n,r,t,l)}function A(e,n){const r=F([e],n);return null!=r.pending?{pending:r.pending,geometry:null}:null!=r.geometries?{pending:null,geometry:r.geometries[0]}:{pending:null,geometry:null}}function F(e,n){if(!v())for(const r of e)if(null!=r&&!R.equals(r.spatialReference,n)&&R.isValid(r.spatialReference)&&R.isValid(n)&&!_(r.spatialReference,n))return l.trackAccess(M),{pending:L(),geometries:null};return{pending:null,geometries:e.map((e=>null==e?null:R.equals(e.spatialReference,n)?e:R.isValid(e.spatialReference)&&R.isValid(n)?O(e,n):null))}}function G(e,n,r=null){if(null==e||null==n)return null;if(null==x||null==w)throw new W;const t=x._getTransformation(w,e,n,r,r?.spatialReference);return null!==t?j.fromGE(t):null}function V(e,n,r=null){if(null==x||null==w)throw new W;const t=x._getTransformationBySuitability(w,e,n,r,r?.spatialReference);if(null!==t){const e=[];for(const n of t)e.push(j.fromGE(n));return e}return[]}class W extends r{constructor(){super("projection:not-loaded","projection engine not fully loaded yet, please call load()")}}function k(){x=null,w=null,S=null,Z={}}const B={get loadPromise(){return S}};function O(e,n){try{const r=T(e,n);if(null==r)return null;"xmin"in e&&"xmin"in r&&(r.zmin=e.zmin,r.zmax=e.zmax);const t=P.getGeometryZScaler(r.type,e.spatialReference,n);return null!=t&&t(r),r}catch(r){if(!(r instanceof W))throw r;return null}}async function q(e,n,r){const t=e.spatialReference;return null!=t&&null!=n&&await U(t,n,null,r),O(e,n)}function _(e,n,r){return!r&&(!!R.equals(e,n)||R.isValid(e)&&R.isValid(n)&&!!g.getProjector(e,n,g.projectorCache))}async function U(e,n,r,l){if(v())return t.waitTick(l);if(Array.isArray(e)){for(const{source:t,dest:o,geographicTransformation:i}of e)if(t&&o&&!_(t,o,i))return L(l)}else if(e&&n&&!_(e,n,r))return L(l);return t.waitTick(l)}function X(e,n,r){return e?"x"in e?I(e,n,new f,r,0):"xmin"in e?ee(e,n,new u,r,0):"rings"in e?Q(e,n,new p,r,0):"paths"in e?J(e,n,new m,r,0):"points"in e?D(e,n,new s,r,0):null:null}function Y(e,n,r=n.spatialReference,t=0){return null!=r&&null!=e.spatialReference&&null!=I(e,e.spatialReference,n,r,t)}function I(e,n,r,t,l){te[0]=e.x,te[1]=e.y;const o=e.z;return te[2]=void 0!==o?o:l,d.projectBuffer(te,n,0,te,t,0,1)?(r.x=te[0],r.y=te[1],r.spatialReference=t,void 0!==o||a.isSphericalPCPF(t)?(r.z=te[2],r.hasZ=!0):(r.z=void 0,r.hasZ=!1),void 0===e.m?(r.m=void 0,r.hasM=!1):(r.m=e.m,r.hasM=!0),r):null}function K(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=D(e,e.spatialReference,n,r,t)}function D(e,n,r,t,l){const{points:o,hasZ:i,hasM:u}=e,s=[],c=o.length,f=[];for(const a of o)f.push(a[0],a[1],i?a[2]:l);if(!d.projectBuffer(f,n,0,f,t,0,c))return null;const p=i||a.isSphericalPCPF(t);for(let a=0;a<c;++a){const e=3*a,n=f[e],r=f[e+1];p&&u?s.push([n,r,f[e+2],o[a][3]]):p?s.push([n,r,f[e+2]]):u?s.push([n,r,o[a][2]]):s.push([n,r])}return r.points=s,r.spatialReference=t,r.hasZ=i,r.hasM=u,r}function H(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=J(e,e.spatialReference,n,r,t)}function J(e,n,r,t,l){const{paths:o,hasZ:i,hasM:u}=e,s=[];if(!ne(o,i??!1,u??!1,n,s,t,l))return null;const c=i||a.isSphericalPCPF(t);return r.paths=s,r.spatialReference=t,r.hasZ=c,r.hasM=u,r}function N(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=Q(e,e.spatialReference,n,r,t)}function Q(e,n,r,t,l){const{rings:o,hasZ:i,hasM:u}=e,s=[];if(!ne(o,i??!1,u??!1,n,s,t,l))return null;const c=i||a.isSphericalPCPF(t);return r.rings=s,r.spatialReference=t,r.hasZ=c,r.hasM=u,r}function $(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=ee(e,e.spatialReference,n,r,t)}function ee(e,n,r,t,l){const{xmin:o,ymin:i,xmax:u,ymax:s,hasZ:c,hasM:f}=e,p=c?e.zmin:l;if(!y.projectXYZToVector(o,i,p,n,te,t))return null;const m=c||a.isSphericalPCPF(t);r.xmin=te[0],r.ymin=te[1],m&&(r.zmin=te[2]);const h=c?e.zmax:l;return y.projectXYZToVector(u,s,h,n,te,t)?(r.xmax=te[0],r.ymax=te[1],m&&(r.zmax=te[2]),f&&(r.mmin=e.mmin,r.mmax=e.mmax),r.spatialReference=t,r):null}function ne(e,n,r,t,l,o,i=0){const u=new Array;for(const a of e)for(const e of a)u.push(e[0],e[1],n?e[2]:i);if(!d.projectBuffer(u,t,0,u,o,0,u.length/3))return!1;let s=0;l.length=0;const c=n||a.isSphericalPCPF(o);for(const a of e){const e=new Array;for(const n of a)c&&r?e.push([u[s++],u[s++],u[s++],n[3]]):c?e.push([u[s++],u[s++],u[s++]]):r?(e.push([u[s++],u[s++],n[2]]),s++):(e.push([u[s++],u[s++]]),s++);l.push(e)}return!0}function re(e){return null!=e&&null!=g.getWGS84ComparableLonLatProjector(e)}const te=i.create();n.canProjectToWGS84ComparableLonLat=re,n.canProjectWithoutEngine=_,n.getTransformation=G,n.getTransformations=V,n.initializeProjection=U,n.isLoaded=v,n.isLoadedOrLoad=z,n.isLoadedOrLoadFor=C,n.load=L,n.project=T,n.projectExtent=$,n.projectMany=b,n.projectMultipoint=K,n.projectOrLoad=A,n.projectOrLoadMany=F,n.projectPoint=Y,n.projectPolygon=N,n.projectPolyline=H,n.projectWithZConversion=q,n.projectWithoutEngine=X,n.requiresLoad=E,n.test=B,n.tryProjectWithZConversion=O,n.unload=k,Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})}));
