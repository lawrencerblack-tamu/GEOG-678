/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../chunks/tslib.es6","../core/arrayUtils","../core/lang","../core/accessorSupport/decorators/property","../core/has","../core/Logger","../core/accessorSupport/decorators/subclass","../core/accessorSupport/decorators/writer","./Extent","./Geometry","./Point","./SpatialReference","./support/centroid","./support/contains","./support/coordsUtils","./support/extentUtils","./support/intersectsBase","./support/webMercatorUtils","./support/zmUtils"],(function(t,e,r,n,s,i,o,a,l,h,c,u,p,g,f,y,m,d,R){"use strict";var x;function _(t){return!Array.isArray(t[0])}let w=x=class extends h{static fromExtent(t){const e=t.clone().normalize(),r=t.spatialReference;let n=!1,s=!1;for(const o of e)o.hasZ&&(n=!0),o.hasM&&(s=!0);const i={rings:e.map((t=>{const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(n&&t.hasZ){const r=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(r)}if(s&&t.hasM){const r=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(r)}return e})),spatialReference:r};return n&&(i.hasZ=!0),s&&(i.hasM=!0),new x(i)}constructor(...t){super(...t),this.rings=[],this.type="polygon"}normalizeCtorArgs(t,e){let r,n,s=null,i=null;return t&&!Array.isArray(t)?(s=t.rings??null,e||(t.spatialReference?e=t.spatialReference:t.rings||(e=t)),r=t.hasZ,n=t.hasM):s=t,s=s||[],e=e||u.WGS84,s.length&&null!=s[0]?.[0]&&"number"==typeof s[0][0]&&(s=[s]),i=s[0]?.[0],i&&(void 0===r&&void 0===n?(r=i.length>2,n=i.length>3):void 0===r?r=n?i.length>3:i.length>2:void 0===n&&(n=r?i.length>3:i.length>2)),{rings:s,spatialReference:e,hasZ:r,hasM:n}}get cache(){return this.commitProperty("rings"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get centroid(){const t=p.polygonCentroid(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const e=new c;return e.x=t[0],e.y=t[1],e.spatialReference=this.spatialReference,this.hasZ&&(e.z=t[2]),e}get extent(){const{spatialReference:t}=this,e=y.getPolygonExtent(this);if(!e)return null;const r=new l(e);return r.spatialReference=t,r}get isSelfIntersecting(){return m.isSelfIntersecting(this.rings)}writeRings(t,e){e.rings=r.clone(this.rings)}addRing(t){if(!t)return;const e=this.rings,r=e.length;if(_(t)){const n=[];for(let e=0,r=t.length;e<r;e++)n[e]=t[e].toArray();e[r]=n}else e[r]=t.concat();return this.notifyChange("rings"),this}clone(){const t=new x;return t.spatialReference=this.spatialReference,t.rings=r.clone(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}equals(t){if(this===t)return!0;if(null==t)return!1;const r=this.spatialReference,n=t.spatialReference;if(null!=r!=(null!=n))return!1;if(null!=r&&null!=n&&!r.equals(n))return!1;if(this.rings.length!==t.rings.length)return!1;const s=([t,e,r,n],[s,i,o,a])=>t===s&&e===i&&(null==r&&null==o||r===o)&&(null==n&&null==a||n===a);for(let i=0;i<this.rings.length;i++){const r=this.rings[i],n=t.rings[i];if(!e.equals(r,n,s))return!1}return!0}contains(t){if(!t)return!1;const e=d.project(t,this.spatialReference);return g.polygonContainsPoint(this,null!=e?e:t)}isClockwise(t){let e;return e=_(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t,f.isClockwise(e)}getPoint(t,e){if(!this._validateInputs(t,e))return null;const r=this.rings[t][e],n=this.hasZ,s=this.hasM;return n&&!s?new c(r[0],r[1],r[2],void 0,this.spatialReference):s&&!n?new c(r[0],r[1],void 0,r[2],this.spatialReference):n&&s?new c(r[0],r[1],r[2],r[3],this.spatialReference):new c(r[0],r[1],this.spatialReference)}insertPoint(t,e,r){return this._validateInputs(t,e,!0)?(R.updateSupportFromPoint(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t].splice(e,0,r),this.notifyChange("rings"),this):this}removePoint(t,e){if(!this._validateInputs(t,e))return null;const r=new c(this.rings[t].splice(e,1)[0],this.spatialReference);return this.notifyChange("rings"),r}removeRing(t){if(!this._validateInputs(t,null))return null;const e=this.rings.splice(t,1)[0],r=this.spatialReference,n=e.map((t=>new c(t,r)));return this.notifyChange("rings"),n}setPoint(t,e,r){return this._validateInputs(t,e)?(R.updateSupportFromPoint(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t][e]=r,this.notifyChange("rings"),this):this}_validateInputs(t,e,r=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const n=this.rings[t];if(r&&(e<0||e>n.length))return!1;if(!r&&(e<0||e>=n.length))return!1}return!0}toJSON(t){return this.write({},t)}};t.__decorate([n.property({readOnly:!0})],w.prototype,"cache",null),t.__decorate([n.property({readOnly:!0})],w.prototype,"centroid",null),t.__decorate([n.property({readOnly:!0})],w.prototype,"extent",null),t.__decorate([n.property({readOnly:!0})],w.prototype,"isSelfIntersecting",null),t.__decorate([n.property({type:[[[Number]]],json:{write:{isRequired:!0}}})],w.prototype,"rings",void 0),t.__decorate([a.writer("rings")],w.prototype,"writeRings",null),w=x=t.__decorate([o.subclass("esri.geometry.Polygon")],w),w.prototype.toJSON.isDefaultToJSON=!0;return w}));
