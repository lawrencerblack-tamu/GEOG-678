/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/Logger","../../../core/libs/gl-matrix-2/math/mat3","../../../core/libs/gl-matrix-2/factories/mat3f64","../../../core/libs/gl-matrix-2/math/mat4","../../../core/libs/gl-matrix-2/factories/mat4f64","../../../core/libs/gl-matrix-2/math/quat","../../../core/libs/gl-matrix-2/factories/quatf64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../Point","../../spatialReferenceEllipsoidUtils","../../projection/computeTranslationToOriginAndRotation","../../projection/projectPointToVector","../axisAngleDegrees","../MeshTransform","../meshVertexSpaceUtils","./geographicUtils","./projection","./vertexSpaceConversion"],(function(e,t,r,o,i,a,n,l,c,s,p,g,f,u,m,x,d,P,b,h){"use strict";const j="esri.geometry.support.meshUtils.rotate";function v(e,t,r){if(!e.vertexAttributes?.position||0===t[3])return;const{spatialReference:o,vertexSpace:i}=e,a=r?.origin??e.anchor,n=r?.geographic,l=P.usesLocalTangentPlaneOnECEFForOperations(j,i,o,n);d.isMeshWithRelativeVertexSpace(e)?T(e,t,a):l?R(e,t,a):A(e,t,a)}function T(e,r,o){e.transform??=new x;const{vertexSpace:a,transform:l,spatialReference:g}=e,[f,u,d]=a.origin,P=new p({x:f,y:u,z:d,spatialReference:g}),b=S;if(P.equals(o))c.set(b,0,0,0);else if(!h.projectPointToVertexSpace(b,o,e))return void t.getLogger(j).error(`Failed to project specified origin (wkid:${o.spatialReference.wkid}) to mesh (wkid:${g.wkid}) ${a.type} vertex space. Projection may be possible after calling projection.load().`);n.setAxisAngle(M,m.axis(r),m.angleRad(r));const v=i.fromRotationTranslationScaleOrigin(w,M,s.ZEROS,s.ONES,b),{localMatrix:T}=l,R=i.multiply(w,v,T);l.scale=i.getScaling(s.create(),R),i.scale(R,R,c.inverse(S,l.scale)),l.rotation=m.fromMatrix(R),l.translation=i.getTranslation(s.create(),R)}function R(e,t,o){const i=e.spatialReference,a=g.getSphericalPCPF(i),n=O;u.projectPointToVector(o,n,a)||u.projectPointToVector(e.origin,n,a);const l=e.vertexAttributes.position,s=e.vertexAttributes.normal,p=e.vertexAttributes.tangent,x=new Float64Array(l.length),d=null!=s?new Float32Array(s.length):null,P=null!=p?new Float32Array(p.length):null;f.computeTranslationToOriginAndRotation(a,n,C,a),r.fromMat4(k,C);const h=y;c.transformMat3(m.axis(y),m.axis(t),k),h[3]=t[3],b.projectToPCPF(l,i,x),null!=s&&null!=d&&b.projectNormalToPCPF(s,l,x,i,d),null!=p&&null!=P&&b.projectTangentToPCPF(p,l,x,i,P),F(x,h,3,n),b.projectFromPCPF(x,l,i),null!=s&&null!=d&&(F(d,h,3),b.projectNormalFromPCPF(d,l,x,i,s)),null!=p&&null!=P&&(F(P,h,4),b.projectTangentFromPCPF(P,l,x,i,p)),e.vertexAttributesChanged()}function A(e,r,o){const i=O;if(!u.projectPointToVector(o,i,e.spatialReference)){const r=e.origin;i[0]=r.x,i[1]=r.y,i[2]=r.z,t.getLogger(j).error(`Failed to project specified origin (wkid:${o.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}F(e.vertexAttributes.position,r,3,i),F(e.vertexAttributes.normal,r,3),F(e.vertexAttributes.tangent,r,4),e.vertexAttributesChanged()}function F(e,t,r,o=s.ZEROS){if(null!=e){i.fromRotation(C,m.angleRad(t),m.axis(t));for(let t=0;t<e.length;t+=r){for(let r=0;r<3;r++)S[r]=e[t+r]-o[r];c.transformMat4(S,S,C);for(let r=0;r<3;r++)e[t+r]=S[r]+o[r]}}}const S=s.create(),w=a.create(),y=m.create(),C=a.create(),k=o.create(),O=s.create(),M=l.create();e.rotate=v,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
