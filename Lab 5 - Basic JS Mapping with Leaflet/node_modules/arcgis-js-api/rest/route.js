/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../request","../core/accessorSupport/get","../geometry/support/normalizeUtils","./networkService","./utils","./route/utils","./support/FeatureSet","./support/RouteSolveResult"],(function(e,r,t,s,o,a,n,u,i){"use strict";function c(e){return e instanceof u}async function l(e,u,i){const l=[],p=[],y={},m={},d=a.parseUrl(e),{path:g}=d;c(u.stops)&&o.collectGeometries(u.stops.features,p,"stops.features",y),c(u.pointBarriers)&&o.collectGeometries(u.pointBarriers.features,p,"pointBarriers.features",y),c(u.polylineBarriers)&&o.collectGeometries(u.polylineBarriers.features,p,"polylineBarriers.features",y),c(u.polygonBarriers)&&o.collectGeometries(u.polygonBarriers.features,p,"polygonBarriers.features",y);const h=await s.normalizeCentralMeridian(p);for(const r in y){const e=y[r];l.push(r),m[r]=h.slice(e[0],e[1])}if(o.isInputGeometryZAware(m,l)){let e=null;try{e=await o.fetchServiceDescription(g,u.apiKey,i)}catch{}e&&!e.hasZ&&o.dropZValuesOffInputGeometry(m,l)}for(const r in m)m[r].forEach(((e,s)=>{t.get(u,r)[s].geometry=e}));const R={...i,query:{...d.query,...n.routeParametersToQueryParameters(u),f:"json"}},v=g.endsWith("/solve")?g:`${g}/solve`,{data:B}=await r(v,R);return f(B)}function f(e){const{barriers:r,directionLines:t,directionPoints:s,directions:o,messages:a,polygonBarriers:n,polylineBarriers:u,routes:c,stops:l,traversedEdges:f,traversedJunctions:p,traversedTurns:y}=e,m=e=>{const r=g.find((r=>r.routeName===e));if(null!=r)return r;const t={routeId:g.length+1,routeName:e};return g.push(t),t},d=e=>{const r=g.find((r=>r.routeId===e));if(null!=r)return r;const t={routeId:e,routeName:null};return g.push(t),t},g=[];c?.features.forEach(((e,r)=>{e.geometry.spatialReference=c.spatialReference??void 0;const t=e.attributes.Name,s=r+1;g.push({routeId:s,routeName:t,route:e})})),o?.forEach((e=>{const{routeName:r}=e;m(r).directions=e}));const h=(l?.features.every((e=>null==e.attributes.RouteName))??!1)&&g.length>0?g[0].routeName:null;return l?.features.forEach((e=>{e.geometry&&(e.geometry.spatialReference??=l.spatialReference??void 0);const r=h??e.attributes.RouteName,t=m(r);t.stops??=[],t.stops.push(e)})),t?.features.forEach((e=>{const r=e.attributes.RouteID,s=d(r),{geometryType:o,spatialReference:a}=t;s.directionLines??={features:[],geometryType:o,spatialReference:a},s.directionLines.features.push(e)})),s?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r),{geometryType:o,spatialReference:a}=s;t.directionPoints??={features:[],geometryType:o,spatialReference:a},t.directionPoints.features.push(e)})),f?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r),{geometryType:s,spatialReference:o}=f;t.traversedEdges??={features:[],geometryType:s,spatialReference:o},t.traversedEdges.features.push(e)})),p?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r),{geometryType:s,spatialReference:o}=p;t.traversedJunctions??={features:[],geometryType:s,spatialReference:o},t.traversedJunctions.features.push(e)})),y?.features.forEach((e=>{const r=e.attributes.RouteID,t=d(r);t.traversedTurns??={features:[]},t.traversedTurns.features.push(e)})),i.fromJSON({routeResults:g,barriers:r,polygonBarriers:n,polylineBarriers:u,messages:a})}e.solve=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
