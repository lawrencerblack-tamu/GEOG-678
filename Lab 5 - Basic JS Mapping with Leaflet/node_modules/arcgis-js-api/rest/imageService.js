/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../geometry","../request","../geometry/support/normalizeUtils","../geometry/support/spatialReferenceUtils","./utils","./support/FindImagesResult","./support/ImageAngleResult","./support/ImageAreaResult","./support/ImageBoundaryResult","./support/ImageDistanceResult","./support/ImageGPSInfoResult","./support/ImageHeightResult","./support/ImageIdentifyResult","./support/ImagePixelLocationResult","./support/ImagePointResult","./support/ImageSampleResult","./support/ImageUrlResult","./support/MeasureAreaFromImageResult","./support/MeasureLengthFromImageResult","../geometry/SpatialReference","../geometry/support/jsonUtils"],(function(e,t,a,n,o,r,s,i,l,c,u,m,p,f,d,g,y,S,O,N,R,h){"use strict";function I(e){const t=e?.time;if(t&&(null!=t.start||null!=t.end)){const a=[];null!=t.start&&a.push(t.start),null==t.end||a.includes(t.end)||a.push(t.end),e.time=a.join(",")}}async function J(e,t,a){const o=r.parseUrl(e),s=t.geometry?[t.geometry]:[],i=await n.normalizeCentralMeridian(s),l=t.toJSON();I(l);const c=i?.[0];null!=c&&(l.geometry=T(c));const u=r.encode({...o.query,f:"json",...l});return r.asValidOptions(u,a)}async function w(e,t,n){const o=t.toJSON();null!=o.angleName&&(o.angleName=o.angleName.join(",")),t?.point?.spatialReference?.imageCoordinateSystem&&(o.point.spatialReference=z(t.point.spatialReference)),t?.spatialReference?.imageCoordinateSystem&&(o.spatialReference=L(t.spatialReference));const s=r.parseUrl(e),l=r.encode({...s.query,f:"json",...o}),c=r.asValidOptions(l,n),{data:u}=await a(`${s.path}/computeAngles`,c);return u.spatialReference=u.spatialReference?null!=u.spatialReference.geodataXform?new R({wkid:0,imageCoordinateSystem:u.spatialReference}):R.fromJSON(u.spatialReference):null,"NaN"===u.north&&(u.north=null),"NaN"===u.up&&(u.up=null),new i(u)}async function j(e,t,n){const o=t.toJSON(),{geometries:s}=t;if(s)for(let a=0;a<s.length;a++)s[a].spatialReference?.imageCoordinateSystem&&(o.geometries.geometries[a].spatialReference=z(s[a].spatialReference));const i=r.parseUrl(e),l=r.encode({...i.query,f:"json",...o}),c=r.asValidOptions(l,n),{data:u}=await a(`${i.path}/computePixelLocation`,c);return d.fromJSON(u)}async function U(e,t,n){const o=await J(e,t,n),s=r.parseUrl(e),{data:i}=await a(`${s.path}/computeStatisticsHistograms`,o),{statistics:l}=i;return l?.length&&l.forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:l,histograms:i.histograms}}async function q(e,t,n){const o=await J(e,t,n),s=r.parseUrl(e),{data:i}=await a(`${s.path}/computeHistograms`,o);return{histograms:i.histograms}}async function C(e,t,o){const s=t.toJSON();I(s),s.outFields?.length&&(s.outFields=s.outFields.join(","));const i=await n.normalizeCentralMeridian(t.geometry),l=i?.[0];null!=l&&(s.geometry=T(l));const c=r.parseUrl(e),u=r.encode({...c.query,f:"json",...s}),m=r.asValidOptions(u,o),{data:p}=await a(`${c.path}/getSamples`,m),f=p?.samples?.map((e=>{const t="NaN"===e.value||""===e.value?null:e.value.split(" ").map((e=>Number(e)));return{...e,pixelValue:t}}));return y.fromJSON({samples:f})}async function M(e,t,o){const s=r.parseUrl(e),i=t.geometry?[t.geometry]:[];return n.normalizeCentralMeridian(i).then((e=>{const n=t.toJSON(),i=e?.[0];null!=i&&(n.geometry=JSON.stringify(T(i)));const l=r.encode({...s.query,f:"json",...n}),c=r.asValidOptions(l,o);return a(s.path+"/identify",c)})).then((e=>f.fromJSON(e.data)))}async function V(e,t,a){const n=await P(e,t,[t.fromGeometry,t.toGeometry],a);return p.fromJSON(n)}async function G(e,t,a){const n=await P(e,t,[t.geometry],a);return l.fromJSON(n)}async function $(e,t,a){const n=await P(e,t,[t.geometry],a);return g.fromJSON(n)}async function b(e,t,a){const n=await P(e,t,[t.fromGeometry,t.toGeometry],a);return u.fromJSON(n)}async function P(e,t,o,s){const i=r.parseUrl(e),l=await n.normalizeCentralMeridian(o),c=t.toJSON();null!=l[0]&&(c.fromGeometry=JSON.stringify(T(l[0]))),null!=l[1]&&(c.toGeometry=JSON.stringify(T(l[1])));const u=r.encode({...i.query,f:"json",...c}),m=r.asValidOptions(u,s),{data:p}=await a(i.path+"/measure",m);return p}async function A(e,t,a){const n=await F(e,t,a);return N.fromJSON(n)}async function v(e,t,a){const n=await F(e,t,a);return O.fromJSON(n)}async function F(e,t,n){const o=r.parseUrl(e),s=t.toJSON(),i=r.encode({...o.query,f:"json",...s}),l=r.asValidOptions(i,n),{data:c}=await a(o.path+"/measureFromImage",l);return c}function T(e){const t=e.toJSON();return e.spatialReference?.imageCoordinateSystem&&(t.spatialReference=z(e.spatialReference)),t}function z(e){const{imageCoordinateSystem:t}=e;if(t){const{id:e,referenceServiceName:a}=t;return null!=e?a?{icsid:e,icsns:a}:{icsid:e}:{ics:t}}return e.toJSON()}function L(e,t){if(!e.imageCoordinateSystem)return o.srToRESTValue(e);const a=z(e),{icsid:n,icsns:r}=a;return null==n||null!=r&&!t?.toLowerCase().includes("/"+r.toLowerCase()+"/")?JSON.stringify(a):`0:${n}`}async function H(e,t,n){const o=r.parseUrl(e),s=t.toJSON();t.outSpatialReference&&(s.outSR=L(t.outSpatialReference));const i=r.encode({...o.query,f:"json",...s}),l=r.asValidOptions(i,n),{data:u}=await a(o.path+"/queryBoundary",l);return c.fromJSON(u)}async function x(e,t,o){const s=t.toJSON();I(s),s.objectIds?.length&&(s.objectIds=s.objectIds.join(",")),s.geometry||s.objectIds||s.time||s.where||(s.where="1=1");const i=await n.normalizeCentralMeridian(t.geometry),l=i?.[0];null!=l&&(s.geometry=T(l));const c=l?.spatialReference??t.geometry?.spatialReference;c&&(s.inSR=L(c));const u=r.parseUrl(e),p=r.encode({...u.query,f:"json",...s}),f=r.asValidOptions(p,o),{data:d}=await a(`${u.path}/queryGPSInfo`,f);return m.fromJSON(d)}async function B(e,t,n){const o=t.toJSON();t.geometry.spatialReference.imageCoordinateSystem&&(o.geometry=T(t.geometry)),t.depthOffset&&t.adjust||delete o.options;const s=r.parseUrl(e),i=r.encode({...s.query,f:"json",...o}),l=r.asValidOptions(i,n),{data:c}=await a(`${s.path}/imageToMap`,l);return h.fromJSON(c)}async function D(e,t,n){const o=t.toJSON();t.rasterIds?.length&&(o.rasterIds=t.rasterIds.join(","));const s=r.parseUrl(e),i=r.encode({...s.query,f:"json",...o}),l=r.asValidOptions(i,n),{data:c}=await a(`${s.path}/imageToMapMultiray`,l);return h.fromJSON(c)}async function E(e,t,o){const s=t.toJSON(),i=await n.normalizeCentralMeridian(t.geometry),l=i?.[0];null!=l&&(s.geometry=T(l)),t.visibleOnly||delete s.options;const c=l?.spatialReference??t.geometry?.spatialReference;c&&(s.inSR=L(c));const u=r.parseUrl(e),m=r.encode({...u.query,f:"json",...s}),p=r.asValidOptions(m,o),{data:f}=await a(`${u.path}/mapToImage`,p);return h.fromJSON(f)}async function k(e,t,n){const o=t.toJSON(),s=r.parseUrl(e),i=r.encode({...s.query,f:"json",...o}),l=r.asValidOptions(i,n),{data:c}=await a(`${s.path}/getImageUrl`,l);return S.fromJSON(c)}async function Q(e,t,o){const i=t.toJSON(),l=await n.normalizeCentralMeridian([t.fromGeometry,t.toGeometry]);null!=l[0]&&(i.fromGeometry=T(l[0]),l[0].spatialReference&&(i.inSR=L(l[0].spatialReference))),null!=l[1]&&(i.toGeometry=T(l[1])),t.objectIds?.length&&(i.objectIds=i.objectIds.join(","));const c=r.parseUrl(e),u=r.encode({...c.query,f:"json",...i}),m=r.asValidOptions(u,o),{data:p}=await a(`${c.path}/find`,m);return s.fromJSON(p)}e.computeAngles=w,e.computeHistograms=q,e.computePixelSpaceLocations=j,e.computeStatisticsHistograms=U,e.findImages=Q,e.getImageSpatialReferenceJSON=z,e.getImageSpatialReferenceQueryParameter=L,e.getImageUrl=k,e.getSamples=C,e.identify=M,e.imageToMap=B,e.imageToMapMultiray=D,e.mapToImage=E,e.measureAreaAndPerimeter=G,e.measureAreaFromImage=v,e.measureDistanceAndAngle=b,e.measureHeight=V,e.measureLengthFromImage=A,e.measurePointOrCentroid=$,e.queryBoundary=H,e.queryGPSInfo=x,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
