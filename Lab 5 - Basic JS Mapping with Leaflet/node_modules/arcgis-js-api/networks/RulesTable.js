/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../chunks/tslib.es6","../request","../core/JSONSupport","../core/Loadable","../core/accessorSupport/decorators/property","../core/has","../core/Logger","../core/RandomLCG","../core/accessorSupport/decorators/subclass","./support/typeUtils"],(function(e,t,o,s,r,n,i,a,u,c){"use strict";let p=class extends(o.JSONSupportMixin(s)){constructor(e){super(e),this.rulesCategorized={attachment:[],containment:[],connectivity:[]},this.request=t}initialize(){}async load(e){const t=this.layer.load(e).then((()=>this._initializeRulesTable()));return this.addResolvingPromise(t),this}getFeatureSQL(e,t){const o=e.layerId.toString(),s=e.fieldsIndex?.normalizeFieldName("assetGroup"),r=e.fieldsIndex?.normalizeFieldName("assetType"),n=s?t.attributes[s]:null,i=r?t.attributes[r]:null,a=this.rulesHash[o];if(a){const e=a.assetGroupHash[n];if(e){return e.assetTypeHash[i]||null}}return null}async _initializeRulesTable(){const e={};let t;!function(e){e[e.from=0]="from",e[e.to=1]="to",e[e.via=2]="via"}(t||(t={}));const o=[{networkSourceId:"fromNetworkSource",assetGroupId:"fromAssetGroup",assetTypeId:"fromAssetType"},{networkSourceId:"toNetworkSource",assetGroupId:"toAssetGroup",assetTypeId:"toAssetType"},{networkSourceId:"viaNetworkSource",assetGroupId:"viaAssetGroup",assetTypeId:"viaAssetType"}];this.rulesCategorized={attachment:[],containment:[],connectivity:[]};for(const s of this.rules){if(s.ruleType===c.RuleType.RTAttachment){this.rulesCategorized.attachment.push(s);continue}if(s.ruleType===c.RuleType.RTContainment){this.rulesCategorized.containment.push(s);continue}if(s.ruleType===c.RuleType.RTJunctionJunctionConnectivity){this.rulesCategorized.connectivity.push(s);continue}this.rulesCategorized.connectivity.push(s);let r=[[t.from,t.to],[t.to,t.from]];s.ruleType===c.RuleType.RTEdgeJunctionEdgeConnectivity&&(r=[[t.from,t.via],[t.via,t.from],[t.to,t.via],[t.via,t.to]]);for(const n of r){const r=n.shift(),i=n.shift();let a=!1;switch(s.ruleType){case c.RuleType.RTEdgeJunctionEdgeConnectivity:a=r===t.from||r===t.to;break;case c.RuleType.RTJunctionEdgeConnectivity:a=r===t.to}const u=o[r],p=s[u.networkSourceId]?.layerId.toString()??"",d=s[u.assetGroupId]?.assetGroupCode?.toString(),l=s[u.assetTypeId],y=l?.assetTypeCode?.toString(),h=o[i],T=s[h.networkSourceId]?.layerId.toString()??"",f=s[h.assetGroupId]?.assetGroupCode?.toString(),g=s[h.assetTypeId],v=g?.assetTypeCode?.toString(),m=e[p]??{assetGroupHash:{}};if(!(d&&y&&f&&v))continue;const S=m.assetGroupHash[d]??{assetTypeHash:{}},I=S.assetTypeHash[y]??{};if(I[T]=I[T]??{},a){I[p]=I[p]??{};const e=`(assetgroup = ${d} AND assettype = ${y})`;I[p].anyVertex=I[p].anyVertex?`${I[p].anyVertex}`:`${e}`,"esriNECPEndVertex"===g?.connectivityPolicy&&(I[p].endVertex=I[p]?.endVertex?`${I[p].endVertex}`:`${e}`)}const C=`(assetgroup = ${f} AND assettype = ${v})`;I[T].anyVertex=I[T]?.anyVertex?`${I[T].anyVertex} OR ${C}`:`${C}`,"esriNECPEndVertex"===g?.connectivityPolicy&&(I[T].endVertex=I[T]?.endVertex?`${I[T].endVertex} OR ${C}`:`${C}`),S.assetTypeHash[y]=I,m.assetGroupHash[d]=S,e[p]=m}}this.rulesHash=e}};e.__decorate([r.property({constructOnly:!0})],p.prototype,"layer",void 0),e.__decorate([r.property({constructOnly:!0})],p.prototype,"rules",void 0),e.__decorate([r.property()],p.prototype,"rulesHash",void 0),e.__decorate([r.property()],p.prototype,"rulesCategorized",void 0),e.__decorate([r.property({constructOnly:!0})],p.prototype,"request",void 0),p=e.__decorate([u.subclass("esri.networks.RulesTable")],p);return p}));
