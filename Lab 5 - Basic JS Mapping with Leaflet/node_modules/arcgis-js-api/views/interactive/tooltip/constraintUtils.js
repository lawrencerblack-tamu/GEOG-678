/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/quantityUtils","../../../core/unitUtils","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/projection/projectVectorToVector","../../../geometry/support/geodesicUtils","../../../support/elevationInfoUtils","../sketch/constraints","../sketch/normalizedPoint","../../support/angularMeasurementUtils"],(function(e,n,t,r,o,i,l,c,u,s,a){"use strict";function f(e,n,t,r,o,c){let u="geodesic",a=l.geodesicCompatibleSpatialReference(t);const f=s.fromPoint(e,n,r);return f[2]=0,a&&i.projectVectorToVector(f,t,f,a)||(u="euclidean",a=t),{mode:u,view:n,elevationInfo:r,hasZ:o,directionMode:c,spatialReference:e.spatialReference,measurementSR:a,origin:f}}function d(e,r,o){if(null==r||null==e)return;const i=t.lengthUnitFromSpatialReference(o.measurementSR);if(null==i)return;const l=S(e,o);if(null==l)return;const c=n.valueInUnit(r,i);return new u.VerticalCylinderConstraint(s.fromVec3(l),c)}function g(e,t,r,i){if(null==r||null==e)return;const l=S(e,i);if(null==l)return;const c=a.getDegreesGeographic(r),s=10,f=e=>{if(null==e)return;const t=o.create(),r=n.createAngle(e,"degrees","geographic");return a.pointFromDistanceAlongAzimuth(t,l,i.measurementSR,s,r,i.mode)?new u.VerticalHalfPlaneConstraint(l,t):void 0},d=()=>{if(null!=t&&null!=e)return a.getDegreesGeographic(a.directionBetweenPoints(t,e))};switch(i.directionMode){case a.DirectionMode.Absolute:return f(c);case a.DirectionMode.Relative:{const e=d();if(null==e)return;return f(e+c)}case a.DirectionMode.RelativeBilateral:{const e=d();if(null==e)return;return u.constraintOrSet([f(e+c),f(e-c)])}}}function m(e,n){const t=w(e,n);return null!=t?new u.HorizontalPlaneConstraint(t):void 0}function p(e,t,r,o,l,c){if(null==r&&null==o&&null==l)return;if(null==t)return m(o,c);const{view:f,elevationInfo:d,measurementSR:g}=c,p=s.fromPoint(t,f,d);if(!g||!i.projectVectorToVector(p,t.spatialReference,D,g))return;const v=[D[0],D[1]],R=null!=r?n.valueInUnit(r,"meters"):void 0,h=C(o,c),S=a.getDegreesGeographic(l),P=e=>{const n=new u.GeodesicConstraint(v,g,R,h,e);return null==R||null==e||null==h&&c.hasZ?n:new u.PointConstraint(n.closestTo(p))};if(null==S)return P(void 0);const w=()=>{if(null!=e&&null!=t)return a.getDegreesGeographic(a.directionBetweenPoints(e,t))};switch(c.directionMode){case a.DirectionMode.Absolute:return P(S);case a.DirectionMode.Relative:{const e=w();if(null==e)return;return P(e+S)}case a.DirectionMode.RelativeBilateral:{const e=w();if(null==e)return;return u.constraintOrSet([P(e+S),P(e-S)])}}}function v(e,n){return"geodesic"===n.mode?p(null,null,null,e,null,n):m(e,n)}function R(e,n,t,r,o,i){return"geodesic"===i.mode?p(n,e,t,o,r,i):h([d(e,t,i),g(e,n,r,i),m(o,i)])}function h(e){let n;for(const t of e)t&&(n=n?.intersect(t)??t);return n}function S(e,n){const{view:t,elevationInfo:o,measurementSR:l,origin:c,mode:u}=n,a=s.fromPoint(e,t,o);if(i.projectVectorToVector(a,e.spatialReference,a,l))return"geodesic"!==u&&r.subtract(a,a,c),a}function P(e,n,t){const{view:o,measurementSR:l,spatialReference:c,origin:u,mode:a}=t,f=D;if("geodesic"===a?r.copy(f,e):r.add(f,e,u),i.projectVectorToVector(f,l,f,c))return s.toElevationAlignedDehydratedPoint(f,o,n,t)}function w(e,n){return V(e,n)?.value??void 0}function C(e,t){const r=V(e,t);return null!=r?n.valueInUnit(r,"meters"):void 0}function V(e,{view:r,origin:o,elevationInfo:i,hasZ:l,measurementSR:u}){if(null==e||!l)return;const s=t.verticalLengthUnitFromSpatialReference(u);if(null==s)return;const[a,f]=o,d=n.valueInUnit(e,s),g="3d"===r?.type?c.getConvertedElevationFromXYZ(r,a,f,d,u,i):d;return null!=g?n.createLength(g,s):void 0}const D=o.create();e.constraintSpaceToPoint=P,e.getConstraintContext=f,e.getGeodesicConstraint=p,e.getPointConstraint=v,e.getPolylineOrPolygonConstraint=R,e.intersectAll=h,e.pointToConstraintSpace=S,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
