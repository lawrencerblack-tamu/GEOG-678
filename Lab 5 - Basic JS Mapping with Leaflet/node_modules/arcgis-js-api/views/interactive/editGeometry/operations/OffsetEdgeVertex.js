/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../core/mathUtils","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/vector","../../../support/geometry2dUtils"],(function(t,e,i,s,n,r,a,o,c){"use strict";class h{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(t,e,i,s=0,n=g.IMMEDIATE){this._helper=t,this._planeType=e,this._edge=i,this.distance=s,this._plane=a.create(),this._offsetPlane=a.create(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,n===g.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const t=this._toXYZ(this._edge.leftVertex.pos),e=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),i=this._toXYZ(this._edge.rightVertex.pos),s=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=n.direction(r.create(),t,i),e?(this._left=this._computeNeighbor(t,e,this._edgeDirection),this._right=this._computeNeighbor(i,s,this._edgeDirection,this._left)):(this._right=this._computeNeighbor(i,s,this._edgeDirection),this._left=this._computeNeighbor(t,e,this._edgeDirection,this._right))}_toXYZ(t){return null!=t?this._helper.toXYZ(t):null}_pointToXYZ(t){return this._toXYZ(this._helper.pointToVector(t))}_computeNeighbor(t,e,i,s){const a=r.create();if(e){n.direction(a,t,e);const s=!this._passesBisectingAngleThreshold(a,i);return{start:t,end:e,direction:s?this._bisectVectorsPerpendicular(i,a):a,isOriginalDirection:!s}}return this._helper.hasZ()?s&&(n.cross(a,i,s.direction),n.cross(a,a,i),n.normalize(a,a),Math.sign(a[1])!==Math.sign(i[0])&&n.scale(a,a,-1)):n.set(a,-i[1],i[0],0),{start:t,end:e,direction:a,isOriginalDirection:!0}}_passesBisectingAngleThreshold(t,e){const i=Math.abs(o.angle(e,t));return i>=_&&i<=Math.PI-_}_bisectVectorsPerpendicular(t,e){const i=n.dot(t,e)<0?t:n.negate(r.create(),t),s=Math.abs(n.dot(i,e));if(!(s<l||s>1-l))return this._bisectDirection(i,e);const a=n.cross(r.create(),i,[0,0,1]);return n.normalize(a,a)}_bisectDirection(t,e){const i=n.add(r.create(),t,e);return n.normalize(i,i)}_initializePlane(){const t=this._computeNormalDirection(this._left),e=this._computeNormalDirection(this._right);n.dot(t,e)<0&&n.negate(e,e),a.fromPositionAndNormal(this._left.start,this._bisectDirection(t,e),this._plane)}_computeNormalDirection(e){const i=n.cross(r.create(),e.direction,this._edgeDirection);n.normalize(i,i);const s=n.cross(r.create(),this._edgeDirection,i);return this._planeType===t.PlaneType.XY&&(s[2]=0),n.normalize(s,s)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(a.signedDistance(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint(a.signedDistance(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))}_updateIntersectDistanceConstraint(t){const e=a.getNormal(t),o=this._edgeDirection,h=n.add(r.create(),this._left.start,this._left.direction),_=n.add(r.create(),this._right.start,this._right.direction),l=this._pointInBasis2D(s.create(),e,o,this._left.start),d=this._pointInBasis2D(s.create(),e,o,h),g=this._pointInBasis2D(s.create(),e,o,this._right.start),p=this._pointInBasis2D(s.create(),e,o,_),[u]=c.intersectLineAndRay({start:d,end:l,type:c.LineType.LINE},{start:p,end:g,type:c.LineType.LINE});if(!u)return;const D=i.subtract(s.create(),l,d);i.normalize(D,D);const f=i.subtract(s.create(),u,d),m=i.dot(D,f),b=n.add(r.create(),h,n.scale(r.create(),this._left.direction,-m)),x=a.signedDistance(t,b);this._updateDistanceConstraint(x)}_pointInBasis2D(t,e,i,s){return t[0]=o.projectPointSignedLength(e,s),t[1]=o.projectPointSignedLength(i,s),t}_offset(t,e){Number.isFinite(this._minDistance)&&(e=Math.max(this._minDistance,e)),Number.isFinite(this._maxDistance)&&(e=Math.min(this._maxDistance,e)),a.copy(this._offsetPlane,this._plane),this._offsetPlane[3]-=e;const i=(t,e,i)=>null!=e&&a.intersectLine(this._offsetPlane,t,n.add(r.create(),t,e),i),s=r.create();(t===this._edge.leftVertex?i(this._left.start,this._left.direction,s):i(this._right.start,this._right.direction,s))&&this._helper.copy(this._helper.fromXYZ(s,void 0,this._helper.getM(t.pos)),t.pos)}selectArrowFromStartPoint(t){this._selectedArrow=a.isPointInside(this.plane,this._pointToXYZ(t))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(t){return a.signedDistance(this.plane,this._pointToXYZ(t))}apply(t){this._offset(t,this.distance)}undo(t){this._offset(t,0)}canAccumulate(t){return t instanceof h&&this._edge.leftVertex.index===t._edge.leftVertex.index&&this._edge.rightVertex.index===t._edge.rightVertex.index&&this._edge.component===t._edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&n.equals(a.getNormal(this._plane),a.getNormal(t._plane))}accumulate(t,e){const i=this._plane[3]-e._plane[3]+e.distance;this._offset(t,i)}accumulateParams(t){const e=t.distance-t._plane[3];this.distance=e+this._plane[3]}clone(){const t=new h(this._helper,this._planeType,this._edge,this.distance,g.DEFERRED);return a.copy(t._plane,this._plane),a.copy(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=n.copy(r.create(),this._edgeDirection),t}_maybeEqualsVec3(t,e){return null==t&&null==e||null!=t&&null!=e&&n.equals(t,e)}_cloneNeighbor({start:t,end:e,direction:i,isOriginalDirection:s}){return{start:n.copy(r.create(),t),end:null!=e?n.copy(r.create(),e):null,direction:n.copy(r.create(),i),isOriginalDirection:s}}}const _=e.deg2rad(15),l=.001;var d,g;t.PlaneType=void 0,(d=t.PlaneType||(t.PlaneType={}))[d.XYZ=0]="XYZ",d[d.XY=1]="XY",function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(g||(g={})),t.OffsetEdgeVertex=h,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
