/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../geometry","../../core/arrayUtils","../../core/has","../../core/lang","../../core/mathUtils","../../core/screenUtils","../../core/libs/gl-matrix-2/factories/vec3f64","../../geometry/projection","../../geometry/support/meshVertexSpaceUtils","../../layers/graphics/hydratedFeatures","../../layers/graphics/sources/interfaces","../../support/elevationInfoUtils","../draw/support/drawUtils","../../geometry/Point"],(function(e,t,n,r,a,o,c,l,s,i,u,p,f,m,d){"use strict";function y(e,t){let n=null,r=null;return a=>{if("cancel"===a.action)return void(null!=r&&(r.execute({action:"cancel"}),n=null,r=null));const o={action:a.action,screenStart:a.start,screenEnd:a.screenPoint};"start"===a.action&&null==n&&(n=new b,r=new b,t(e,n,r,a.pointerType,o)),null!=n&&n.execute(o),"end"===a.action&&null!=n&&(n=null,r=null)}}function x(e,t){return e.events.on("drag",y(e,t))}function g(e,t){const n=[e.x,e.y,e.z??0],r=t,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const c=e=>{const t=(e.x-n[0])*a[0]+(e.y-n[1])*a[1];e.x=n[0]+t*a[0],e.y=n[1]+t*a[1]};return e=>(c(e.mapStart),c(e.mapEnd),{...e,axis:a})}function S(e){let t=null;return n=>{if("start"===n.action&&(t=E(e,n.mapStart.spatialReference)),null==t)return null;const r=n.mapEnd.x-n.mapStart.x,a=n.mapEnd.y-n.mapStart.y,o=n.mapEnd.z-n.mapStart.z;return t.move(r,a,o,n.action),{...n,translationX:r,translationY:a,translationZ:o}}}function h(e,t){return null==e?null:e.spatialReference.equals(t)?e.clone():s.project(e,t)}function E(e,t){const n=e.geometry,r=u.hydratedSpatialReference(t);if(null==n)return null;if("mesh"===n.type)return v(e,n,r);const a=h(n,r),o=n.spatialReference;return null==a?null:{move:(t,n,r)=>{const c=m.move(a.clone(),t,n,r);c.spatialReference.equals(o)?e.geometry=c:e.geometry=s.project(c,o)}}}function v(e,t,n){if(i.isRelativeVertexSpace(t.vertexSpace))return M(e,t,t.vertexSpace,n);if(!t.spatialReference.equals(n))return null;let r=0,a=0,o=0;return{move:(n,c,l)=>{const s=n-r,i=c-a,u=l-o;if(s||i||u){const p=new d(t.anchor.x+s,t.anchor.y+i,(t.anchor.z??0)+u,t.anchor.spatialReference);t.centerAt(p),e.notifyGeometryChanged(),r=n,a=c,o=l}}}}function M(e,t,n,r){const a=h(i.vertexSpaceOriginToPoint(t.vertexSpace,t.spatialReference),r),o=t.spatialReference;return null==a?null:{move:(t,r,c,i)=>{const u=m.move(a.clone(),t,r,c);if(u.spatialReference.equals(o))n.origin=l.fromValues(u.x,u.y,u.z??0);else{const e=s.project(u,o);null!=e&&(n.origin=l.fromValues(e.x,e.y,e.z??0))}const f="end"===i;e.notifyMeshTransformChanged(f?{action:p.MeshTransformUpdateAction.UpdateFastLocalOrigin}:{})}}}function z(e,t=null,n){let r=null;const a=null==t||e.spatialReference?.equals(t)?e=>e:e=>null!=e?s.project(e,t):e,o={exclude:[],...n};return t=>{if("start"===t.action&&(r=a(e.toMap(t.screenStart,o))),null==r)return null;const n=a(e.toMap(t.screenEnd,o));return null!=n?{...t,mapStart:r,mapEnd:n}:null}}function P(e){const t=e.map((e=>S(e))).filter(n.isSome);return e=>{const n=e.mapEnd.x-e.mapStart.x,r=e.mapEnd.y-e.mapStart.y,a=e.mapEnd.z-e.mapStart.z;return t.forEach((t=>t(e))),{...e,translationX:n,translationY:r,translationZ:a}}}function R(e,t){const n=new Map;for(const r of t)n.set(r,a.clone(e[r]));return t=>(n.forEach(((t,n)=>{e[n]=t})),t)}function D(e){return null!=e.geometry&&"mesh"===e.geometry.type?w(e,e.geometry):R(e,["geometry"])}function w(e,t){const{vertexSpace:n}=t;if("georeferenced"===n.type){const n=t.vertexAttributes.clonePositional();return r=>(t.vertexAttributes=n,e.notifyGeometryChanged(),r)}const r=l.clone(n.origin),a=t.transform?.clone();return n=>(t.transform=a,t.vertexSpace.origin=r,e.notifyMeshTransformChanged(),n)}function A(e){const t=e.map((e=>D(e))).filter((e=>null!=e));return e=>(t.forEach((t=>t(e))),e)}function T(){let e=0,t=0,n=0;return r=>{"start"===r.action&&(e=r.mapStart.x,t=r.mapStart.y,n=r.mapStart.z);const a=r.mapEnd.x-e,o=r.mapEnd.y-t,c=r.mapEnd.z-n;return e=r.mapEnd.x,t=r.mapEnd.y,n=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:c,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function U(){let e=0,t=0;return n=>{"start"===n.action&&(e=n.screenStart.x,t=n.screenStart.y);const r=n.screenEnd.x-e,a=n.screenEnd.y-t;return e=n.screenEnd.x,t=n.screenEnd.y,{...n,screenDeltaX:r,screenDeltaY:a}}}function j(e,t){let n=null,r=0,a=0;return l=>{if("start"===l.action&&(n=e.toScreen?.(t),null!=n&&(n.x<0||n.x>e.width||n.y<0||n.y>e.height?n=null:(r=l.screenStart.x-n.x,a=l.screenStart.y-n.y))),null==n)return null;const s=o.clamp(l.screenEnd.x-r,0,e.width),i=o.clamp(l.screenEnd.y-a,0,e.height),u=c.createScreenPoint(s,i);return l.screenStart=n,l.screenEnd=u,l}}const Z=()=>{};class b{constructor(){this.execute=Z}next(e,t=new b){return null!=e&&(this.execute=n=>{const r=e(n);null!=r&&t.execute(r)}),t}}function q(e,t,n=[]){if("2d"===e.type)return e=>e;let r=null;return a=>{"start"===a.action&&(r=e.toMap(a.screenStart,{exclude:n}),null!=r&&(r.z=f.getZForElevationMode(r,e,t)));const o=e.toMap(a.screenEnd,{exclude:n});null!=o&&(o.z=f.getZForElevationMode(o,e,t));const c=null!=r&&null!=o?{sceneStart:r,sceneEnd:o}:null;return{...a,scenePoints:c}}}function G(e,t,n){const r=t.elevationProvider.getElevation(e.x,e.y,e.z??0,e.spatialReference,"scene")??0,a=u.clonePoint(e);return a.z=r,a.hasZ=!0,a.z=f.getZForElevationMode(a,t,n),a}function C(e,t){if("2d"===e.type)return e=>e;let n=null;return r=>{"start"===r.action&&(n=G(r.mapStart,e,t));const a=G(r.mapEnd,e,t),o=null!=n&&null!=a?{sceneStart:n,sceneEnd:a}:null;return{...r,scenePoints:o}}}e.EventPipeline=b,e.addMapDelta=T,e.addScreenDelta=U,e.constrainToMapAxis=g,e.createDragEventPipelineCallback=y,e.createManipulatorDragEventPipeline=x,e.dragAtLocation=j,e.dragGraphic=S,e.dragGraphicMany=P,e.resetGraphic=D,e.resetGraphicMany=A,e.resetProperties=R,e.sceneSnappingAtLocation=q,e.sceneSnappingAtProjectedLocation=C,e.screenToMap=z,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
