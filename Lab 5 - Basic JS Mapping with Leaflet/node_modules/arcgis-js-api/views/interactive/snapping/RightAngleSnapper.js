/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/Cyclical","../../../core/quantityUtils","../../../core/libs/gl-matrix-2/math/vec2","../../../core/libs/gl-matrix-2/factories/vec2f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../support/elevationInfoUtils","../sketch/constraints","../sketch/normalizedPoint","./SnappingAlgorithm","./snappingUtils","./candidates/RightAngleSnappingCandidate","../support/viewUtils","../../support/angularMeasurementUtils","../../support/geodesicLengthMeasurementUtils"],(function(e,t,i,n,r,a,o,s,c,l,g,d,h,p,f,u){"use strict";class V extends g.SnappingAlgorithm{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],n=[];if(i.vertices.length<2)return n;const{view:r}=this,a=p.vectorToScreenPoint(e,t.spatialReference,s.absoluteHeightElevationInfo,r),o=i.vertices.at(-1);this._checkForSnappingCandidate(n,o.leftEdge,o,o.leftEdge.leftVertex,e,a,t);const c=i.vertices[0];return this._checkForSnappingCandidate(n,c.rightEdge,c,c.rightEdge.rightVertex,e,a,t),n}snapExistingVertex(e,t){const i=[],n=t.vertexHandle;if(n.component.vertices.length<3)return i;const{view:r}=this,a=p.vectorToScreenPoint(e,t.spatialReference,s.absoluteHeightElevationInfo,r),o=n.leftEdge,c=n.rightEdge;if(o?.leftVertex.leftEdge){const n=o.leftVertex.leftEdge;this._checkForSnappingCandidate(i,n,n.rightVertex,n.leftVertex,e,a,t)}if(c?.rightVertex.rightEdge){const n=c.rightVertex.rightEdge;this._checkForSnappingCandidate(i,n,n.leftVertex,n.rightVertex,e,a,t)}return i}_checkForSnappingCandidate(e,t,i,n,r,a,o){if(!this.edgeExceedsShortLineThreshold(t,o))return;const s=this.view,c=l.fromAnyMapPoint(i.pos,s,o),g=l.fromAnyMapPoint(n.pos,s,o);this._checkForSnappingCandidateNormalized(e,g,c,r,a,o)}_checkForSnappingCandidateNormalized(e,t,i,n,r,a){this._projectionRay(x,t,i,n,a),this._checkForSnappingCandidateAlongProjectedRay(e,t,i,x,n,r,a)}_projectionRay(e,t,i,n,r){this._projectionRayGeodesic(e,t,i,n,r)||this._projectionRayPlanar(e,t,i)}_projectionRayGeodesic(e,n,r,s,{spatialReference:c}){const l=f.radiansGeographicBetweenVec(n,r,c,c);if(null==l)return!1;const g=f.radiansGeographicBetweenVec(r,s,c,c);if(null==g)return!1;const d=Math.sign(t.cyclical2PI.shortestSignedDiff(l,g))*Math.PI*.5,h=i.createAngle(l+d,"radians","geographic"),p=o.create(),V=u.geodesicDistance(r,s,c);return null!=V&&(f.pointFromDistanceAlongAzimuth(p,r,c,i.valueInUnit(V,"meters"),h,"geodesic"),a.subtract(e,p,r),!0)}_projectionRayPlanar(e,t,i){const r=n.subtract(v,l.asVec2(i),l.asVec2(t));a.set(e,r[1],-r[0],0)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,r,g,f,u){const{spatialReference:V,pointer:x}=u,m=n.subtract(v,l.asVec2(g),l.asVec2(i)),S=n.dot(r,m)/n.squaredLength(r),y=n.scaleAndAdd(v,l.asVec2(i),r,S),E=l.fromValues(y[0],y[1],g[2]);if(d.squaredScreenDistance(f,p.vectorToScreenPoint(E,V,s.absoluteHeightElevationInfo,this.view))>this.squaredProximityThreshold(x)||this.isVertical(E,i,u)||this.isVertical(i,t,u))return;const A=a.scaleAndAdd(o.create(),i,r,Math.sign(S));e.push(new h.RightAngleSnappingCandidate({targetPoint:E,constraint:new c.VerticalHalfPlaneConstraint(i,l.fromVec3(A)),previousVertex:t,otherVertex:i,otherVertexType:h.OtherVertexType.CENTER,isDraped:"on-the-ground"===u.elevationInfo?.mode}))}}const v=r.create(),x=o.create();e.RightAngleSnapper=V,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
