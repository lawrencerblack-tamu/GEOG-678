/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../core/Error","../../core/has","./checkWebGLError","./enums","./GLObjectType","./TextureDescriptor","./ValidatedTextureDescriptor"],(function(e,t,i,r,s,o,a,n){"use strict";const l=4,h=null;let d=class e{constructor(e,i=null,r=null){if(this.type=o.GLObjectType.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=i;else{const r=n.ValidatedTextureDescriptor.validate(e,i);if(!r)throw new t("Texture descriptor invalid");this._descriptor=r}this._descriptor.target===s.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return a.estimateMemory(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(s.ResourceType.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,i){const r=this._descriptor;if(r.width!==e||r.height!==i){if(this._wasImmutablyAllocated)throw new t("Immutable textures can't be resized!");r.width=e,r.height=i,this._descriptor.target===s.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let t=s.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;t<=s.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}setData(e){this._setData(e)}_setData(i,o){if(!this._descriptor.context?.gl)return;const a=this._descriptor.context.gl;r.checkWebGLError(a),this._glName||(this._glName=a.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(s.ResourceType.Texture,this)),void 0===i&&(i=null);const n=this._descriptor,h=o??n.target,d=M(h);null===i&&(n.width=n.width||l,n.height=n.height||l,d&&(n.depth=n.depth??1));const u=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),p(n),this._configurePixelStorage(),r.checkWebGLError(a);const g=this._deriveInternalFormat();if(E(i)){let e="width"in i?i.width:i.codedWidth,t="height"in i?i.height:i.codedHeight;const s=1;i instanceof HTMLVideoElement&&(e=i.videoWidth,t=i.videoHeight),n.width&&n.height,d&&n.depth,n.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,g,n.hasMipmap,e,t,s),this._texImage(h,0,g,e,t,s,i),r.checkWebGLError(a),n.hasMipmap&&this.generateMipmap(),n.width||(n.width=e),n.height||(n.height=t),d&&!n.depth&&(n.depth=s)}else{const{width:e,height:s,depth:o}=n;if(null==e||null==s)throw new t("Width and height must be specified!");if(d&&null==o)throw new t("Depth must be specified!");if(n.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,g,n.hasMipmap,e,s,o),x(i)){const r=i.levels,l=A(h,e,s,o),d=Math.min(l-1,r.length-1);a.texParameteri(n.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,d);const p=g;if(!T(p))throw new t("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((e,t,i,s)=>{const o=r[Math.min(e,r.length-1)];this._compressedTexImage(h,e,p,t,i,s,o)}),d)}else this._texImage(h,0,g,e,s,o,i),r.checkWebGLError(a),n.hasMipmap&&this.generateMipmap()}c(a,this._descriptor),m(a,this._descriptor),_(this._descriptor.context,this._descriptor),r.checkWebGLError(a),this._descriptor.context.bindTexture(u,e.TEXTURE_UNIT_FOR_UPDATES)}updateData(i,r,s,o,a,n,l=0){n||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const h=this._descriptor,d=this._deriveInternalFormat(),{context:p,pixelFormat:c,dataType:m,target:_,isImmutable:u}=h;if(u&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");const T=p.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||s<0||o>h.width||a>h.height||r+o>h.width||s+a>h.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:g}=p;l&&g.pixelStorei(g.UNPACK_SKIP_ROWS,l),E(n)?g.texSubImage2D(_,i,r,s,o,a,c,m,n):x(n)?g.compressedTexSubImage2D(_,i,r,s,o,a,d,n.levels[i]):g.texSubImage2D(_,i,r,s,o,a,c,m,n),l&&g.pixelStorei(g.UNPACK_SKIP_ROWS,0),p.bindTexture(T,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(i,r,s,o,a,n,l,h){h||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const d=this._descriptor,p=this._deriveInternalFormat(),{context:c,pixelFormat:m,dataType:_,isImmutable:u,target:T}=d;if(u&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");M(T)||console.warn("Attempting to set 3D texture data on a non-3D texture");const g=c.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);c.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),(r<0||s<0||o<0||a>d.width||n>d.height||l>d.depth||r+a>d.width||s+n>d.height||o+l>d.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:E}=c;if(x(h))h=h.levels[i],E.compressedTexSubImage3D(T,i,r,s,o,a,n,l,p,h);else{const e=h;E.texSubImage3D(T,i,r,s,o,a,n,l,m,_,e)}c.bindTexture(g,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const i=this._descriptor;if(!i.hasMipmap){if(this._wasImmutablyAllocated)throw new t("Cannot add mipmaps to immutable texture after allocation");i.hasMipmap=!0,this._samplingModeDirty=!0,p(i)}i.samplingMode===s.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,i.samplingMode=s.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):i.samplingMode===s.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,i.samplingMode=s.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(i.target),this._descriptor.context.bindTexture(r,e.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,p(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor,t=e.context.gl;this._samplingModeDirty&&(c(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(m(t,e),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===s.PixelFormat.DEPTH_STENCIL&&(this._descriptor.internalFormat=s.PixelFormat.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case s.PixelType.FLOAT:switch(this._descriptor.pixelFormat){case s.PixelFormat.RGBA:return this._descriptor.internalFormat=s.SizedPixelFormat.RGBA32F;case s.PixelFormat.RGB:return this._descriptor.internalFormat=s.SizedPixelFormat.RGB32F;default:throw new t("Unable to derive format")}case s.PixelType.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case s.PixelFormat.RGBA:return this._descriptor.internalFormat=s.SizedPixelFormat.RGBA8;case s.PixelFormat.RGB:return this._descriptor.internalFormat=s.SizedPixelFormat.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===s.PixelFormat.DEPTH_STENCIL?s.PixelFormat.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:i,preMultiplyAlpha:r}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,i?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r?1:0)}_texStorage(e,i,r,s,o,a){const{gl:n}=this._descriptor.context;if(!u(i))throw new t("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=r?A(e,s,o,a):1;if(M(e)){if(null==a)throw new t("Missing depth dimension for 3D texture upload");n.texStorage3D(e,l,i,s,o,a)}else n.texStorage2D(e,l,i,s,o);this._wasImmutablyAllocated=!0}_texImage(e,i,r,s,o,a,n){const l=this._descriptor.context.gl,h=M(e),{isImmutable:d,pixelFormat:p,dataType:c}=this._descriptor;if(d){if(null!=n){const r=n;if(h){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.texSubImage3D(e,i,0,0,0,s,o,a,p,c,r)}else l.texSubImage2D(e,i,0,0,s,o,p,c,r)}}else{const d=n;if(h){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.texImage3D(e,i,r,s,o,a,0,p,c,d)}else l.texImage2D(e,i,r,s,o,0,p,c,d)}}_compressedTexImage(e,i,r,s,o,a,n){const l=this._descriptor.context.gl,h=M(e);if(this._descriptor.isImmutable){if(null!=n)if(h){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(e,i,0,0,0,s,o,a,r,n)}else l.compressedTexSubImage2D(e,i,0,0,s,o,r,n)}else if(h){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.compressedTexImage3D(e,i,r,s,o,a,0,n)}else l.compressedTexImage2D(e,i,r,s,o,0,n)}_forEachMipmapLevel(e,i=1/0){let{width:r,height:o,depth:a,hasMipmap:n,target:l}=this._descriptor;const h=l===s.TextureType.TEXTURE_3D;if(null==r||null==o||h&&null==a)throw new t("Missing texture dimensions for mipmap calculation");for(let t=0;e(t,r,o,a),n&&(1!==r||1!==o||h&&1!==a)&&!(t>=i);++t)r=Math.max(1,r>>1),o=Math.max(1,o>>1),h&&(a=Math.max(1,a>>1))}};function p(e){(null!=e.width&&e.width<0||null!=e.height&&e.height<0||null!=e.depth&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!")}function c(e,t){let i=t.samplingMode,r=t.samplingMode;i===s.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||i===s.TextureSamplingMode.LINEAR_MIPMAP_LINEAR?(i=s.TextureSamplingMode.LINEAR,t.hasMipmap||(r=s.TextureSamplingMode.LINEAR)):i!==s.TextureSamplingMode.NEAREST_MIPMAP_NEAREST&&i!==s.TextureSamplingMode.NEAREST_MIPMAP_LINEAR||(i=s.TextureSamplingMode.NEAREST,t.hasMipmap||(r=s.TextureSamplingMode.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,i),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,r)}function m(e,t){"number"==typeof t.wrapMode?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}function _(e,t){const i=e.capabilities.textureFilterAnisotropic;if(!i)return;e.gl.texParameterf(t.target,i.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}function u(e){return e in s.SizedPixelFormat}function T(e){return e in s.CompressedTextureFormat}function x(e){return null!=e&&"type"in e&&"compressed"===e.type}function g(e){return null!=e&&"byteLength"in e}function E(e){return null!=e&&!x(e)&&!g(e)}function M(e){return e===s.TextureType.TEXTURE_3D||e===s.TextureType.TEXTURE_2D_ARRAY}function A(e,t,i,r=1){let o=Math.max(t,i);return e===s.TextureType.TEXTURE_3D&&(o=Math.max(o,r)),Math.round(Math.log(o)/Math.LN2)+1}d.TEXTURE_UNIT_FOR_UPDATES=0,e.Texture=d,e.tracer=h,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
