/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../layers/graphics/featureConversionUtils","../../../../../layers/graphics/OptimizedFeature","../../../../../layers/graphics/OptimizedGeometry","../../../engine/webgl/definitions","../aggregation/ComputedAggregateField","../aggregation/GridCell","../aggregation/GridSpatialIndex","./AAggregateStrategy","./AProcessorStrategy","./support/WithDisplayId","../sources/FeatureSourceMessage","../support/ComputedAttributeStorage","../support/FeatureFilter","../support/FeatureMetadata","../support/FeatureSetReaderJSON","../../../tiling/TileKey"],(function(e,t,i,s,r,n,a,l,d,o,u,c,h,p,g,f,_){"use strict";const y=128;class S extends o.ASendState{constructor(e){super(e),this.didSend=!1,this.done=!1}}class m{constructor(e,t,i,s,r){this._level=e,this._scale=t,this._indexOptions=i,this._clusterRadius=s,this._store=r,this._cells=new Map,this._handledChunks=new Set,this._statistics=new Map,this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const e of this._clusters.values())this._store.releaseDisplayIdForObjectId(e.inner.id);this._clusters.clear()}*aggregatesWorldSpace(){for(const e of this._clusters.values()){const t=e.inner.getCentroid(null),s=new i.OptimizedFeature(t,e.inner.getAttributes(),null);s.objectId=e.inner.id,s.displayId=e.displayId,yield s}}clusters(){return this._clusters.values()}updateChunks(e,t){let i=!1;for(const a of e){const e=a.queryInfo;if("tileId"in e){if(new _(e.tileId).level!==this._level)continue}if(!this._handledChunks.has(a.normalizedChunkId)){this._handledChunks.add(a.normalizedChunkId),i=!0;a.getGridIndex({...this._indexOptions,scale:this._scale}).putCells(this._cells)}}const s={xMin:1/0,yMin:1/0,xMax:-1/0,yMax:-1/0},r=l.pixelsPerMapUnit(this._indexOptions.spatialReference,this._scale),n=this._indexOptions.cellSize;for(const{subscription:a}of t){const e=a.tile.bounds,t=Math.floor(e[0]*r/n),i=Math.floor(e[1]*r/n),l=Math.ceil(e[2]*r/n),d=Math.ceil(e[3]*r/n);s.xMin=Math.min(s.xMin,t),s.yMin=Math.min(s.yMin,i),s.xMax=Math.max(s.xMax,l),s.yMax=Math.max(s.yMax,d)}return null!=this._lastCellBounds&&s.xMin===this._lastCellBounds.xMin&&s.yMin===this._lastCellBounds.yMin&&s.yMin===this._lastCellBounds.yMin&&s.yMax===this._lastCellBounds.yMax||(i=!0,this._lastCellBounds=s),i&&this._clusterCells(s),i}async updateStatistics(e){let t=!1;for(const i of this._clusters.values())i.inner.count>1&&(t=this._updateAggregateStatistics(this._statistics,i.inner)||t);if(t){const t=Array.from(this._statistics.entries()).map((([e,t])=>({fieldName:e,minValue:t.minValue,maxValue:t.maxValue})));await e.container.updateStatistics(this._level,t)}}createAggregateFeatures(e,t){const n=e.subscription,a=[],l=n.tile.transform;for(const d of this._clusters.values()){let e=d.inner.getCentroidX(l);const t=d.inner.getCentroidY(l),o=n.tile.lod,u=o.wrap?o.worldSize[0]:null,c=1===d.inner.count?d.inner.firstObjectId:d.inner.id,h=d.displayId;if(null!=u)if(1===u){const n=new s([],[e,t]),l=new i.OptimizedFeature(n,d.inner.getAttributes(),null);l.geometry.coords[0]-=r.tileSize,l.objectId=c,l.displayId=h,a.push(l);const o=new s([],[e,t]),u=new i.OptimizedFeature(o,d.inner.getAttributes(),null);u.geometry.coords[0]+=r.tileSize,u.objectId=c,u.displayId=h,a.push(u)}else e>r.tileSize+r.tileSize/2?e-=u*r.tileSize:e<-r.tileSize/2&&(e+=u*r.tileSize);if(e<r.tileSize+y&&e>=-y&&t<r.tileSize+y&&t>=-y){const r=new s([],[e,t]),n=new i.OptimizedFeature(r,d.inner.getAttributes(),null);n.objectId=c,n.displayId=h,a.push(n)}}return f.FeatureSetReaderJSON.fromOptimizedFeatures(a,t,n.tile.transform)}_clusterCells(e){let t=Array.from(this._cells.values());t=t.sort(((e,t)=>t.count-e.count));const i=[];for(const a of this._clusters.values())i.push(a.inner.id);this._clusters.clear();const s=this._clusterRadius*(1/l.pixelsPerMapUnit(this._indexOptions.spatialReference,this._scale)),r=1+this._clusterRadius/this._indexOptions.cellSize,n=new Set;for(const l of t){if(n.has(l.id))continue;if(l.gridX<e.xMin||l.gridX>e.xMax||l.gridY<e.yMin||l.gridY>e.yMax)continue;const t=this._store.createDisplayIdForObjectId(l.id),i=new u.WithDisplayId(l.clone(),t);n.add(l.id),this._clusters.set(l.id,i);const d=l.centroidXWorld,o=l.centroidYWorld;for(let e=l.gridY-r;e<=l.gridY+r;e++)for(let t=l.gridX-r;t<=l.gridX+r;t++){if(e===l.gridY&&t===l.gridX)continue;const r=this._cells.get(a.GridCell.createId(t,e));if(!r||n.has(r.id))continue;const u=Math.abs(r.centroidXWorld-d),c=Math.abs(r.centroidYWorld-o);u<s&&c<s&&(i.inner.merge(r),n.add(r.id))}}for(const a of i)this._store.releaseDisplayIdForObjectId(a)}_updateAggregateStatistics(e,t){let i=!1;for(const s of t.statistics.values()){if("esriFieldTypeString"===s.field.type)continue;const t=s.value,r=s.field,n=e.get(r.name);if(n){const{minValue:e,maxValue:s}=n,r=Math.min(n.minValue,t),a=Math.max(n.maxValue,t);e===r&&s===a||(n.minValue=r,n.maxValue=a,i=!0)}else e.set(r.name,{minValue:t,maxValue:t}),i=!0}return i}}class I extends d.AAggregateStrategy{static async create(e,t,i,s,r,a){const l=new h.ComputedAttributeStorage({spatialReference:i}),d={fields:await Promise.all(t.fields.map((async e=>n.ComputedAggregateField.create(l,e)))),spatialReference:i,featureFilter:t.featureFilter?await p.create({geometryType:s.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:s.metadata.timeInfo,fieldsIndex:s.metadata.fieldsIndex,spatialReference:i,filterJSON:t.featureFilter}):null,cellSize:t.clusterRadius/4,timeZone:a};return new I(e,t.clusterRadius,d,t.fields,s,r)}constructor(e,t,i,s,r,n){super(r,n,i.spatialReference,i.fields),this._connection=e,this._clusterRadius=t,this._indexOptions=i,this._cellsPerScale=new Map,this._metadata=new g.FeatureMetadata({geometryType:"esriGeometryPoint",objectIdField:"aggregateId",fields:[...s,...this._source.metadata.fieldsIndex.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],globalIdField:null,spatialReference:r.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}get enablePixelBuffering(){return!1}invalidate(){super.invalidate();for(const e of this._cellsPerScale.values())e.destroy();this._cellsPerScale.clear()}onSubscribe(e){super.onSubscribe(e),this._requiredLevel=e.tile.level,this._requiredScale=e.tile.scale}createState(e){return new S(e)}async*applyOverride(e){for(const t of this._cellsPerScale.values())t.destroy();this._cellsPerScale.clear();for(const t of this._sendStates.values())t.done=!1}displayMap(e,t,i){const s=new Map(e.map((e=>[t(e),e]))),r=[],n=this._getClusterState(this._requiredLevel,this._requiredScale);for(const a of n.clusters()){const e=s.get(a.inner.id);if(null==e){if(1===a.inner.count){const e=s.get(a.inner.firstObjectId);if(null!=e){const t=i(a.displayId,e,a.inner.firstObjectId);r.push(t),s.delete(a.inner.firstObjectId)}}}else{const t=i(a.displayId,e,a.inner.id);r.push(t),s.delete(a.inner.id)}}return r}getDisplayFeatures(e){const i=new Set(e),s=new Set,r=[],n=[],a=this._getClusterState(this._requiredLevel,this._requiredScale);for(const l of a.aggregatesWorldSpace())if(i.has(l.displayId)&&!s.has(l.displayId)){const e=t.convertToFeature(l,this._metadata.geometryType,!1,!1);if(s.add(l.displayId),1===e.attributes.cluster_count){r.push({...e,displayId:l.displayId});continue}n.push({...e,displayId:l.displayId})}return{features:r,aggregates:n}}getFeatureObjectIdsForAggregate(e){const t=this._getClusterState(this._requiredLevel,this._requiredScale);for(const i of t.clusters())if(i.inner.id===e)return Array.from(i.inner.objectIds);return[]}async*updateChunks(){const e=this._source.chunks();if(!e.length)return;const t=this._getClusterState(this._requiredLevel,this._requiredScale),i=Array.from(this._sendStates.values()).filter((e=>e.subscription.tile.level===this._requiredLevel));if(t.updateChunks(e,i)||!this._source.updateTracking.updating)for(const n of i)n.subscription.tile.level===this._requiredLevel&&(n.didSend=!1,n.done=!1);const s=Array.from(this._sendStates.values()).filter((e=>e.done)).map((e=>e.subscription.tile.key)),r=new Set(s);for(const n of this._sendStates.values()){if(this._source.updateTracking.updating){if(s.some((e=>e.containsChild(n.subscription.tile.key))))continue;if(n.subscription.tile.key.getChildKeys().every((e=>r.has(e))))continue}n.didSend||n.subscription.tile.level!==this._requiredLevel||(n.didSend=!0,yield*this._update(n,t,this._source))}await t.updateStatistics(this._connection)}forEachAggregateWorldSpace(e){if(null==this._requiredLevel||null==this._requiredScale)return;const t=this._getClusterState(this._requiredLevel,this._requiredScale);for(const i of t.aggregatesWorldSpace())e(i)}_getClusterState(e,t){if(null==e||null==t)throw new Error("InternalError: Level and scale must be defined");let i=this._cellsPerScale.get(t);return i||(i=new m(e,t,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(t,i)),i}async*_update(e,t,i){if(e.done)return;const s=t.createAggregateFeatures(e,this._metadata);this.events.emit("changed"),e.done=!i.updateTracking.updating;const r=s.getCursor(),n=e.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);for(;r.next();)this._attributeStore.setAttributeData(r.getDisplayId(),r,n);const a=new c.FeatureTileAppendMessage(e.subscription,s,!0,e.done,{});yield a}}e.ClusterState=S,e.ClusterStrategy=I,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
