/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../geometry","../../../../../geohash/geohashUtils","../../../../../layers/graphics/featureConversionUtils","../../../../../layers/graphics/OptimizedFeature","../../../../../layers/graphics/data/projectionSupport","../aggregation/ComputedAggregateField","./AAggregateStrategy","./AProcessorStrategy","../sources/FeatureSourceMessage","../support/ComputedAttributeStorage","../support/FeatureFilter","../support/FeatureMetadata","../support/FeatureSetReaderJSON","../../../tiling/TileKey","../../../../../geometry/SpatialReference"],(function(e,t,s,a,r,i,o,n,d,l,c,u,p,h,f,g){"use strict";class y extends d.ASendState{constructor(e,t){super(e),this.bins=new Map,this.done=!1,this._store=t}reset(){this.destroy(),this.bins.clear(),this.done=!1,this.handledChunks.clear()}destroy(){const e=this.subscription.tile.key.level;for(const t of this.bins.values()){const s=t.cachedFeature?.objectId;null!=s&&this._store.releaseDisplayIdForObjectId(`${s}.${e}`)}}*featuresWorldSpace(){for(const e of this.bins.values()){const t=e.cachedFeature;if(t){const e=t.clone();e.geometry&&a.unquantizeOptimizedGeometry(e.geometry,e.geometry,!1,!1,this.subscription.tile.transform),yield e}}}getGeohashBounds(e,t){const a=this.subscription.tile;return s.getGeohashBounds(a.extent,a.resolution,t,e)}}class m extends n.AAggregateStrategy{static async create(e,t,s,a,r){const n=new c.ComputedAttributeStorage({spatialReference:t}),d=e.fixedBinLevel,l=await Promise.all(e.fields.map((async e=>o.ComputedAggregateField.create(n,e)))),p=e.featureFilter?await u.create({geometryType:s.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:s.metadata.timeInfo,fieldsIndex:s.metadata.fieldsIndex,spatialReference:t,filterJSON:e.featureFilter}):null;return await i.checkProjectionSupport(t,g.WGS84),new m({fields:l,geohashLevel:d,spatialReference:t,featureFilter:p,timeZone:r},e.fields,s,a)}constructor(e,t,s,a){super(s,a,e.spatialReference,e.fields),this._indexOptions=e,this._metadata=new p.FeatureMetadata({geometryType:"esriGeometryPolygon",objectIdField:"aggregateId",fields:t,globalIdField:null,spatialReference:s.metadata.spatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,typeIdField:null,types:null})}createState(e){return new y(e,this._attributeStore)}async*applyOverride(e){for(const t of this._sendStates.values()){t.reset();const e=new l.FeatureTileAppendMessage(t.subscription,h.FeatureSetReaderJSON.empty(this._source.metadata),!0,!1,{});yield e}}displayMap(e,t,s){const a=new Map(e.map((e=>[t(e),e]))),r=[];for(const i of this._sendStates.values())for(const e of i.featuresWorldSpace()){const{objectId:t,displayId:i}=e,o=a.get(t);if(null!=o){const e=s(i,o,t);r.push(e),a.delete(t)}}return r}getDisplayFeatures(e){const t=new Set(e),s=new Set,r=[];for(const i of this._sendStates.values())for(const e of i.featuresWorldSpace())t.has(e.displayId)&&!s.has(e.objectId)&&(e.geometry&&r.push({...a.convertToFeature(e,this._metadata.geometryType,!1,!1),displayId:e.displayId}),s.add(e.objectId));return{features:[],aggregates:r}}getFeatureObjectIdsForAggregate(e){for(const t of this._sendStates.values())for(const s of t.bins.values())if(s.id===e)return Array.from(s.objectIds);return[]}async*updateChunks(){if(this._source.chunks().length)for(const e of this._sendStates.values())yield*this._update(e,this._source)}forEachAggregateWorldSpace(e){for(const t of this._sendStates.values())for(const s of t.featuresWorldSpace())e(s)}async*_update(e,t){const{handledChunks:s,subscription:a,bins:i}=e,{spatialReference:o,geohashLevel:n}=this._indexOptions,d=a.tile;if(e.done)return;for(const r of t.chunks()){if(s.has(r.chunkId))continue;s.add(r.chunkId);const t=r.queryInfo;if("tileId"in t){const e=new f(t.tileId);if(e.level!==d.level||e.world!==d.key.world)continue}const a=r.getGeohashIndex(this._indexOptions),l=e.getGeohashBounds(o,n);null!=l&&a.putBins(i,l)}const c=[],u=a.tile.transform,p=a.tile.key.level;for(const l of i.values()){if(l.cachedFeature)l.cachedFeature.attributes=l.getAttributes();else{const e=l.getGeometry(this.spatialReference,u),t=new r.OptimizedFeature(e,l.getAttributes(),null);e||(t.centroid=l.getGeometryCentroid(this.spatialReference,u)),t.objectId=l.id,t.displayId=this._attributeStore.createDisplayIdForObjectId(`${t.objectId}.${p}`),l.cachedFeature=t}c.push(l.cachedFeature)}this.events.emit("changed"),e.done=!t.updateTracking.updating;const g=h.FeatureSetReaderJSON.fromOptimizedFeatures(c,this._metadata,u),y=g.getCursor(),m=e.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);for(;y.next();)this._attributeStore.setAttributeData(y.getDisplayId(),y,m);const S=new l.FeatureTileUpdateMessage(e.subscription,g,[],e.done,{});yield S}}e.BinningState=y,e.BinningStrategy=m,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
