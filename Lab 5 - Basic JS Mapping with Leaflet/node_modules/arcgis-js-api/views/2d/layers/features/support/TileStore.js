/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../../../core/Evented","../../../../../core/has","../../../../../chunks/rbush","../../../../../geometry/support/aaBoundingRect","../../../../../geometry/support/spatialReferenceUtils","./Tile","../../../tiling/TileCoverage","../../../tiling/TileKey"],(function(e,t,s,i,n,o,r,h){"use strict";const l={added:[],removed:[]},d=new Set,c=new h(0,0,0,0);function a(e,t){const s=n.getInfo(t);if(!s)return null;const[o,r]=s.valid;return e[2]>r?[i.create([e[0],e[1],r,e[3]]),i.create([o,e[1],o+e[2]-r,e[3]])]:e[0]<o?[i.create([o,e[1],e[2],e[3]]),i.create([r-(o-e[0]),e[1],r,e[3]])]:null}class u extends e{constructor(e){super(),this._tiles=new Map,this._index=s.rbush(9,t("esri-csp-restrictions")?e=>({minX:e.bounds[0],minY:e.bounds[1],maxX:e.bounds[2],maxY:e.bounds[3]}):[".bounds[0]",".bounds[1]",".bounds[2]",".bounds[3]"]),this.tiles=[],this.tileScheme=e}destroy(){this.clear()}clear(){this.tiles.length=0,this._tiles.clear(),this._index.clear()}has(e){return this._tiles.has(e)}get(e){return this._tiles.get(e)}getIntersectingTiles(e){if(!e||0===i.width(e)||0===i.height(e))return[];const t=a(e,this.tileScheme.spatialReference);return null!=t?[...new Set([...this.boundsIntersections(t[0]),...this.boundsIntersections(t[1])])]:this.boundsIntersections(e)}boundsIntersections(e){return this._index.search({minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]})}updateTiles(e){const t={added:[],removed:[]};for(const s of e.added)if(!this.has(s)){const e=new o.Tile(this.tileScheme,s);this._tiles.set(s,e),this._index.insert(e),t.added.push(e)}for(const s of e.removed)if(this.has(s)){const e=this.get(s);this._tiles.delete(s),this._index.remove(e),t.removed.push(e)}this.tiles.length=0,this._tiles.forEach((e=>this.tiles.push(e))),(t.added.length||t.removed.length)&&this.emit("update",t)}setViewState(e){const t=this.tileScheme.getTileCoverage(e,0);if(!t)return;const{spans:s,lodInfo:i}=t,{level:n}=i;if(s.length>0)for(const{row:r,colFrom:h,colTo:a}of s)for(let e=h;e<=a;e++){const t=c.set(n,r,i.normalizeCol(e),i.getWorldForColumn(e)).id;if(d.add(t),!this.has(t)){const e=new o.Tile(this.tileScheme,t);this._tiles.set(t,e),this._index.insert(e),this.tiles.push(e),l.added.push(e)}}for(let o=this.tiles.length-1;o>=0;o--){const e=this.tiles[o];d.has(e.id)||(this._tiles.delete(e.id),this.tiles.splice(o,1),this._index.remove(e),l.removed.push(e))}(l.added.length||l.removed.length)&&this.emit("update",l),r.pool.release(t),d.clear(),l.added.length=0,l.removed.length=0}}return u}));
