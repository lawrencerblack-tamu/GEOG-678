/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../core/has","../../../../core/Logger","../../../../core/libs/gl-matrix-2/factories/mat2df32","./AFeatureTile","./definitions","./DisplayEntity","./enums","./FeatureDisplayList","./ReshufflePlan","./collisions/LabelMetric","./cpuMapped/MappedMesh","./mesh/meshDebugUtils","./util/Reader","./util/serializationUtils"],(function(e,t,s,i,r,n,d,o,h,a,l,u,f,_,c){"use strict";const p=()=>s.getLogger("esri.views.2d.engine.webgl.FeatureTile");let y=0;class m extends r.AFeatureTile{constructor(e,t,s,r,n=!1){super(e,t,s,r),this._meshes=new Map,this._entities=[],this._invalidated=!1,this._nextUploadAllowed=!1,this.tileAge=y++,this._metrics=[],this._entityIds=new Set,this._entityIdsFromBuffer=new Set,this._attributeEpoch=0,this._encounteredEnd=!1,this.visible=!0,this.transforms.labelMat2d=i.create(),this.enableDeferredUploads=n}destroy(){super.destroy(),this.clear()}clear(){for(const e of this._meshes.values())e.destroy();this._meshes.clear(),this._entities=[],this._metrics=[],this._displayList=null,this._invalidated=!0,this._entityIds.clear(),this._nextUploadAllowed=!0}beforeRender(e){super.beforeRender(e),this._needsReshuffle&&e.reshuffleManager.schedule(this)}tryReady(e){const s=this._invalidated&&!this._uploadAllowed;return!(this._isReady||s||!this._encounteredEnd||!(e>=this._attributeEpoch))&&(t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.ready [epoch=${e}]`),this.ready(),this.requestRender(),!0)}get labelMetrics(){return this._metrics}get hasData(){return!!this._meshes.size}get needsUpload(){return this._invalidated}get _uploadAllowed(){return!this.enableDeferredUploads||this._nextUploadAllowed}upload(){this._nextUploadAllowed=!0}getDisplayList(e,t,s=o.FeatureBatchingStrategy.BATCHING){if(this._uploadAllowed&&this._invalidated){this._entities.sort(((e,t)=>{const s=t.sortKey,i=e.sortKey;return i===s?e.id-t.id:i-s})),s===o.FeatureBatchingStrategy.BATCHING&&this.reshuffle(!0),this._displayList=h.DisplayList.fromDisplayEntities(this._entities,this,t,s);for(const e of this._meshes.values())e.upload();this.debugInfo.display.length=this._displayList.length,this.debugInfo.display.minOrderedLength=this._displayList.minOrderedLength,this.debugInfo.display.minUnorderedLength=this._displayList.minUnorderedLength,this.requestRender(),this._invalidated=!1,this._nextUploadAllowed=!1}return this._displayList}getMesh(e){if(!this._meshes.has(e))throw new Error(`InternalError: Unable to find VAO for instance: ${e}`);return this._meshes.get(e)}getSortKeys(e){const t=new Map;for(const{id:s,sortKey:i}of this._entities)if(e.has(s)&&t.set(s,i),t.size===e.size)break;return t}onMessage(e){switch(e.type){case"append":this._onAppendMessage(e);break;case"update":this._onUpdateMessage(e)}if(this._aggregateMemoryStats(),this.requestRender(),e.end){if(t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.end [epoch=${e.attributeEpoch}]`),!e.attributeEpoch)throw new Error("InternalError: Attribute epoch not defined.");this._attributeEpoch=e.attributeEpoch,this._encounteredEnd=!0}}_onAppendMessage(e){if(t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.append`,{append:f.debugMeshDataInfo(e?.append)}),e.clear&&this.clear(),!e.append)return;const s=c.deserializeList(new _(e.append.entities),d);this._insert(s,e.append.data,!1)}_onUpdateMessage(e){t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.update`,{isPixelBuffer:e.isPixelBuffer,modify:f.debugMeshDataInfo(e.modify),remove:e.remove});const s=c.deserializeList(new _(e.modify.entities),d),i=s.map((e=>e.id)),r=e.isPixelBuffer??!1,n=[...e.remove,...i];r?this._removeByIdsFromBuffer(n):this._removeByIds(n),this._insert(s,e.modify.data,r)}reshuffle(e=!1){if(this.destroyed)return;const s=new Map;for(const t of this._entities)for(const i of t.records){const t=this._meshes.get(i.instanceId);let r=s.get(t);r||(r=new a.ReshufflePlan(e),s.set(t,r)),r.copyRecord(i)}for(const[t,i]of s)t.reshuffle(i);this._invalidated=!0,this._aggregateMemoryStats(),t("esri-2d-update-debug")&&p().info(`Tile ${this.key.id} was reshuffled.`)}copyPixelBufferedEntitesFrom(e,t,s,i){const r=s*n.tileSize,o=i*n.tileSize;for(const n of e._entities){let s=null;for(const i of n.records)if(i.overlaps&t){const t=this._ensureMesh(i.instanceId),h=e.getMesh(i.instanceId),a=t.copyRecordFrom(h,i,r,o);s||(s=new d(n.id,n.sortKey),this._entityIdsFromBuffer.add(n.id),this._entities.push(s)),s.records.push(a)}}this._invalidated=!0}_ensureMesh(e){return this._meshes.has(e)||this._meshes.set(e,new u.MappedMesh(this._stage.bufferPool)),this._meshes.get(e)}_insert(e,t,s){if(!e.length)return;this._removeDuplicatedBufferedEntites(e);const i=this._insertVertexData(t);for(const r of e){for(const e of r.records)e.updateBaseOffsets(i.get(e.instanceId));s?this._tryInsertBufferedEntity(r):this._insertEntity(r)}this._invalidated=!0}_insertVertexData(e){const t=new Map;for(const s of e){const{instanceId:e}=s,i=this._ensureMesh(e).append(s);if(s.metrics){const e=c.deserializeList(new _(s.metrics),l.LabelMetric)??[];this._metrics.push(...e)}t.set(e,i)}return t}_insertEntity(e){t("esri-2d-update-debug")&&this._entityIds.has(e.id)&&console.error(`Tile ${this.key.id} insertEnitty: Already have entityId ${e.id}`),this._entityIds.add(e.id),this._entities.push(e)}_tryInsertBufferedEntity(e){this._entityIds.has(e.id)?this._removeRecordsFromMesh(e.records):(this._entityIdsFromBuffer.add(e.id),this._entities.push(e))}_removeDuplicatedBufferedEntites(e){if(!this._entityIdsFromBuffer.size)return;const t=[];for(const s of e)this._entityIdsFromBuffer.has(s.id)&&t.push(s.id);this._removeByIds(t)}_removeByIdsFromBuffer(e){this._removeByIds(e.filter((e=>this._entityIdsFromBuffer.has(e))))}_removeByIds(e){if(0===e.length)return;const t=new Set(e),s=[];for(const i of this._entities)t.has(i.id)?this._remove(i):s.push(i);this._entities=s,this._invalidated=!0}_remove(e){this._removeRecordsFromMesh(e.records),this._entityIds.delete(e.id),this._entityIdsFromBuffer.delete(e.id)}_removeRecordsFromMesh(e){for(const t of e){const{instanceId:e,indexStart:s,indexCount:i,vertexStart:r,vertexCount:n}=t;this._meshes.get(e)?.remove(s,i,r,n)}}_aggregateMemoryStats(){this.debugInfo.memory.bytesUsed=0,this.debugInfo.memory.bytesReserved=0;for(const[e,t]of this._meshes)this.debugInfo.memory.bytesUsed+=t.memoryStats.bytesUsed,this.debugInfo.memory.bytesReserved+=t.memoryStats.bytesReserved}get _needsReshuffle(){if(this.destroyed)return!1;const{bytesUsed:e,bytesReserved:t}=this.debugInfo.memory,s=e/t,{minOrderedLength:i,length:r}=this.debugInfo.display,d=i/r;return t>n.RESHUFFLING_EXEMPT_MEMORY_BYTES&&s<n.RESHUFFLING_TARGET_MEMORY_EFFICIENCY||r>n.RESHUFFLING_EXEMPT_DRAW_CALLS&&d<n.RESHUFFLING_TARGET_DRAW_EFFICIENCY}}e.FeatureTile=m,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
