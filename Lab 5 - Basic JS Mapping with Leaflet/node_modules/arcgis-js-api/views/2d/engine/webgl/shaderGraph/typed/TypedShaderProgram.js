/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../../core/Error","../../../../../../core/Logger","../../../../../../core/object","../../../../../../core/RandomLCG","../../../../../../core/has","../../../../../webgl/checkWebGLError","../../../../../webgl/enums","../../../../../webgl/FramebufferObject","../../../../../webgl/Program","../../../../../webgl/GLObjectType","../../../../../webgl/Texture","../../Utils"],(function(e,r,t,o,i,n,s,a,f,m,c,u,l){"use strict";const h=()=>t.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function g(e,t,o){const i=t.length;if(i!==o){const n=new r("Invalid Uniform",`Invalid length, expected ${o} but got ${i}`,{uniformName:e,values:t});h().errorOnce(n)}}class d{constructor(e,r,t,o,i,n){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=e,this.fragmentShader=r,this._locations=t,this._locationInfo=o,this._uniformBindings=i,this._transformFeedbackBindings=n}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(e){this._uniforms=e}cleanupTemporaryTextures(){for(const e of this._temporaryTextures)e.dispose();this._temporaryTextures=[]}bind(e){const r=this._uniforms;if(!this._program){const r=new Map;for(const[e,o]of this._locations)r.set(e,o);const t=[];for(const e of this._transformFeedbackBindings??[]){const{index:r,propertyKey:o}=e;t[r]=`v_${o}`}this._program=new m.Program(e,this.vertexShader,this.fragmentShader,r,new Map,t)}const t=this._program;e.useProgram(t);for(const i of this._uniformBindings){const{shaderModulePath:n,uniformName:s,uniformType:a,uniformArrayLength:f}=i,m=o.getDeepValue(n,r);if(null==m){if("sampler2D"===a)continue;throw new Error(`Failed to find uniform value for ${n}`)}switch("array"===a?i.uniformArrayElementType:a){case"sampler2D":{const{unit:r,texture:o}=m;if(t.setUniform1i(s,r),"type"in o)e.bindTexture(o,r);else{const t=l.createTexture(e,o.descriptor,o.data);e.bindTexture(t,r)}break}case"int":if(!f){t.setUniform1i(s,m);break}g(i.uniformName,m,f),t.setUniform1iv(s,m);break;case"float":if(!f){t.setUniform1f(s,m);break}g(i.uniformName,m,f),t.setUniform1fv(s,m);break;case"vec2":if(!f){t.setUniform2f(s,m[0],m[1]);break}g(i.uniformName,m,f),t.setUniform2fv(s,m.flat());break;case"vec3":if(!f){t.setUniform3f(s,m[0],m[1],m[2]);break}g(i.uniformName,m,f),t.setUniform3fv(s,m.flat());break;case"vec4":if(!f){t.setUniform4f(s,m[0],m[1],m[2],m[3]);break}g(i.uniformName,m,f),t.setUniform4fv(s,m.flat());break;case"mat3":t.setUniformMatrix3fv(s,m.flat());break;case"mat4":t.setUniformMatrix4fv(s,m.flat());break;default:throw new Error(`Unable to set uniform for type ${a}`)}}}}e.TypedShaderProgram=d,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
