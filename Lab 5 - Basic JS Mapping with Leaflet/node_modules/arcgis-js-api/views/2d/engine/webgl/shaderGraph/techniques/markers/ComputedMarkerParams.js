/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../../../core/screenUtils","../../../../../../../symbols/cim/enums","../../../../../../../symbols/cim/utils","../../../definitions"],(function(t,e,i,s,o){"use strict";class h{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const i=new h(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:s,width:o,height:r,angle:n,alignment:a,outlineSize:c,referenceSize:l,sprite:f,overrideOutlineColor:m}=t;i.rawWidth=e.pt2px(o),i.rawHeight=e.pt2px(r),i.angle=n,i.alignment=a,i.outlineSize=e.pt2px(c),i.referenceSize=e.pt2px(l),i.overrideOutlineColor=m,i.offsetX=e.pt2px(t.offsetX),i.offsetY=e.pt2px(t.offsetY),"simple"!==s||f.sdf||(i.rawWidth=f.width,i.rawHeight=f.height);const p=2;return i.sizeRatio=f.sdf?p:1,i._computeSize(t,!1),i}static fromComplexMeshParams(t){const i=new h(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:o,transforms:r,size:n,scaleX:a,anchorX:c,anchorY:l,angle:f,colorLocked:m,frameHeight:p,widthRatio:d,offsetX:u,offsetY:x,outlineSize:g,referenceSize:z,scaleFactor:S,sizeRatio:w,isAbsoluteAnchorPoint:X,rotateClockwise:Y,scaleSymbolsProportionally:P,sprite:H}=t;if(r&&r.infos.length>0){const t=s.applyParentTransform(n,f,Y,u,x,r);n=t.size,f=t.rotation,u=t.offsetX,x=t.offsetY,Y=!1}S&&(n*=S,u*=S,x*=S);const M=a*(H.width/H.height);i.alignment=o,i.rawHeight=e.pt2px(n),i.rawWidth=i.rawHeight*M,i.referenceSize=e.pt2px(z),i.sizeRatio=w,i.angle=f,i.rotateClockwise=Y,i.anchorX=c,i.anchorY=l,i.offsetX=e.pt2px(u),i.offsetY=e.pt2px(x),X&&n&&(H.sdf?i.anchorX=c/(n*d):i.anchorX=c/(n*M),i.anchorY=l/n);const y=P&&p?n/p:1;return i.outlineSize=0===g||isNaN(g)?0:e.pt2px(g)*y,i.scaleSymbolsProportionally=P,i.colorLocked=m,i._computeSize(t,!0),i}constructor(t,e,s,o,h,r,n){this.sprite=t,this.color=e,this.outlineColor=s,this.minPixelBuffer=o,this.placement=h,this.scaleInfo=r,this.effects=n,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.alignment=i.Alignment.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:i,hasSizeVV:s}=t,h=!!i.sdf,{rawWidth:r,rawHeight:n,sizeRatio:a,outlineSize:c}=this,l=r*a,f=n*a;if(h&&!s){const t=e&&r>n?l:r,i=n,s=c+2*1;this.computedWidth=Math.min(t+s,l),this.computedHeight=Math.min(i+s,f)}else this.computedWidth=l,this.computedHeight=f;const m=h?o.sdfTextureSize/Math.max(l,f):1,p=.5*(l-this.computedWidth)*m,d=.5*(f-this.computedHeight)*m,u=i.rect.x+o.spritePadding+p,x=i.rect.y+o.spritePadding+d,g=u+i.width-2*p,z=x+i.height-2*d;this.texXmin=Math.floor(u),this.texYmin=Math.floor(x),this.texXmax=Math.ceil(g),this.texYmax=Math.ceil(z),this.computedWidth*=(this.texXmax-this.texXmin)/(g-u),this.computedHeight*=(this.texYmax-this.texYmin)/(z-x),this.anchorX*=l/this.computedWidth,this.anchorY*=f/this.computedHeight}}t.ComputedMarkerParams=h,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
