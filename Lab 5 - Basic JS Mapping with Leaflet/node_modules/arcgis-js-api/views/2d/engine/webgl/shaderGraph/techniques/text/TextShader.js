/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../../../chunks/tslib.es6","../../../definitions","../../GraphShaderModule","../../graph/glsl","../shaders/AFeatureShader","../shaders/constants","../shaders/hittestUtils","../shaders/MosaicInfo","../shaders/utils","../shaders/VisualVariableColor","../shaders/VisualVariableOpacity","../shaders/VisualVariableRotation","../shaders/VisualVariableSizeMinMaxValue","../shaders/VisualVariableSizeScaleStops","../shaders/VisualVariableSizeStops","../shaders/VisualVariableSizeUnitValue","../shaders/vvUtils"],(function(t,e,i,o,a,l,s,r,n,d,c,p,u,V,y,h,m,b){"use strict";const v=360/254;class _ extends l.FeatureVertexInput{}e.__decorate([o.location(3,a.Vec4)],_.prototype,"color",void 0),e.__decorate([o.location(4,a.Vec2)],_.prototype,"offset",void 0),e.__decorate([o.location(5,a.Vec2)],_.prototype,"textureUV",void 0),e.__decorate([o.location(6,a.Float)],_.prototype,"fontSize",void 0),e.__decorate([o.location(7,a.Float)],_.prototype,"referenceSize",void 0),e.__decorate([o.location(8,a.Float)],_.prototype,"haloFontSize",void 0),e.__decorate([o.location(9,a.Vec4)],_.prototype,"haloColor",void 0),e.__decorate([o.location(10,a.Vec2)],_.prototype,"zoomRange",void 0),e.__decorate([o.location(11,a.Float)],_.prototype,"clipAngle",void 0),e.__decorate([o.location(12,a.Vec4)],_.prototype,"referenceSymbol",void 0);class f extends o.ComputeVertexInput{}e.__decorate([o.location(13,a.Vec2)],f.prototype,"offsetNextVertex1",void 0),e.__decorate([o.location(14,a.Vec2)],f.prototype,"offsetNextVertex2",void 0);class x extends l.FeatureFragmentInput{}class S extends l.AFeatureShader{constructor(){super(...arguments),this.computeAttributes={offset:["offsetNextVertex1","offsetNextVertex2"]},this.isHaloPass=!1,this.isBackgroundPass=!1,this.isLabel=!1}clipLabel(t,e,o){const l=e.multiply(v),s=a.abs(this.view.rotation.subtract(l)),r=a.min(new a.Float(360).subtract(s),s);let n=new a.Float(0);const d=a.floor(this.view.currentZoom.multiply(i.minMaxZoomPrecisionFactor)).divide(i.minMaxZoomPrecisionFactor),c=t.x,p=t.y,u=new a.Float(1).subtract(a.step(c,d)).multiply(2),V=a.step(new a.Float(90),r).multiply(2),y=new a.Float(2).multiply(new a.Float(1).subtract(a.step(d,p)));return n=n.add(o.multiply(u)),n=n.add(o.multiply(V)),n=n.add(y),n}vertex(t,e){const o=d.getBit(t.bitset,s.bitsetTextIsBackground),l=new a.Float(1).subtract(o);let r=t.fontSize,n=r.divide(s.sdfFontSize);const c=this.isHaloPass?t.haloColor:this._getVertexColor(t),p=this.isLabel?c.multiply(this.storage.getAnimationValue(t.id)):c,u=this.view.displayViewScreenMat3.multiply(new a.Vec3(t.pos,1));let V=t.offset,y=new a.Float(1),h=a.Mat3.identity();if(this.isLabel){if(!t.referenceSymbol)throw new Error("InternalError: Optional attribute 'referenceSymbol' expected for labels");const e=t.referenceSymbol,o=e.xy,a=e.z,l=this._unpackDirection(e.w),s=b.getVisualVariableSize(this,t.id,a).divide(2),r=l.multiply(s.add(i.labelPlacementOffsetPadding));V=V.add(o).add(r)}else{y=b.getVisualVariableSize(this,t.id,t.referenceSize).divide(t.referenceSize),r=r.multiply(y),n=n.multiply(y),V=V.multiply(y),h=b.getVisualVariableRotation(this,t.id),V=h.multiply(new a.Vec3(V,0)).xy}const m=d.getBit(t.bitset,s.bitsetTextIsMapAligned),v=this._getViewRotationMatrix(m).multiply(new a.Vec3(V,0));let _=this.isLabel?this.clipLabel(t.zoomRange,t.clipAngle,m):this.clip(t.id,t.zoomRange);_=this.isBackgroundPass?_.add(l.multiply(2)):_.add(o.multiply(2));const f=new a.Vec4(u.xy.add(v.xy),_,1),x=t.textureUV.divide(this.mosaicInfo.size);let S=new a.Float(0);if(this.isHaloPass){S=t.haloFontSize.divide(n).divide(s.maxSdfDistance)}return{glPosition:f,color:p,size:n,textureUV:x,antialiasingWidth:new a.Float(.105*s.sdfFontSize).divide(r).divide(this.view.pixelRatio),haloDistanceOffset:S,...this.maybeRunHittest(t,e,{vvSizeAdjustment:y,vvRotation:h})}}_getViewRotationMatrix(t){const e=this.view.displayViewMat3,i=this.view.displayMat3,o=new a.Float(1).subtract(t);return e.multiply(t).add(i.multiply(o))}fragment(t){const e=new a.Float(2/8),i=new a.Float(1).subtract(e),o=a.texture2D(this.mosaicInfo.texture,t.textureUV).a;let l=i.subtract(t.haloDistanceOffset);this.highlight&&(l=l.divide(2));const s=t.antialiasingWidth,r=a.smoothstep(l.subtract(s),l.add(s),o);return this.getFragmentOutput(t.color.multiply(r),t)}hittest(t,e,{vvSizeAdjustment:i,vvRotation:o}){const l=o.multiply(new a.Vec3(t.offset.multiply(i),0)),s=o.multiply(new a.Vec3(e.offsetNextVertex1.multiply(i),0)),n=o.multiply(new a.Vec3(e.offsetNextVertex2.multiply(i),0)),{viewMat3:d,tileMat3:c}=this.view,p=d.multiply(c).multiply(new a.Vec3(t.pos,1)),u=p.add(c.multiply(l)).xy,V=p.add(c.multiply(s)).xy,y=p.add(c.multiply(n)).xy;return r.distPointTriangle(this.hittestRequest.position,u.xy,V.xy,y.xy)}_unpackDirection(t){const e=new a.Int(t),i=a.bitRShift(e,new a.Int(2)),o=a.bitAnd(e,new a.Int(3));return new a.Vec2(new a.Float(i).subtract(1),new a.Float(o).subtract(1))}_getVertexColor(t){let e=t.color;if(this.visualVariableColor){const i=this.storage.getColorValue(t.id);e=this.visualVariableColor.getColor(i,t.color,new a.Bool(!1))}if(this.visualVariableOpacity){const i=this.storage.getOpacityValue(t.id),o=this.visualVariableOpacity.getOpacity(i);e=e.multiply(o)}return e}}e.__decorate([o.option(c.VisualVariableColor)],S.prototype,"visualVariableColor",void 0),e.__decorate([o.option(p.VisualVariableOpacity)],S.prototype,"visualVariableOpacity",void 0),e.__decorate([o.option(u.VisualVariableRotation)],S.prototype,"visualVariableRotation",void 0),e.__decorate([o.option(V.VisualVariableSizeMinMaxValue)],S.prototype,"visualVariableSizeMinMaxValue",void 0),e.__decorate([o.option(y.VisualVariableSizeScaleStops)],S.prototype,"visualVariableSizeScaleStops",void 0),e.__decorate([o.option(h.VisualVariableSizeStops)],S.prototype,"visualVariableSizeStops",void 0),e.__decorate([o.option(m.VisualVariableSizeUnitValue)],S.prototype,"visualVariableSizeUnitValue",void 0),e.__decorate([o.uniform(n.MosaicInfo)],S.prototype,"mosaicInfo",void 0),e.__decorate([o.define],S.prototype,"isHaloPass",void 0),e.__decorate([o.define],S.prototype,"isBackgroundPass",void 0),e.__decorate([o.define],S.prototype,"isLabel",void 0),e.__decorate([e.__param(0,o.input(_)),e.__param(1,o.input(f))],S.prototype,"vertex",null),e.__decorate([e.__param(0,o.input(x))],S.prototype,"fragment",null),t.TextFragmentInput=x,t.TextShader=S,t.TextVertexInput=_,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
