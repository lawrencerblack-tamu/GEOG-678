/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/arrayUtils","../../../../../core/Logger","../../../../../core/string","./ShaderBuilder2D","./graph/glsl","./graph/GlslGraphWriter","./graph/ShaderGraphContext","./graph/ShaderGraphNode","./typed/TypedShaderProgram"],(function(e,t,r,o,n,s,i,a,p,u,c){"use strict";function d(e){return new e}function y(e,t,r){const o=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:o.slice()}),e.constructor[t].push(r)}function h(e,t){return(r,o)=>{y(r,"locations",{typeCtor:t,propertyKey:o,parameterIndex:null,index:e})}}const l=e=>(t,r)=>{y(t,"builtins",{builtin:e,propertyKey:r})},f=e=>(t,r,o)=>{y(t,"inputs",{inputCtor:e,propertyKey:r,parameterIndex:o})},g=e=>(t,r)=>{y(t,"uniforms",{typeCtor:e,propertyKey:r})},m=e=>(t,r)=>{y(t,"options",{typeCtor:e,propertyKey:r})},_=(e,t)=>{y(e,"defines",{propertyKey:t})};function x(e){return(t,r)=>{y(t,"transformFeedbackBindings",{propertyKey:r,parameterIndex:null,index:e})}}const K=(e,t)=>(r,o)=>{r.constructor.builtins.push({builtin:e,propertyKey:o,typeCtor:t})};class I{}I.builtins=[],t.__decorate([K("gl_VertexID",i.Int)],I.prototype,"glVertexID",void 0);class C{}class b{}b.builtins=[],t.__decorate([K("gl_FragCoord",i.Vec4)],b.prototype,"glFragCoord",void 0),t.__decorate([K("gl_PointCoord",i.Vec2)],b.prototype,"glPointCoord",void 0);class v{}t.__decorate([l("gl_FragColor")],v.prototype,"glFragColor",void 0);class w{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class F{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=r.findLast(this._shaderModuleClass.inputs,(e=>"vertex"===e.propertyKey&&0===e.parameterIndex));if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return r.findLast(this._shaderModuleClass.inputs,(e=>"vertex"===e.propertyKey&&1===e.parameterIndex))}get fragmentInput(){const e=r.findLast(this._shaderModuleClass.inputs,(e=>"fragment"===e.propertyKey));if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,t=new Set;for(const r of this.locations)t.has(r.index)?o.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:e}):(e.set(r.propertyKey,r.index),t.add(r.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map((([e,t])=>`${e}.${t}`)).join("."),r=n.numericHash(t);this._locationInfo={hash:r,locations:e}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,r,o){try{const{vertex:n,fragment:s,uniformBindings:i}=this._generateShaders(e,t,r,o);return new c.TypedShaderProgram(n,s,this.renamedLocationsMap,this.locationInfo,i,this.transformFeedbackBindings)}catch(n){return console.error("Failed to create program",{error:n}),new c.TypedShaderProgram("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find((t=>t.propertyKey===e));if(t)return{type:"option",className:t.typeCtor};const r=this._uniforms.find((t=>t.propertyKey===e));if(!r)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:r.typeCtor}}getShaderKey(e,t,r,o){const n=Object.keys(r).map((e=>`${e}.${r[e]}`)).join("."),s=Object.keys(o).map((e=>`${e}.${o[e]}`)).join("."),i=Object.keys(t).filter((e=>this.optionPropertyKeys.has(e)&&t[e])).join(".");return`${this.constructor.name}.${e.hash}.${n}.${s}.${i}`}_generateShaders(e,t,r,o){const n=[];this._setDefines(r),this._setOptionalUniforms(n,t),this._setRequiredUniforms(n);const s=this._hydrateVertexInput(o),i=this._injectPackPrecisionFactor(s,e),c=this._hydrateComputeInput(),d=c&&this._injectPackPrecisionFactor(c,e),y=this.vertex(i,d),h=this._hydrateFragmentInput(y),l=this.fragment(h),f=new Set;for(const a in l){const e=l[a];u.setReachableUids(f,e)}const g=this._getVertexInputBuiltins(),m=p.ShaderGraphContext.createVertex({...s,...c},y,g,n,this.transformFeedbackBindings,f);(new a.GlslShaderWriter).write(m);const _=this._getFragmentInputBuiltins(l);_.set("glPointCoord","gl_PointCoord");const x=p.ShaderGraphContext.createFragment(h,l,_,n,m,this.transformFeedbackBindings);(new a.GlslShaderWriter).write(x);const K=this._createShaderBuilder(m,x),I=K.generate("vertex",!1),C=K.generate("fragment",!1);return this.logShader&&(console.log(I),console.log(C)),{vertex:I,fragment:C,uniformBindings:n}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const r of this._options){t[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(e,r):this[r.propertyKey]=null}}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const r=new(0,t.typeCtor);for(const o of r._uniforms??[]){const n=d(o.typeCtor),s=`u_${t.propertyKey}_${o.propertyKey}`,i=n.type,a=[t.propertyKey,o.propertyKey].join(".");if("type"in o.typeCtor&&"array"===o.typeCtor.type){const t=n;e.push({shaderModulePath:a,uniformName:s,uniformType:i,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:n})}else e.push({shaderModulePath:a,uniformName:s,uniformType:i,uniformHydrated:n});r[o.propertyKey]=n}return r}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,r=t.locations.reduce(((t,r)=>!1===e[r.propertyKey]?t:{...t,[r.propertyKey]:d(r.typeCtor)}),{});for(const{propertyKey:o,typeCtor:n}of t.builtins){const e=d(n);r[o]=e}return r}_hydrateComputeInput(){if(null==this.computeInput)return null;return this.computeInput.inputCtor.locations.reduce(((e,t)=>({...e,[t.propertyKey]:d(t.typeCtor)})),{})}_injectPackPrecisionFactor(e,t){const r={};for(const o in e){const n=e[o],s=t.attributes.find((e=>e.name===o));if(s?.packPrecisionFactor){if("float"!==n.type&&"vec2"!==n.type&&"vec3"!==n.type&&"vec4"!==n.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${n.type}`);r[o]=n.divide(new i.Float(s.packPrecisionFactor))}else r[o]=n}return r}_hydrateFragmentInput(e){const t={};for(const r in e)t[r]=e[r];for(const{propertyKey:r,typeCtor:o}of b.builtins){const e=d(o);t[r]=e}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:r,propertyKey:o}of e.builtins)t.set(o,r);return t}_getFragmentInputBuiltins(e){const t=e.constructor,r=new Map;for(const o of t.builtins??[])r.set(o.propertyKey,o.builtin);return r}_createShaderBuilder(e,t){const r=new s.ShaderBuilder2D;return this._insertDebugInfo(r),e.insertVertexShader(r),t.insertFragmentShader(r),r}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}}e.ComputeVertexInput=C,e.FragmentInput=b,e.FragmentOutput=v,e.GraphShaderModule=F,e.UniformGroup=w,e.VertexInput=I,e.builtin=l,e.define=_,e.input=f,e.location=h,e.option=m,e.transformFeedback=x,e.uniform=g,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
