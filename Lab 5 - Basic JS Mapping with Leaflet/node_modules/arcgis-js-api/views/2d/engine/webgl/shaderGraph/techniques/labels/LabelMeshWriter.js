/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../../../core/MapUtils","../../../../../../../core/libs/gl-matrix-2/math/mat2d","../../../../../../../core/libs/gl-matrix-2/factories/mat2df32","../../../alignmentUtils","../../../DisplayId","../../../collisions/BoundingBox","../../../collisions/LabelMetric","../../../mesh/templates/segmentUtils","../fill/meshWriterUtils","../text/TextMeshWriter"],(function(e,t,i,s,a,n,o,r,l,h,c){"use strict";const m=1,d=0,u=128,g=t.memoize((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class p extends c.TextMeshWriter{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,i,s){if(this._zoomLevel=s||0,null!=i)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const i=t.readXForDisplay(),s=t.readYForDisplay();return this._writePoint(e,i,s,t)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const i=t.readCentroidForDisplay();if(!i)return;const[s,a]=i.coords;return this._writePoint(e,s,a,t)}case"esriGeometryPolyline":{const i=t.readLegacyGeometryForDisplay();this._writeLines(e,t,i)}}}_writePoint(e,t,i,s){const o=this._getShaping();if(!o)return;let l=this._getPointReferenceBounds();l||(l={offsetX:0,offsetY:0,size:0});const h=o.boundsT,c=a.getXAnchorDirection(this.evaluatedMeshParams.horizontalAlignment),m=a.getYAnchorDirection(this.evaluatedMeshParams.verticalAlignment),d=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0,g=n.getDisplayIdTexel(s.getDisplayId());e.metricStart(new r.LabelMetric(g,t,i,c,m,d,u,l)),e.metricBoxWrite(h),this._writeGlyphs(e,s.getDisplayId(),t,i,o,0,l),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t,i){const{repeatLabel:s,scaleInfo:a}=this.evaluatedMeshParams,n=this.evaluatedMeshParams.repeatLabelDistance||128,o=this._getShaping();if(!o)return;this._current={out:e,id:t.getDisplayId(),shaping:o,zoomRange:h.getMinMaxZoom(a,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0}};const r=l.smoothPaths(i.paths,o.bounds.width),c=this._placeSubdivGlyphs.bind(this),d=(o.bounds.width+n)/(1<<m);for(const h of r)l.pathDivide(h,d,c,!!s)}_placeSubdivGlyphs(e,t,i,s){const{allowOverrun:a,labelPosition:n,repeatLabelDistance:o}=this.evaluatedMeshParams,r=this._current.zoomRange[0],l=g(t),h=this._current.shaping.bounds.width/(1<<m),d=Math.sqrt(o||u)/(1<<m),p=Math.min(i,s-i),x=this._current.shaping.isMultiline?c.maxLabelZoom:Math.log2(p/(d+h/2)),f=0===t?x:Math.min(l,x),_=Math.max(r,this._zoomLevel+m-f),M=this._zoomLevel-_,y=this._current.shaping.bounds.width/2*2**M;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,_):a&&M<0?this._placeStraightAlong(e,r):"parallel"===n?this._placeStraightAlong(e,_):"curved"===n&&this._placeCurved(e,_,y)}_placeStraight(e,t){const{out:i,id:s,shaping:a,referenceBounds:o}=this._current,{x:l,y:h}=e,c=n.getDisplayIdTexel(s),m=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0;i.metricStart(new r.LabelMetric(c,e.x,e.y,0,0,m,d,null)),i.metricBoxWrite(a.boundsT);const u=e.angle*(180/Math.PI)%360,g=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(i,s,l,h,a,0,o,{clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(i,s,l,h,a,0,o,{clipAngle:g,mapAligned:!0,isLineLabel:!0,minZoom:t}),i.metricEnd()}_placeCurved(e,t,i){const{out:s,id:a}=this._current,o=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,c=n.getDisplayIdTexel(a),m=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0;s.metricStart(new r.LabelMetric(c,e.x,e.y,0,0,m,d,null)),this._placeFirst(o,t,1,l),this._placeBack(e,o,t,i,1,l),this._placeForward(e,o,t,i,1,l),this._placeFirst(o,t,0,h),this._placeBack(e,o,t,i,0,h),this._placeForward(e,o,t,i,0,h),s.metricEnd()}_placeStraightAlong(e,t){const{out:a,id:o,shaping:l,zoomRange:h,referenceBounds:m}=this._current,{boxBorderLineColor:d,boxBackgroundColor:u}=this.evaluatedMeshParams,g=e.clone(),p=e.angle*(180/Math.PI)%360,x=(e.angle*(180/Math.PI)+180)%360;if(l.glyphs.length>0&&(d||u)){const n=Math.max(t,h[0],0),r=Math.min(c.maxLabelZoom,h[1]),d=i.fromRotation(s.create(),-e.angle),[u,g]=l.shapeBackground(d),f={minZoom:n,maxZoom:r,clipAngle:p,mapAligned:!0,isLineLabel:!0};a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,o,e.x,e.y,g,m,f),a.recordEnd(),f.clipAngle=x,a.recordStart(this.instanceId,this.attributeLayout,l.glyphs[0].textureBinding),this._writeTextBox(a,o,e.x,e.y,g,m,f),a.recordEnd()}const f=n.getDisplayIdTexel(o),_=this.evaluatedMeshParams.scaleInfo?.maxScale??0,M=this.evaluatedMeshParams.scaleInfo?.minScale??0;a.metricStart(new r.LabelMetric(f,e.x,e.y,0,0,_,M,null)),this._placeFirst(g,t,1,p,!0),this._placeFirst(g,t,0,x,!0),a.metricEnd()}_placeBack(e,t,i,s,a,n){const o=e.clone();let r=e.backwardLength+d;for(;o.prev()&&!(r>=s);)this._placeOnSegment(o,t,r,i,-1,a,n),r+=o.length+d}_placeForward(e,t,i,s,a,n){const o=e.clone();let r=e.remainingLength+d;for(;o.next()&&!(r>=s);)this._placeOnSegment(o,t,r,i,1,a,n),r+=o.length+d}_placeFirst(e,t,i,s,a=!1){const n=e,{out:o,id:r,shaping:l,zoomRange:h,referenceBounds:m}=this._current,u=l.glyphs;for(const g of u){const u=g.x>l.bounds.x?i:1-i,p=u*e.remainingLength+(1-u)*e.backwardLength,x=Math.abs(g.x+g.width/2-l.bounds.x),f=Math.max(0,this._zoomLevel+Math.log2(x/(p+d))),_=Math.max(t,a?0:f);g.maxZoom=Math.min(h[1],c.maxLabelZoom),g.angle=e.angle+(1-i)*Math.PI,g.minZoom=Math.max(h[0],_),this._writeLineGlyph(o,r,n.x,n.y,l.bounds,g,s,m,!0),i&&this._isVisible(g.minZoom,g.maxZoom)&&o.metricBoxWrite(g.bounds)}}_placeOnSegment(e,t,i,s,a,n,r){const{out:l,id:h,shaping:c,referenceBounds:m}=this._current,u=c.glyphs,g=e.dx/e.length,p=e.dy/e.length,x={x:e.x+i*-a*g,y:e.y+i*-a*p};for(const f of u){const u=f.x>c.bounds.x?n:1-n;if(!(u&&1===a||!u&&-1===a))continue;const g=Math.abs(f.x+f.width/2-c.bounds.x),p=Math.max(0,this._zoomLevel+Math.log2(g/i)-.1),_=Math.max(s,this._zoomLevel+Math.log2(g/(i+e.length+d)));if(0!==p&&(f.angle=e.angle+(1-n)*Math.PI,f.minZoom=_,f.maxZoom=p,this._writeLineGlyph(l,h,x.x,x.y,c.bounds,f,r,m,!0),n&&this._isVisible(f.minZoom,f.maxZoom))){const i=f.bounds,s=e.x-t.x,a=e.y-t.y,n=new o(i.center[0]+s,i.center[1]+a,i.width,i.height);l.metricBoxWrite(n)}}}_writeLineGlyph(e,t,i,s,a,n,o,r,l){const c=i+a.x,m=s+a.y,d=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),u=Math.max(a.width,a.height)*d;e.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),e.recordBounds(c,m,u,u);const{texcoords:g,offsets:p}=n,x=this._textMeshTransformProps.fontSize;this._writeQuad(e,t,i,s,{texcoords:g,offsets:p,fontSize:x,color:h.processColorInput(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:r,minZoom:Math.max(this._current.zoomRange[0],n.minZoom),maxZoom:Math.min(this._current.zoomRange[1],n.maxZoom),clipAngle:o,mapAligned:l,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const i=this._zoomLevel;return e<=i&&i<=t}}e.LabelMeshWriter=p,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
