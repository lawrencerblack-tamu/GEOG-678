/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../../../core/arrayUtils","../../../../../../../core/Error","../../../../../../../core/lang","../../../../../../../core/Logger","../../../grouping","./utils","../../../../../layers/features/support/DictionaryValue"],(function(e,r,t,s,a,o,i,n){"use strict";const c=()=>a.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function l(e,r,t=!1){const{defaultValue:s,valueExpressionInfo:a,value:o}=r;if(a){const{expression:o}=a,i=await e.createComputedField({expression:o},t);return i?{...r,computed:i,defaultValue:s}:null}return{...r,computed:new n.DictionaryValue(o),defaultValue:s}}async function p(e,r){const{defaultValue:t,valueExpressionInfo:s}=r,{expression:a}=s,o=await e.createComputedField({expression:a});return o?{...r,computed:o,defaultValue:t}:null}const m=e=>"boolean"!=typeof e&&"number"!=typeof e&&"valueExpressionInfo"in e,f=e=>e.some((e=>{for(const r in e){const t=e[r];if(m(t))return!0}return!1}));class u{static async create(e,t,s){const a={},o=new Map,i=new Map,n=new Map,c=new Map,d=new Map;for(const u in s.params){const h=s.params[u];if(null!=h&&"object"==typeof h)if(Array.isArray(h)){if("object"==typeof h[0])throw new Error(`InternalError: Cannot handle ${u}. Nested array params are not supported`);a[u]=h}else if("valueExpressionInfo"in h){if(h.value){a[u]=h.value;continue}const r=await p(e,h);if(!r){a[u]=h.defaultValue;continue}o.set(u,r),a[u]=null}else switch(h.type){case"cim-effect-infos":if(h.effectInfos.some((e=>e.overrides.length))){i.set(u,{effects:await Promise.all(h.effectInfos.map((async t=>{const s=t.overrides.map((r=>l(e,r)));return{effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(r.isSome)}})))});break}a[u]=h.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-info":h.overrides.length&&n.set(u,{placementInfo:h,compiledOverrides:(await Promise.all(h.overrides.map((r=>l(e,r))))).filter(r.isSome)}),a[u]=h.placement;break;case"text-rasterization-param":{if(h.overrides.length){const t=h.overrides.map((r=>l(e,r,h.useLegacyLabelEvaluationRules)));c.set(u,{compiledOverrides:(await Promise.all(t)).filter(r.isSome),rasterizationParam:h,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:h.resource};a[u]=await t.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(h.overrides.length){const t=h.overrides.map((r=>l(e,r)));c.set(u,{compiledOverrides:(await Promise.all(t)).filter(r.isSome),rasterizationParam:h,objectIdToResourceId:new Map});continue}if("animated"===h.resource.type){c.set(u,{compiledOverrides:[],rasterizationParam:h,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:h.resource};a[u]=await t.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:r}=h;if(f(r)){const t={compiledMarkerInfos:[]};await Promise.all(r.map((async r=>{const s={props:{}};for(const t in r)if(m(r[t])){const a=await p(e,r[t]);s.compiledExpressionMap||(s.compiledExpressionMap=new Map);const o=s.compiledExpressionMap;a&&o.set(t,a)}else s.props[t]=r[t];t.compiledMarkerInfos.push(s)}))),d.set(u,t)}else a[u]={type:"cim-marker-transform-info",infos:r};break}default:a[u]=h}else a[u]=h}return new u(s,a,o,i,n,c,d)}constructor(e,r,t,s,a,o,i){this.inputMeshParams=e,this._resolvedMeshParams=r,this._dynamicProperties=t,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=a,this._dynamicAsyncProperties=o,this._dynamicTransformProperties=i,this.evaluator=e=>e}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,r,a){for(const l of this._dynamicAsyncProperties.values()){const p=s.clone(l.rasterizationParam.resource);"animated"===l.rasterizationParam.resource.type&&l.rasterizationParam.resource.randomizeStartTime&&(p.primitiveName="__RESERVED__PRIMITIVE__NAME__",p.startGroup=o.getStartGroup(r.getObjectId()||0));for(const{primitiveName:e,propertyName:s,computed:o,defaultValue:f,valueExpressionInfo:u}of l.compiledOverrides)try{const t="animated"===l.rasterizationParam.resource.type?p.primitiveName:e;i.applyComputedValue(p,t,s,o,r,a,f)}catch(n){c().errorOnce(new t("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${u?.expression}' (primitive: '${e}', property: '${s}')`,n))}const m=e.enqueueRequest({type:"cim-rasterization-info",resource:p});l.objectIdToResourceId.set(r.getObjectId(),m)}}evaluateMeshParams(e,r,t){for(const[s,a]of this._dynamicProperties.entries())this._resolvedMeshParams[s]=a.computed.readWithDefault(r,t,a.defaultValue);for(const[s,a]of this._dynamicPlacementProperties.entries())for(const{computed:e,defaultValue:o,propertyName:i}of a.compiledOverrides){const n=e.readWithDefault(r,t,o);a.placementInfo.placement[i]=n,this._resolvedMeshParams[s]=a.placementInfo.placement}for(const[s,a]of this._dynamicEffectProperties.entries())for(const e of a.effects){for(const{computed:s,defaultValue:a,propertyName:o}of e.compiledOverrides){const i=s.readWithDefault(r,t,a);e.effect[o]=i}this._resolvedMeshParams[s]=a.effects.map((e=>e.effect))}for(const[s,a]of this._dynamicTransformProperties.entries()){const e={type:"cim-marker-transform-info",infos:[]};for(const s of a.compiledMarkerInfos){const a={...s.props};if(s.compiledExpressionMap)for(const[e,o]of s.compiledExpressionMap){const s=o.computed.readWithDefault(r,t,o.defaultValue);a[e]="number"==typeof s||"boolean"==typeof s?s:o.defaultValue}e.infos.push(a)}this._resolvedMeshParams[s]=e}for(const[s,a]of this._dynamicAsyncProperties.entries()){const t=a.objectIdToResourceId.get(r.getObjectId());if(null==t)continue;const o=e.getResource(t);this._resolvedMeshParams[s]=o}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}e.MeshWriterInputEvaluator=u,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
