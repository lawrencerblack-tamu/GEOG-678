/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","./ShaderGraphNode"],(function(e,t){"use strict";class n{constructor(e,t,n){this.variableName=e,this.variableInputType=t,this.node=n,this.type="shader-input",this.isUsed=!1}clone(){return new n(this.variableName,this.variableInputType,t.cloneShaderNode(this.node))}}class o{constructor(e,t,n){this.outVariableName=e,this.outVariableType=t,this.node=n,this.type="shader-output"}clone(){const e=new o(this.outVariableName,this.outVariableType,t.cloneShaderNode(this.node));return e.variableName=this.variableName,e}}class d{static createVertex(e,t,a,i,r,s){const u=[];for(const o in e){const t=e[o],d=a.get(o);d?u.push(new n(d,"builtin",t)):u.push(new n("a_"+o,"attribute",t))}for(const o of i){const e=o.uniformHydrated;u.push(new n(o.uniformName,"uniform",e))}const p=[];for(const n in t){const e=t[n];"glPosition"===n?p.push(new o("gl_Position","builtin",e)):"glPointSize"===n?p.push(new o("gl_PointSize","builtin",e)):p.push(new o("v_"+n,"varying",e))}return new d(u,p,r,s)}static createFragment(e,t,a,i,r,s){const u=[],p=Array.from(r.rootOutputNodes());for(const o in e){const t=e[o],d=a.get(o);if(d){u.push(new n(d,"builtin",t));continue}const i=p.find((e=>e.node===t));i&&u.push(new n(i.outVariableName,i.outVariableType,t))}for(const o of i){const e=o.uniformHydrated;u.push(new n(o.uniformName,"uniform",e))}const h=[];for(const n in t){const e=t[n],d=a.get(n);if("discard"===n)h.push(new o(null,"discard",e));else{if(!d)throw new Error(`Member ${n} in shader fragment output shoule be tagged as builtin`);h.push(new o(d,"builtin",e))}}return new d(u,h,s)}constructor(e,t,n,o){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const d of e)this._inputShaderTypesByNodeUid.set(d.node.uid,d);this._outputShaderTypes=t,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map((e=>"v_"+e.propertyKey))),this._usedInFragmentShader=o}shouldPruneOutputNode(e){return!!this._usedInFragmentShader&&("builtin"!==e.outVariableType&&(!this._transformFeedbackNames.has(e.outVariableName)&&!this._usedInFragmentShader.has(e.node.uid)))}setEmit(e,t){this._nodeEmitMap.set(e.uid,t)}getEmit(e){return this._nodeEmitMap.get(e.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(e){return this._inputShaderTypesByNodeUid.get(e.uid)}*rootOutputNodes(){for(const e of this._outputShaderTypes)yield e}*nodes(){const e=[];for(const t of this._outputShaderTypes.values())e.push(t.node);for(;e.length;){const t=e.pop();"number"!=typeof t&&"boolean"!=typeof t&&e.push(...t.children.filter(Boolean)),yield t}}*nodesOfTypeOrFunction(){for(const e of this.nodes())"number"!=typeof e&&"boolean"!=typeof e&&(yield e)}createSubgraphContext(){const e=this.clone();return e.body="",e.indent=this.indent+2,e._nodeEmitMap=new Map(this._nodeEmitMap),e}clone(){const e=new d([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return e._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,e.indent=this.indent,e.body=this.body,e.varCount=this.varCount,e._nodeEmitMap=this._nodeEmitMap,e}insertVertexShader(e){e.vertex.code.add(""),this._insertInputs(e,"vertex"),e.vertex.code.add(""),e.vertex.code.add("// OUTPUTS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this.rootOutputNodes()){const n="builtin"===t.outVariableType;this.shouldPruneOutputNode(t)||(n?e.vertex.code.add(`// ${t.outVariableType.padEnd(7)} ${t.node.type.padEnd(9)} ${t.outVariableName};`):e.vertex.code.add(`${t.outVariableType.padEnd(10)} ${t.node.type.padEnd(9)} ${t.outVariableName};`))}e.vertex.code.add(""),e.vertex.code.add("void main() {"),e.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())this.shouldPruneOutputNode(t)||e.vertex.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.vertex.code.add("}")}insertFragmentShader(e){this._insertInputs(e,"fragment"),e.fragment.code.add(""),e.fragment.code.add("void main() {"),e.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())"discard"===t.outVariableType?(e.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),e.fragment.code.add(`  if (${t.variableName}) {`),e.fragment.code.add("    discard;"),e.fragment.code.add("  }"),e.fragment.code.add("  ")):e.fragment.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.fragment.code.add("}")}_insertInputs(e,t){e[t].code.add("// INPUTS: "),e[t].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())n.isUsed&&"builtin"!==n.variableInputType&&("array"===n.node.type?e[t].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`):e[t].code.add(`${n.variableInputType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`))}}e.ShaderGraphContext=d,e.ShaderInput=n,e.ShaderOutput=o,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
