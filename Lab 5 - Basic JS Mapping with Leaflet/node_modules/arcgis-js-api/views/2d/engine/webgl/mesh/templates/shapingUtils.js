/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../../core/libs/gl-matrix-2/math/mat2d","../../../../../../core/libs/gl-matrix-2/factories/mat2df32","../../../../../../core/libs/gl-matrix-2/math/vec2","../../../../../../core/libs/gl-matrix-2/factories/vec2f32","../../alignmentUtils","../../Rect","../../collisions/BoundingBox"],(function(t,s,e,i,o,h,n,a){"use strict";const r=22,f=4,c=r+f,d=r-6,m=3,l=Math.PI/180,g=8,_=1.5;class u{constructor(t,s,i,o){this._rotationT=e.create(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const h=i.rect,n=new Float32Array(8);t*=o,s*=o;const a=i.code?h.width*o:i.metrics.width,r=i.code?h.height*o:i.metrics.height;this.width=a,this.height=r,n[0]=t,n[1]=s,n[2]=t+a,n[3]=s,n[4]=t,n[5]=s+r,n[6]=t+a,n[7]=s+r,this._data=n,this._setTextureCoords(h),this._scale=o,this._mosaic=i,this.x=t,this.y=s,this.maxOffset=Math.max(t+a,s+r)}get mosaic(){return this._mosaic}set angle(t){this._angle=t,s.fromRotation(this._rotationT,-t),this._setOffsets()}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:t,width:i}=this._mosaic.metrics,o=i*this._scale,h=Math.abs(t)*this._scale,n=new Float32Array(8);n[0]=this.x,n[1]=this.y,n[2]=this.x+o,n[3]=this.y,n[4]=this.x,n[5]=this.y+h,n[6]=this.x+o,n[7]=this.y+h;const r=s.multiply(e.create(),this._rotationT,this._transform);e.transformMany(n,n,r);let f=1/0,c=1/0,d=0,m=0;for(let s=0;s<4;s++){const t=n[2*s],e=n[2*s+1];f=Math.min(f,t),c=Math.min(c,e),d=Math.max(d,t),m=Math.max(m,e)}const l=d-f,g=m-c,_=f+l/2,u=c+g/2;this._bounds=new a(_,u,l,g)}return this._bounds}setTransform(t){this._transform=t,this._offsets=null}_setOffsets(){this._offsets||(this._offsets={topLeft:[0,0],topRight:[0,0],bottomLeft:[0,0],bottomRight:[0,0]});const t=s.multiply(e.create(),this._rotationT,this._transform);this._offsets.topLeft[0]=this._data[0],this._offsets.topLeft[1]=this._data[1],this._offsets.topRight[0]=this._data[2],this._offsets.topRight[1]=this._data[3],this._offsets.bottomLeft[0]=this._data[4],this._offsets.bottomLeft[1]=this._data[5],this._offsets.bottomRight[0]=this._data[6],this._offsets.bottomRight[1]=this._data[7],i.transformMat2d(this._offsets.topLeft,this._offsets.topLeft,t),i.transformMat2d(this._offsets.topRight,this._offsets.topRight,t),i.transformMat2d(this._offsets.bottomLeft,this._offsets.bottomLeft,t),i.transformMat2d(this._offsets.bottomRight,this._offsets.bottomRight,t)}_setTextureCoords({x:t,y:s,width:e,height:i}){this._texcoords={topLeft:[t,s],topRight:[t+e,s],bottomLeft:[t,s+i],bottomRight:[t+e,s+i]}}}const x=(t,s)=>({code:0,page:0,sdf:!0,rect:new n(0,0,11,8),textureBinding:s,metrics:{advance:0,height:4,width:t,left:0,top:0}});function p(t,s){return t.forEach((t=>i.transformMat2d(t,t,s))),{topLeft:t[0],topRight:t[1],bottomLeft:t[2],bottomRight:t[3]}}class y{constructor(t,s,e){this._rotation=0,this._decorate(t,s,e),this.glyphs=t,this.bounds=this._createBounds(t),this.isMultiline=s.length>1,this._hasRotation=0!==e.angle,this._transform=this._createGlyphTransform(this.bounds,e),this._borderLineSizePx=e.borderLineSizePx,(e.borderLineSizePx||e.hasBackground)&&([this.bounds,this.textBox]=this.shapeBackground(this._transform));for(const i of t)i.setTransform(this._transform)}setRotation(t){if(0===t&&0===this._rotation)return;this._rotation=t;const i=this._transform,o=s.fromRotation(e.create(),t);s.multiply(i,o,i);for(const s of this.glyphs)s.setTransform(this._transform)}_decorate(t,s,e){if(!e.decoration||"none"===e.decoration||!t.length)return;const i=e.scale,o="underline"===e.decoration?c:d,h=t[0].textureBinding;for(const n of s){const s=n.startX*i,e=n.startY*i,a=(n.width+n.glyphWidthEnd)*i;t.push(new u(s,e+o*i,x(a,h),1))}}shapeBackground(t){const s=this._borderLineSizePx||0,e=(_+s)/2,i=this._borderLineSizePx?e:0,{xmin:o,ymin:h,xmax:n,ymax:r,x:f,y:c,width:d,height:m}=this.bounds,l=[o-g,h-g],u=[n+g,h-g],x=[o-g,r+g],y=[n+g,r+g],b=p([[l[0]-e,l[1]-e],[u[0]+e,u[1]-e],[l[0]+i,l[1]+i],[u[0]-i,u[1]+i]],t),M=p([[x[0]+i,x[1]-i],[y[0]-i,y[1]-i],[x[0]-e,x[1]+e],[y[0]+e,y[1]+e]],t),w=p([[l[0]-e,l[1]-e],[l[0]+i,l[1]+i],[x[0]-e,x[1]+e],[x[0]+i,x[1]-i]],t),L=p([[u[0]-i,u[1]+i],[u[0]+e,u[1]-e],[y[0]-i,y[1]-i],[y[0]+e,y[1]+e]],t),R={main:p([l,u,x,y],t),top:b,bot:M,left:w,right:L};return[new a(f,c,d+2*e,m+2*e),R]}get boundsT(){const t=this.bounds,s=i.set(o.create(),t.x,t.y);if(i.transformMat2d(s,s,this._transform),this._hasRotation){const e=Math.max(t.width,t.height);return new a(s[0],s[1],e,e)}return new a(s[0],s[1],t.width,t.height)}_createBounds(t){let s=1/0,e=1/0,i=0,o=0;for(const a of t)s=Math.min(s,a.xTopLeft),e=Math.min(e,a.yTopLeft),i=Math.max(i,a.xBottomRight),o=Math.max(o,a.yBottomRight);const h=i-s,n=o-e;return new a(s+h/2,e+n/2,h,n)}_createGlyphTransform(t,h){const n=l*h.angle,a=e.create(),r=o.create();return s.translate(a,a,i.set(r,h.xOffset,-h.yOffset)),h.useCIMAngleBehavior?s.rotate(a,a,n):(s.translate(a,a,i.set(r,t.x,t.y)),s.rotate(a,a,n),s.translate(a,a,i.set(r,-t.x,-t.y))),a}}class b{constructor(t,s,e,i,o,h){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(s,e)),this.end=Math.max(0,Math.max(s,e)),this.end<t.length&&(this.glyphWidthEnd=t[this.end].metrics.width),this.width=i,this.yMin=o,this.yMax=h}}const M=t=>10===t,w=t=>32===t;function L(t,s,e){const i=new Array,o=1/e.scale,h=e.maxLineWidth*o,n=s?t.length-1:0,a=s?-1:t.length,r=s?-1:1;let f=n,c=0,d=0,m=f,l=m,g=0,_=1/0,u=0;for(;f!==a;){const{code:s,metrics:e}=t[f],o=Math.abs(e.top);if(M(s)||w(s)||(_=Math.min(_,o),u=Math.max(u,o+e.height)),M(s))f!==n&&(i.push(new b(t,m,f-r,c,_,u)),_=1/0,u=0),c=0,m=f+r,l=f+r,d=0;else if(w(s))l=f+r,d=0,g=e.advance,c+=e.advance;else if(c>h){if(l!==m){const s=l-2*r;c-=g,i.push(new b(t,m,s,c-d,_,u)),_=1/0,u=0,m=l,c=d}else i.push(new b(t,m,f-r,c,_,u)),_=1/0,u=0,m=f,l=f,c=0;c+=e.advance,d+=e.advance}else c+=e.advance,d+=e.advance;f+=r}const x=new b(t,m,f-r,c,_,u);return x.start>=0&&x.end<t.length&&i.push(x),i}function R(t,s){let e=0;for(let h=0;h<t.length;h++){const{width:s}=t[h];e=Math.max(s,e)}const i="underline"===s.decoration?f:0,o=t[0].yMin;return{x:0,y:o,height:t[t.length-1].yMax+s.lineHeight*(t.length-1)+i-o,width:e}}function B(t,s){const e=s.scale,i=new Array,{glyphs:o,isRightToLeft:n}=t,a=L(o,n,s),f=R(a,s),c=h.getXAnchorDirection(s.horizontalAlignment),d=h.getYAnchorDirection(s.verticalAlignment),l=d===h.VAlign.Baseline?1:0,g=l?0:d-1,_=(1-l)*-f.y+g*(f.height/2)+(l?1:0)*-r;for(let h=0;h<a.length;h++){const{start:t,end:n,width:r}=a[h];let f=-1*(c+1)*(r/2)-m;const d=h*s.lineHeight+_-m;a[h].startX=f,a[h].startY=d;for(let s=t;s<=n;s++){const t=o[s];if(M(t.code))continue;const h=new u(f+t.metrics.left,d-t.metrics.top,t,e);f+=t.metrics.advance,i.push(h)}}return new y(i,a,s)}t.ShapedGlyph=u,t.ShapingInfo=y,t.shapeGlyphs=B,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
