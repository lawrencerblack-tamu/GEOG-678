/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../tiling/TileInfoView","../../../tiling/TileKey","../../../tiling/TileQueue","../../../tiling/TileStrategy","../definitions","./MeshData","../../../layers/features/support/tileUtils"],(function(e,t,s,i,r,n,h,o){"use strict";const a=1,c=2,l=4,u=8,f=16,d=32,_=64,m=128;function g(e){switch(e){case a:case u:case d:return-1;case c:case _:return 0;case l:case f:case m:return 1}}function y(e){switch(e){case a:case c:case l:return-1;case u:case f:return 0;case d:case _:case m:return 1}}const p=a|u|d,v=l|f|m,S=a|c|l,b=d|_|m;class E{constructor(e,t,s,i=0){this.tileKey=e,this._bufferingEnabled=t,this._sizeHint=i,this._meshes={self:new h.MeshData(this.id,this._sizeHint),neighbors:new Array},this._currentRecordOverlaps=0,this._currentEntityOverlaps=0,this._copyBufferedDataIntoSelf=s&&this._bufferingEnabled&&0===e.level}get id(){return this.tileKey.id}vertexCount(){return this._meshes.self.vertexCount()}indexCount(){return this._meshes.self.indexCount()}indexEnsureSize(e){this._meshes.self.indexEnsureSize(e)}entityStart(e,t=e){this._currentEntityOverlaps=0,this._meshes.self.entityStart(e,t)}entityRecordCount(){return this._meshes.self.entityRecordCount()}entityEnd(){if(this._meshes.self.entityEnd(),this._bufferingEnabled){if(this._copyBufferedDataIntoSelf)return;for(let e=0;e<8;e++){const t=1<<e;!!(this._currentEntityOverlaps&t)&&this._meshes.neighbors[e].entityEnd()}}}recordStart(e,t,s){this._currentRecordOverlaps=0,this._meshes.self.recordStart(e,t,s)}recordEnd(e=0){const t=this._meshes.self.recordEnd(this._currentRecordOverlaps);return t&&0!==this._currentRecordOverlaps?(this._copyIntoNeighbors(),this._currentEntityOverlaps|=this._currentRecordOverlaps,!0):t}recordBounds(e,t,s,i){this._bufferingEnabled&&this._addOverlap(e,t,s,i)}recordCount(){return this._meshes.self.recordCount()}metricStart(e){this._meshes.self.metricStart(e)}metricBoxWrite(e){this._meshes.self.metricBoxWrite(e)}metricEnd(){this._meshes.self.metricEnd()}vertexWrite(e){this._meshes.self.vertexWrite(e)}vertexWriteF32(e){this._meshes.self.vertexWriteF32(e)}vertexWriteRegion(e){this._meshes.self.vertexWriteRegion(e)}indexWrite(e){this._meshes.self.indexWrite(e)}serialize(e){const t={message:[],transferList:[]},i=this._meshes.self.serialize();return t.message.push({tileId:this.tileKey.id,...i.message}),t.transferList.push(...i.transferList),this._meshes.neighbors.forEach(((i,r)=>{const n=i.serialize(),h=1<<r,a=g(h),c=y(h),l=o.getPow2NeighborKey(new s(this.tileKey),a,c,e);t.message.push({tileId:l.id,...n.message}),t.transferList.push(...n.transferList)})),t}_addOverlap(e,t,s,i){const r=Math.min(n.tileSize/2,s),h=Math.min(n.tileSize/2,i),o=255^((e<0+r?v:e>=n.tileSize-r?p:v|p)|(t<0+h?b:t>=n.tileSize-h?S:b|S));this._currentRecordOverlaps|=o}_copyIntoNeighbors(){for(let e=0;e<8;e++){const t=1<<e;if(!!(this._currentRecordOverlaps&t)){if(this._copyBufferedDataIntoSelf){const e=-g(t)*n.tileSize,s=-y(t)*n.tileSize;this._meshes.self.copyLast(e,s);continue}if(!this._meshes.neighbors[e]){const s=Math.floor(this._sizeHint/16);this._meshes.neighbors[e]=new h.MeshData(t,s)}const s=this._meshes.neighbors[e],i=-g(t)*n.tileSize,r=-y(t)*n.tileSize;s.copyLastFrom(this._meshes.self,i,r)}}}}e.MultiTileMeshData=E,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
