/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/maybe","../number","./Buffer","../shaderGraph/techniques/mesh/dataViewUtils","../shaderGraph/techniques/mesh/utils","../../../../webgl/enums","../../../../webgl/VertexArrayObject"],(function(e,t,r,i,s,o,f,n){"use strict";const u=0,a=1,h=1e3;class c{constructor(e){this._bufferPool=e,this._computeLayouts=new Map,this._vaos=new Map,this._invalidated=!1}destroy(){for(const[e,t]of this._vaos)t?.disposeVAOOnly();this._indexBuffer=t.destroyMaybe(this._indexBuffer),this._vertexBuffer=t.destroyMaybe(this._vertexBuffer)}_getVertexAttributeLayout(e){if(!e)return null;const t=[];for(const r of e.attributes)t.push({name:r.name,type:r.type,count:r.count,divisor:0,normalized:r.normalized??!1,offset:r.offset,stride:e.stride});return{geometry:t}}getLayout(e){if(!this._layout)return null;const{locationInfo:t,useComputeBuffer:r,computeAttributeMap:i}=e,s=this._layout.attributes.filter((e=>t.locations.has(e.name)));if(!r)return{attributes:s,hash:this._layout.hash,stride:this._layout.stride};const f=Object.values(i).flat().join("-");if(this._computeLayouts.has(f))return this._computeLayouts.get(f);const n=this._layout.stride;for(const{name:o,count:a,type:h,normalized:c,offset:d,packPrecisionFactor:l}of this._layout.attributes){const e=i[o];null!=e&&2===e.length&&(s.push({name:e[0],count:a,type:h,normalized:c,offset:d+n,packPrecisionFactor:l}),s.push({name:e[1],count:a,type:h,normalized:c,offset:d+2*n,packPrecisionFactor:l}))}const u={attributes:s,stride:n,hash:o.vertexLayoutHash(s)};return this._computeLayouts.set(f,u),u}getDrawArgs(e,t,r,i){return i?{primitive:f.PrimitiveType.POINTS,count:t/3,offset:r/3}:{primitive:e,count:t,offset:r}}getDebugVertexInfo(e){if(!this._vertexBuffer)return null;const t=this.getLayout(e);if(null==t)return null;const r=t.stride,i=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize),o=new DataView(i.slice().buffer);let f=i.byteLength/r;e.useComputeBuffer&&(f=this._indexBuffer.fillPointer/3);const n=this._indexBuffer.getView(0,this._indexBuffer.byteSize);let u=0;const a=[];for(let h=0;h<f;h++){if(e.useComputeBuffer){u=n[3*h]*r}const i={};for(const e of t.attributes){let t=`${e.offset} ${e.name}`,r=s.unpackDataView(o,e,u);if(e.packPrecisionFactor)if(t+=` (precision: ${e.packPrecisionFactor})`,"number"==typeof r)r/=e.packPrecisionFactor;else for(let i=0;i<r.length;i++)r[i]/=e.packPrecisionFactor;i[t]=r}u+=r,a.push(i)}return{vertices:a,layout:t}}_ensure(e,t,r){if(this._vertexBuffer&&this._indexBuffer){if(this._layout?.hash!==e.hash)throw new Error("InternalError: Expected vertex layouts to match");this._indexBuffer.ensure(Math.max(t,1e3)),this._vertexBuffer.ensure(Math.max(r,1e3))}else{const s=e.stride/Uint32Array.BYTES_PER_ELEMENT;if(this._layout=e,this._position=e.attributes.find((e=>"pos"===e.name||"position"===e.name)),!this._position)throw new Error("InternalError: Unable to find position attribute");this._indexBuffer=new i.MappedBuffer("index",Math.max(t,h),1,this._bufferPool),this._vertexBuffer=new i.MappedBuffer("vertex",Math.max(r,h),s,this._bufferPool)}}append(e){const t=e.layout.stride,r=e.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,i=e.vertices.byteLength/t;this._ensure(e.layout,r,i);const{vertices:s,indices:o}=e,f=this._vertexBuffer.insert(s,0,s.byteLength/t,0);return{vertexFrom:f,indexFrom:this._indexBuffer.insert(o,0,o.byteLength/4,f)}}copyRecordFrom(e,t,i,s){const{indexStart:o,indexCount:f,vertexStart:n,vertexCount:u}=t;this._ensure(e._layout,f,u);const a=e._position,h=i*(a.packPrecisionFactor??1),c=s*(a.packPrecisionFactor??1),d=a.offset,l=r.i1616to32(h,c),_=this._vertexBuffer.copyFrom(e._vertexBuffer,n,u,l,d),x=this._indexBuffer.copyFrom(e._indexBuffer,o,f,_-n,0),p=t.clone();return p.vertexStart=_,p.indexStart=x,p.overlaps=0,p}remove(e,t,r,i){this._indexBuffer.free(e,t),this._vertexBuffer.free(r,i)}upload(){this._invalidated=!0}getVAO(e,t,r){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;const i=r?.useComputeBuffer?a:u;let s=this._vaos.get(i);if(this._invalidated||r?.useComputeBuffer){(this._vertexBuffer.invalidated||this._indexBuffer.invalidated||r?.useComputeBuffer&&this._indexBuffer.invalidatedComputeBuffer)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),s?.disposeVAOOnly(),s=null),this._vertexBuffer.upload(),this._indexBuffer.upload();const o=this._indexBuffer.getGPUBuffer(e,1===i),f=this._vertexBuffer.getGPUBuffer(e);s||(s=new n.VertexArrayObject(e,t.locations,this._getVertexAttributeLayout(this.getLayout(r)),{geometry:f},o),this._vaos.set(i,s)),this._invalidated=!1}return s}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(e){this._vertexBuffer&&this._vertexBuffer.reshuffle(e.vertex.count,e.vertex.operations),this._indexBuffer&&this._indexBuffer.reshuffle(e.index.count,e.index.operations)}}e.MappedMesh=c,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
