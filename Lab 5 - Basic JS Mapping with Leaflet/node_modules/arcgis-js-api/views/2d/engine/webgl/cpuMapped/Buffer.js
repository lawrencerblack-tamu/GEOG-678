/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/has","../../../../../core/maybe","../PooledUint32Array","./FreeList","../../../../webgl/BufferObject","../../../../webgl/enums"],(function(t,i,e,r,s,n,h){"use strict";const a=1.25,d=32767,u=d<<16|d;class o{constructor(t,i,e,s){this._pool=s;const n=r.PooledUint32Array.create(i*e*Uint32Array.BYTES_PER_ELEMENT,this._pool);this.size=i,this.strideInt=e,this.bufferType=t,this.dirty={start:1/0,end:0},this.memoryStats={bytesUsed:0,bytesReserved:i*e*Uint32Array.BYTES_PER_ELEMENT},this._gpu=null,this._cpu=n,this.clear()}get elementSize(){return this._cpu.length/this.strideInt}get intSize(){return this.fillPointer*this.strideInt}get byteSize(){return this.intSize*Uint32Array.BYTES_PER_ELEMENT}get invalidated(){return this.bufferSize>0&&!this._gpu}get invalidatedComputeBuffer(){return this.bufferSize>0&&!this._gpuComputeTriangles}invalidate(){this._invalidateTriangleBuffer(),this._gpu?.dispose(),this._gpu=null}_invalidateTriangleBuffer(){this._gpuComputeTriangles?.dispose(),this._gpuComputeTriangles=null}destroy(){this._gpu?.dispose(),this._gpuComputeTriangles?.dispose(),this._cpu?.destroy()}clear(){this.dirty.start=1/0,this.dirty.end=0,this.freeList=new s.FreeList({start:0,end:this._cpu.length/this.strideInt}),this.fillPointer=0}ensure(t){if(this.maxAvailableSpace()>=t)return;if(t*this.strideInt>this._cpu.length-this.fillPointer){this.invalidate();const i=this._cpu.length/this.strideInt,e=Math.round((i+t)*a),r=e*this.strideInt;this._cpu.expand(r*Uint32Array.BYTES_PER_ELEMENT),this.freeList.free(i,e-i),this.memoryStats.bytesReserved+=(e-i)*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}}set(t,i){this._cpu.array[t]!==i&&(this._cpu.array[t]=i,this.dirty.start=Math.min(t,this.dirty.start),this.dirty.end=Math.max(t+1,this.dirty.end))}getGPUBuffer(t,i=!1){if(!this.bufferSize)return null;if(i){if("index"!==this.bufferType)throw new Error("Tired to get triangle buffer, but target is not an index buffer");return null==this._gpuComputeTriangles&&(this._gpuComputeTriangles=this._createComputeBuffer(t)),this._gpuComputeTriangles}return null==this._gpu&&(this._gpu=this._createBuffer(t)),this._gpu}getView(t,i){return this._cpu.getUint32View(t,i/Uint32Array.BYTES_PER_ELEMENT)}get bufferSize(){return this._cpu.length/this.strideInt}maxAvailableSpace(){return this.freeList.maxAvailableSpace()}insert(t,i,r,s){const n=r*this.strideInt;if(!n)return 0;const h=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,a=new Uint32Array(t,h,n),d=this.freeList.firstFit(r);e.assertIsSome(d,"First fit region must be defined");const u=d*this.strideInt,o=n;if(this._cpu.array.set(a,u),0!==s)for(let e=0;e<a.length;e++)this._cpu.array[e+u]+=s;return this.dirty.start=Math.min(this.dirty.start,u),this.dirty.end=Math.max(this.dirty.end,u+o),this.fillPointer=Math.max(this.fillPointer,u+o),this.memoryStats.bytesUsed+=r*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d}copyFrom(t,i,r,s,n){const h=r*this.strideInt;if(!h)return 0;const a=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,d=t._cpu.getUint32View(a,h),u=this.freeList.firstFit(r);e.assertIsSome(u,"First fit region must be defined");const o=u*this.strideInt,f=h;if(this._cpu.array.set(d,o),0!==s)for(let e=0;e<h;e++)this._cpu.array[o+e*this.strideInt+n]+=s;return this.dirty.start=Math.min(this.dirty.start,o),this.dirty.end=Math.max(this.dirty.end,o+f),this.fillPointer=Math.max(this.fillPointer,o+f),this.memoryStats.bytesUsed+=r*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,u}free(t,i,e){const r=t*this.strideInt,s=(t+i)*this.strideInt;if(!0===e)for(let n=t;n!==t+i;n++)this._cpu.array[n*this.strideInt]=u;this.dirty.start=Math.min(this.dirty.start,r),this.dirty.end=Math.max(this.dirty.end,s),this.freeList.free(t,i),this.memoryStats.bytesUsed-=i*this.strideInt*Uint32Array.BYTES_PER_ELEMENT}upload(){if(this.dirty.end){if(this._invalidateTriangleBuffer(),null==this._gpu)return this.dirty.start=1/0,void(this.dirty.end=0);this._gpu.setSubData(this._cpu.array,this.dirty.start,this.dirty.start,this.dirty.end),this.dirty.start=1/0,this.dirty.end=0}}reshuffle(t,i){if(0===i.length)return;const e=this.byteSize,s=t*this.strideInt*Uint32Array.BYTES_PER_ELEMENT,n=e>s,h=this._cpu,a=r.PooledUint32Array.create(s,this._pool);n||a.array.set(this._cpu.getUint32View(0,this.intSize));for(const r of i)if(n||r.srcFrom!==r.dstFrom||0!==r.mutate){this.dirty.start=Math.min(this.dirty.start,r.dstFrom*this.strideInt),this.dirty.end=Math.max(this.dirty.end,(r.dstFrom+r.count)*this.strideInt);for(let t=0;t<r.count;t++){const i=(r.dstFrom+t)*this.strideInt,e=(r.srcFrom+t)*this.strideInt;for(let t=0;t<this.strideInt;t++)a.array[i+t]=h.array[e+t]+r.mutate}}this._cpu.destroy(),this._cpu=a,n&&this.invalidate(),this.freeList.clear(),this.memoryStats.bytesUsed=this.memoryStats.bytesReserved=s}_createBuffer(t){const i=h.Usage.DYNAMIC_DRAW;return"index"===this.bufferType?n.BufferObject.createIndex(t,i,this._cpu.array):n.BufferObject.createVertex(t,i,this._cpu.array)}_createComputeBuffer(t){const i=h.Usage.DYNAMIC_DRAW,e=new Uint32Array(this.fillPointer/3);for(let r=0;r<this.fillPointer;r+=3)e[r/3]=this._cpu.array[r];return n.BufferObject.createIndex(t,i,e)}}t.MappedBuffer=o,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
