/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../../core/screenUtils","../../../../core/libs/gl-matrix-2/math/mat3","../../../../core/libs/gl-matrix-2/factories/mat3f32","../../../../core/libs/gl-matrix-2/factories/vec2f32","../../../../core/libs/gl-matrix-2/factories/vec3f32","../../../../geometry/support/normalizeUtils","../../../../geometry/support/spatialReferenceUtils","../../viewpointUtils","../brushes","./enums","./WGLContainer"],(function(e,t,s,r,a,i,o,n,l,c,d){"use strict";class h extends d{constructor(){super(...arguments),this._localOrigin=e.createScreenPoint(0,0),this._viewStateId=-1,this._dvsMat3=s.create()}get dvsMat3(){return this._dvsMat3}beforeRender(e){this._updateMatrices(e),this._updateOverlays(e,this.children);for(const t of this.children)t.beforeRender(e)}prepareRenderPasses(e){const t=e.registerRenderPass({name:"overlay",brushes:[l.brushes.overlay],target:()=>this.children,drawPhase:c.WGLDrawPhase.MAP});return[...super.prepareRenderPasses(e),t]}_updateMatrices(e){const{state:s}=e,{id:o,size:n,pixelRatio:l,resolution:c,rotation:d,viewpoint:h,displayMat3:p}=s;if(this._viewStateId===o)return;const u=Math.PI/180*d,f=l*n[0],m=l*n[1],{x:M,y:g}=h.targetGeometry,v=i.normalizeMapX(M,s.spatialReference);this._localOrigin.x=v,this._localOrigin.y=g;const w=c*f,y=c*m,_=t.identity(this._dvsMat3);t.multiply(_,_,p),t.translate(_,_,r.fromValues(f/2,m/2)),t.scale(_,_,a.fromValues(f/w,-m/y,1)),t.rotate(_,_,-u),this._viewStateId=o}_updateOverlays(e,t){const{state:s}=e,{rotation:r,spatialReference:a,worldScreenWidth:i,size:l,viewpoint:c}=s,d=this._localOrigin;let h=0;const p=o.getInfo(a);if(p&&a.isWrappable){const e=l[0],o=l[1],u=180/Math.PI*r,f=Math.abs(Math.cos(u)),m=Math.abs(Math.sin(u)),M=Math.round(e*f+o*m),[g,v]=p.valid,w=n.getWorldWidth(a),{x:y,y:_}=c.targetGeometry,b=[y,_],x=[0,0];s.toScreen(x,b);const P=[0,0];let R;R=M>i?.5*i:.5*M;const I=Math.floor((y+.5*w)/w),O=g+I*w,S=v+I*w,W=[x[0]+R,0];s.toMap(P,W),P[0]>S&&(h=w),W[0]=x[0]-R,s.toMap(P,W),P[0]<O&&(h=-w);for(const s of t){const e=s.elementView.bounds;if(null==e)continue;const[t,,r]=e;t<g&&r>g?s.updateDrawCoords(d,w):r>v&&t<v?s.updateDrawCoords(d,-w):s.updateDrawCoords(d,h)}}else for(const o of t)o.updateDrawCoords(d,h)}}return h}));
