/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../../../core/libs/gl-matrix-2/factories/vec4f32","../DefaultVertexAttributeLayouts","../FeatureTile","./WGLBrush","../shaders/BackgroundPrograms","../shaders/TileInfoPrograms","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/ProgramTemplate","../../../../webgl/Texture","../../../../webgl/TextureDescriptor","../../../../webgl/VertexArrayObject"],(function(e,t,r,i,o,s,n,a,l,c,u,f){"use strict";const d=512,g=512,h=16,m=8,_=(g-2*m)/5;class x extends i{constructor(){super(...arguments),this._color=e.fromValues(1,0,0,1)}dispose(){this._outlineProgram?.dispose(),this._outlineProgram=null,this._tileInfoProgram?.dispose(),this._tileInfoProgram=null,this._outlineVertexArrayObject?.dispose(),this._outlineVertexArrayObject=null,this._tileInfoVertexArrayObject?.dispose(),this._tileInfoVertexArrayObject=null,this._ctx=null}prepareState({context:e}){e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(a.BlendFactor.ONE,a.BlendFactor.ONE_MINUS_SRC_ALPHA,a.BlendFactor.ONE,a.BlendFactor.ONE_MINUS_SRC_ALPHA),e.setColorMask(!0,!0,!0,!0),e.setStencilWriteMask(0),e.setStencilTestEnabled(!1)}draw(e,t){const{context:i,requestRender:o,allowDelayedRender:s}=e;if(!t.isReady&&t instanceof r.FeatureTile&&t.hasData)return;if(this._loadWGLResources(i),s&&null!=o&&(!this._outlineProgram.compiled||!this._tileInfoProgram.compiled))return void o();i.bindVAO(this._outlineVertexArrayObject),i.useProgram(this._outlineProgram),this._outlineProgram.setUniformMatrix3fv("u_dvsMat3",t.transforms.displayViewScreenMat3),this._outlineProgram.setUniform2f("u_coord_range",t.rangeX,t.rangeY),this._outlineProgram.setUniform1f("u_depth",0),this._outlineProgram.setUniform4fv("u_color",this._color),i.drawArrays(a.PrimitiveType.LINE_STRIP,0,4);const n=this._getTexture(i,t);n?(i.bindVAO(this._tileInfoVertexArrayObject),i.useProgram(this._tileInfoProgram),i.bindTexture(n,0),this._tileInfoProgram.setUniformMatrix3fv("u_dvsMat3",t.transforms.displayViewScreenMat3),this._tileInfoProgram.setUniform1f("u_depth",0),this._tileInfoProgram.setUniform2f("u_coord_ratio",t.rangeX/t.width,t.rangeY/t.height),this._tileInfoProgram.setUniform2f("u_delta",0,0),this._tileInfoProgram.setUniform2f("u_dimensions",n.descriptor.width,n.descriptor.height),i.drawArrays(a.PrimitiveType.TRIANGLE_STRIP,0,4),i.bindVAO()):i.bindVAO()}_loadWGLResources(e){if(this._outlineProgram&&this._tileInfoProgram)return;const r=l.createProgram(e,o.background),i=l.createProgram(e,s.tileInfo),c=new Int8Array([0,0,1,0,1,1,0,1]),u=n.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,c),d=new f.VertexArrayObject(e,o.background.attributes,t.Pos2b,{geometry:u}),g=new Int8Array([0,0,1,0,0,1,1,1]),h=n.BufferObject.createVertex(e,a.Usage.STATIC_DRAW,g),m=new f.VertexArrayObject(e,s.tileInfo.attributes,t.Pos2b,{geometry:h});this._outlineProgram=r,this._tileInfoProgram=i,this._outlineVertexArrayObject=d,this._tileInfoVertexArrayObject=m}_getTexture(e,t){if(!this._ctx){const e=document.createElement("canvas");e.width=d,e.height=g,this._ctx=e.getContext("2d")}if(!t.tileDebugInfoTexture){const r=new u.TextureDescriptor;r.wrapMode=a.TextureWrapMode.CLAMP_TO_EDGE,r.samplingMode=a.TextureSamplingMode.LINEAR,r.isImmutable=!0,r.width=d,r.height=g,t.tileDebugInfoTexture=new c.Texture(e,r)}const r=this._ctx;r.clearRect(0,0,r.canvas.width,r.canvas.height),r.textAlign="left",r.textBaseline="top",r.font=h-2+"px sans-serif",r.lineWidth=2,r.fillStyle="white",r.strokeStyle="black";const{debugSlot:i}=t;let o=m+_*i;const s=`${i}) ${t.key.id} (${t.constructor.name})`;r.strokeText(s,m,o),r.fillText(s,m,o),o+=h;const{debugInfo:n}=t;if(n){const{length:e,minOrderedLength:t,minUnorderedLength:i,triangleCount:s}=n.display;if(e>0){const t=`Length: ${e}`;r.strokeText(t,m,o),r.fillText(t,m,o),o+=h}if(t){const e=`Min ordered length: ${t}`;r.strokeText(e,m,o),r.fillText(e,m,o),o+=h}if(i){const e=`Min unordered length: ${i}`;r.strokeText(e,m,o),r.fillText(e,m,o),o+=h}if(s>0){s>1e5&&(r.fillStyle="red",r.strokeStyle="white");const e=`Triangle count: ${s}`;r.strokeText(e,m,o),r.fillText(e,m,o),o+=h}const{bytesUsed:a,bytesReserved:l}=n.memory;if(r.fillStyle="white",r.strokeStyle="black",a>0||l>0){const e=`Memory usage: ${a} of ${l} bytes`;r.strokeText(e,m,o),r.fillText(e,m,o),o+=h}}return t.tileDebugInfoTexture.setData(r.canvas),t.tileDebugInfoTexture}}return x}));
