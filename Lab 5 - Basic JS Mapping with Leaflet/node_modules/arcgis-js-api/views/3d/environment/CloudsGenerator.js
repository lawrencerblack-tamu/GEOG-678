/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/tslib.es6","../../../core/Accessor","../../../core/mathUtils","../../../core/maybe","../../../core/reactiveUtils","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../core/libs/gl-matrix-2/math/mat3","../../../core/libs/gl-matrix-2/math/mat4","../../../core/libs/gl-matrix-2/factories/mat4f64","../../../core/libs/gl-matrix-2/math/vec2","../../../core/libs/gl-matrix-2/factories/vec2f64","../../../core/libs/gl-matrix-2/factories/vec3f32","../../../geometry/ellipsoidUtils","../../../chunks/Clouds.glsl","./CloudsData","./CloudsParameters","./CloudsPresets","./CloudsTechnique","./CloudsTechniqueConfiguration","./NoiseTextureAtlas","../webgl-engine/lib/BindParameters","../webgl-engine/lib/glUtil3D","../../support/Scheduler","../../support/Yield","../../webgl/enums","../../webgl/FramebufferObject","../../webgl/TextureDescriptor"],(function(e,t,s,r,i,a,o,n,h,l,u,d,c,p,_,m,f,g,y,C,T,x,w,P,b,v,S,M,I,R,G,q){"use strict";e.CloudsGenerator=class extends s{constructor(e){super(e),this._techniques=new Array,this._techniqueConfiguration=new P.CloudsTechniqueConfiguration,this._bindParameters=new v.BindParameters(null,null),this._passParameters=new y.CloudsPassParameters,this._weatherTile=m.create(),this._weatherTileCount=128,this._faceIndex=0,this._tileIndex=0,this.coverage=r.lerp(x.cloudPresets.default.coverage[0],x.cloudPresets.default.coverage[1],.5),this.density=r.lerp(x.cloudPresets.default.density[0],x.cloudPresets.default.density[1],.5),this.absorption=r.lerp(x.cloudPresets.default.absorption[0],x.cloudPresets.default.absorption[1],.5),this.cloudSize=r.lerp(x.cloudPresets.default.cloudSize[0],x.cloudPresets.default.cloudSize[1],.5),this.detailSize=r.lerp(x.cloudPresets.default.detailSize[0],x.cloudPresets.default.detailSize[1],.5),this.smoothness=r.lerp(x.cloudPresets.default.smoothness[0],x.cloudPresets.default.smoothness[1],.5),this.cloudHeight=r.lerp(x.cloudPresets.default.cloudHeight[0],x.cloudPresets.default.cloudHeight[1],.5),this.raymarchingSteps=x.cloudPresets.default.raymarchingSteps,this._viewMatrix=p.create(),this._dirty=!1,this.running=!1,this._vao=S.createQuadVAO(e.context.renderContext.rctx)}_getTechnique(e){const t=1-this.context.renderContext.bindParameters.cloudsFade.readChannels,s=t===C.CloudsTextureChannels.RG?2*e:2*e+1,r=this._techniques[s];return r||(this._techniqueConfiguration.writeTextureChannels=t,this._techniqueConfiguration.steps=e,this._techniques[s]=new w.CloudsTechnique({rctx:this.context.renderContext.rctx,viewingMode:this.view.state.viewingMode},this._techniqueConfiguration),this._techniques[s])}updateWeatherTile(){const e=this.view.camera.position.latitude,t=this.view.camera.position.longitude;if(null==e||null==t)return;_.set(this._weatherTile,(e+90)/180,(t+180)/360);const s=Math.floor(this._weatherTileCount*Math.abs(2*this._weatherTile[0]-1));this._weatherTile[0]=Math.floor(2*this._weatherTileCount*this._weatherTile[0]),this._weatherTile[1]=Math.floor(4*(this._weatherTileCount-s)*this._weatherTile[1]);let r=0,i=0;if(null!=this.view.environment&&"virtual"!==this.view.environment.lighting.type&&null!=this.view.environment.lighting.date){const e=new Date(this.view.environment.lighting.date);e.setUTCHours(this.view.environment.lighting.date.getUTCHours()+(this.view.environment.lighting.displayUTCOffset??0)),r=31*e.getUTCMonth()+e.getUTCDate(),i=e.getUTCFullYear()}this._weatherTile[0]=(this._weatherTile[0]+r)%(2*this._weatherTileCount),this._weatherTile[1]=(this._weatherTile[1]+i%100)%(4*this._weatherTileCount),_.equals(this._passParameters.weatherTile,this._weatherTile)||this.setDirty()}initialize(){const e=g.getReferenceEllipsoid(this.view.spatialReference);this._passParameters.cloudRadius=.5*e.radius,this.setDirty(),this.updateWeatherTile(),this.addHandles([this.view.resourceController.scheduler.registerTask(M.TaskPriority.CLOUDS_GENERATOR,this),a.watch((()=>[this.coverage,this.density,this.absorption,this.cloudSize,this.detailSize,this.smoothness,this.cloudHeight,this.raymarchingSteps]),(()=>this.setDirty()),a.initial)])}destroy(){this._techniques.forEach((e=>i.releaseMaybe(e))),this._frameBufferCube=i.disposeMaybe(this._frameBufferCube),this._techniques.length=0,this._vao.dispose(),this._passParameters.noiseTexture=i.destroyMaybe(this._passParameters.noiseTexture)}get _tilesPerFace(){switch(this._techniqueConfiguration.steps){case P.RayMarchingSteps.SIXTEEN:return 1;case P.RayMarchingSteps.HUNDRED:return 4;case P.RayMarchingSteps.COUNT:case P.RayMarchingSteps.TWOHUNDRED:return 8}}get usedMemory(){return(this._frameBufferCube?.usedMemory??0)+(this._passParameters.noiseTexture?.textureAtlas?.usedMemory??0)}_ensureNoiseTexture(){if(null!=this._passParameters.noiseTexture)this._passParameters.noiseTexture.updateWeatherMap(this._passParameters.weatherTile);else{const e=this.context;this._passParameters.noiseTexture=new b.NoiseTextureAtlas({context:e}),this._passParameters.noiseTexture.updateWeatherMap(this._passParameters.weatherTile)}return null!=this._passParameters.noiseTexture.textureAtlas}_ensureFrameBufferCube(e){if(null==this._frameBufferCube){const t=new q.TextureDescriptor(e);t.target=R.TextureType.TEXTURE_CUBE_MAP,t.wrapMode=R.TextureWrapMode.CLAMP_TO_EDGE,this._frameBufferCube=new G.FramebufferObject(this.context.renderContext.rctx,t)}return this._frameBufferCube}get cubeMap(){return this._frameBufferCube}destroyFrameBufferCube(){this._frameBufferCube=i.disposeMaybe(this._frameBufferCube)}applyPreset(e,t){const s=e.median,i=e=>{const i=r.lerp(e[0],e[1],s);return t<.5?r.lerp(e[0],i,2*t):r.lerp(i,e[1],2*(t-.5))};this.coverage=i(e.coverage),this.density=i(e.density),this.absorption=i(e.absorption),this.cloudSize=i(e.cloudSize),this.detailSize=i(e.detailSize),this.smoothness=i(e.smoothness),this.cloudHeight=i(e.cloudHeight),this.raymarchingSteps=e.raymarchingSteps}setDirty(){this._dirty=this.running=!0}runTask(e){0===this._faceIndex&&0===this._tileIndex&&(this._passParameters.raymarchingSteps=this.raymarchingSteps,this.updateWeatherTile(),_.copy(this._passParameters.weatherTile,this._weatherTile));const t=this._getTechnique(this._passParameters.raymarchingSteps);if(!t.compiled)return I.Yield;if(this.context.renderContext.bindParameters.cloudsFade.fadeMode===T.FadeMode.CROSS_FADE||!this._ensureNoiseTexture())return I.Yield;0===this._faceIndex&&0===this._tileIndex&&(this.context.renderContext.bindParameters.cloudsFade.renderingStage=C.CloudsRenderingStages.RENDERING,this._passParameters.absorption=this.absorption,this._passParameters.density=this.density,this._passParameters.cloudSize=this.cloudSize,this._passParameters.detailSize=this.detailSize,this._passParameters.smoothness=this.smoothness,this._passParameters.cloudHeight=this.cloudHeight,this._passParameters.coverage=this.coverage,this._dirty=!1);const s=z[this._faceIndex],r=E[this._faceIndex];c.targetTo(this._viewMatrix,D,s,r),d.fromMat4(this._passParameters.viewMatrix,this._viewMatrix);const i=this.context.renderContext.rctx,a=i.bindTechnique(t,this._bindParameters,this._passParameters);i.bindVAO(this._vao),a.assertCompatibleVertexAttributeLocations(this._vao);const o=i.getViewport(),n=t.configuration.cubeMapSize,h=n/this._tilesPerFace,l=this._tileIndex*h;i.setViewport(0,l,n,h);const u=this._ensureFrameBufferCube(n);i.bindFramebuffer(u);const p=R.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X+this._faceIndex;return u.setColorTextureTarget(p),i.gl.drawArrays(i.gl.TRIANGLE_STRIP,0,4),i.gl.flush(),i.setViewport(o.x,o.y,o.width,o.height),this.requestRender(),++this._tileIndex,4===this._faceIndex&&this._tileIndex===this._tilesPerFace?(this.running=this._dirty,this._faceIndex=0,this._tileIndex=0,this.running||(this.context.renderContext.bindParameters.cloudsFade.renderingStage=C.CloudsRenderingStages.FADING)):this._tileIndex===this._tilesPerFace&&(++this._faceIndex,this._tileIndex=0),e.madeProgress(),I.Yield}},t.__decorate([o.property({constructOnly:!0})],e.CloudsGenerator.prototype,"context",void 0),t.__decorate([o.property({constructOnly:!0})],e.CloudsGenerator.prototype,"view",void 0),t.__decorate([o.property({constructOnly:!0})],e.CloudsGenerator.prototype,"requestRender",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"coverage",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"density",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"absorption",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"cloudSize",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"detailSize",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"smoothness",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"cloudHeight",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"raymarchingSteps",void 0),t.__decorate([o.property()],e.CloudsGenerator.prototype,"running",void 0),e.CloudsGenerator=t.__decorate([u.subclass("esri.views.3d.environment.CloudsGenerator")],e.CloudsGenerator);const z=[f.fromValues(1,0,0),f.fromValues(-1,0,0),f.fromValues(0,1,0),f.fromValues(0,-1,0),f.fromValues(0,0,1)],E=[f.fromValues(0,1,0),f.fromValues(0,1,0),f.fromValues(0,0,-1),f.fromValues(0,0,1),f.fromValues(0,1,0)],D=f.zeros();Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
