/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/mathUtils","../../../../../core/screenUtils","../../../../../core/Logger","../../../../../core/has","../../../../../core/RandomLCG","../../../../../core/Error","../../../../../core/accessorSupport/decorators/subclass","../../../../../core/libs/gl-matrix-2/math/vec2","../../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../../chunks/vec32","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../geometry/ellipsoidUtils","../../../../../geometry/support/axisAngle","../../../../../chunks/sphere","../../../camera/constraintUtils","../../../camera/constraintUtils/ConstraintOptions","../../../camera/constraintUtils/ConstraintTypes","../../../camera/constraintUtils/InteractionType","../../../camera/constraintUtils/surfaceCollision","../InteractiveController","../../utils/navigationUtils","../../../support/geometryUtils/ray"],(function(t,e,i,r,s,a,n,o,c,h,l,m,p,_,d,u,C,P,y,g,v,R,k,f){"use strict";t.ZoomController=class extends R.InteractiveController{constructor(){super(...arguments),this._pickPoint=p.create(),this._tmpP0=l.create(),this._panAxisAngle=d.create(),this._tmpRayDir=p.create(),this._tmpRayDirPick=p.create(),this._targetOnSphere=p.create(),this._navMode=k.NavigationMode.Horizontal,this._tmpRay={origin:p.create(),direction:p.create()},this.dragBeginPoint=r.createScreenPointArray(),this._normalizedAnchorPoint=l.create(),this._constraintOptions=new P.ConstraintOptions(y.ConstraintTypes.ALL_EXCEPT_COLLISION,g.InteractionType.ZOOM,0,this.startCamera),this._sphere=u.create(),this._hasPickPoint=!1}get _intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;h.copy(this.dragBeginPoint,t),k.normalizeCoordinate(this.startCamera,t,this._normalizedAnchorPoint);const e=_.getReferenceEllipsoid(this.view.spatialReference),r=k.pickPointAndInitSphere(this._intersectionHelper,this.startCamera,t,e,k.SpherePickPointFallback.Ellipsoid,0===this.view.map.ground.opacity?k.contentIntersectorOptions:{});if(this._navMode=k.decideNavigationMode(this.startCamera,t,e),this._navMode===k.NavigationMode.Horizontal)this._hasPickPoint=!!r.scenePickPoint,this._pickPoint=r.scenePickPoint??this._pickPoint,this._sphere=r.sphere;else{let e;f.fromScreenAtEye(this.startCamera,t,this._tmpRay),m.normalize(this._tmpRay.direction,this._tmpRay.direction),null!=r.scenePickPoint&&(m.subtract(this._tmpRayDirPick,this.startCamera.eye,r.scenePickPoint),e=m.length(this._tmpRayDirPick));const s=Math.abs(this.view.camera.position.z);this.view.renderCoordsHelper.worldUpAtPosition(this.startCamera.eye,M);let a=i.clamp(Math.min(k.pivotDistanceModifier,1/Math.abs(m.dot(M,this._tmpRay.direction)))*s,k.distanceClampValues[0],k.distanceClampValues[1]);const n=this.view._stage.renderView.getMinimalDepthForArea(null,t[0],t[1],this.view.state.camera,k.screenPixelArea);a=null!=n?n:a,a=null!=e?Math.min(a,e):a,this._hasPickPoint=!0,m.scale(this._tmpRay.direction,this._tmpRay.direction,a),m.add(this._pickPoint,this._tmpRay.origin,this._tmpRay.direction)}}update(t){if(this.active){if(this.currentCamera.eye=this.startCamera.eye,this.currentCamera.center=this.startCamera.center,this.currentCamera.up=this.startCamera.up,this._navMode===k.NavigationMode.Horizontal){m.subtract(this._tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const e=m.length(this._tmpRayDir);k.normalizeCoordinate(this.currentCamera,t,this._tmpP0);const i=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let r=e*2**i;const s=this.view.state.constraints.minimumPoiDistance;if(i<0&&r<s&&(r=s),Math.abs(e-r)<1e-6)return;if(this._hasPickPoint&&r<e){const t=1-(1-r/e)*(1-this._sphere[3]/m.length(this.currentCamera.center));this.currentCamera.center=m.scale(A,this.currentCamera.center,t)}m.scale(this._tmpRayDir,this._tmpRayDir,-r/e),this.currentCamera.eye=m.add(A,this.currentCamera.center,this._tmpRayDir),this._constraintOptions.interactionFactor=C.pixelDistanceToInteractionFactor(h.distance(this.dragBeginPoint,t)),C.applyAll(this.view,this.currentCamera,this._constraintOptions),this._hasPickPoint&&(k.sphereOrPlanePointFromScreenPoint(this._sphere,this.currentCamera,this.dragBeginPoint,this._targetOnSphere),d.fromPoints(this._pickPoint,this._targetOnSphere,this._panAxisAngle),k.applyRotation(this.currentCamera,u.getCenter(this._sphere),this._panAxisAngle))}else{const e=m.length(this._tmpRay.direction);k.normalizeCoordinate(this.currentCamera,t,this._tmpP0);const i=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let r=e*2**i;const s=this.view.state.constraints.minimumPoiDistance;if(i<0&&r<s&&(r=s),Math.abs(e-r)<1e-6)return;m.scale(this._tmpRayDir,this._tmpRay.direction,1-r/e),this.currentCamera.eye=m.add(A,this.currentCamera.eye,this._tmpRayDir),this.currentCamera.center=m.add(A,this.currentCamera.center,this._tmpRayDir)}v.applySurfaceCollisionConstraint(this.view,this.currentCamera),this.commitCamera()}}end(){this.active&&this.finishController()}},t.ZoomController=e.__decorate([c.subclass("esri.views.3d.state.controllers.global.ZoomController")],t.ZoomController);const A=p.create(),M=p.create();Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
