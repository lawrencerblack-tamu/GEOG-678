/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/mathUtils","../../../../../core/screenUtils","../../../../../core/Logger","../../../../../core/has","../../../../../core/RandomLCG","../../../../../core/Error","../../../../../core/accessorSupport/decorators/subclass","../../../../../core/libs/gl-matrix-2/math/vec2","../../../../../chunks/vec32","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../geometry/support/axisAngle","../../../../../geometry/support/plane","../../../camera/constraintUtils","../../../camera/constraintUtils/ConstraintOptions","../../../camera/constraintUtils/ConstraintTypes","../../../camera/constraintUtils/InteractionType","../../../input/util","../../../layers/VoxelWasm","../InteractiveController","../momentum/PanPlanarMomentumController","../momentum/RotationMomentumController","../momentum/ZoomPlanarMomentumController","../../utils/navigationUtils","../../../webgl-engine/lib/Camera","../../../../navigation/PanPlanarMomentumEstimator","../../../../navigation/RotationMomentumEstimator","../../../../navigation/ZoomMomentumEstimator"],(function(t,e,i,n,a,o,r,s,m,l,c,h,p,u,_,d,g,C,M,P,v,b,y,w,E,S,V,z,f){"use strict";const A=h.fromValues(0,0,1),O={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI};t.PinchAndPanController=class extends v.InteractiveController{constructor(){super(...arguments),this._rotationValueSmooth=new M.ExponentialFalloff(.05),this._scalingValueSmooth=new M.ExponentialFalloff(.05),this._planeHorizontal=u.create(),this._planeVertical=u.create(),this._rotationMomentumEstimator=new z.RotationMomentumEstimator,this._panMomentumEstimator=new V.PanPlanarMomentumEstimator(300,12,.9),this._zoomMomentumEstimator=new f.ZoomMomentumEstimator,this._beginRadius=0,this._beginCenter=h.create(),this._beginAngle=0,this._tmpPoints=[],this._panMode=E.NavigationMode.Horizontal,this._beginCenterScreen=n.createScreenPointArray(),this._tmpCentroid3d=h.create(),this._tmpCentroid2d=n.createScreenPointArray(),this._tmp2d=n.createScreenPointArray(),this._pointerCount=0,this._beginCamera=new S.Camera,this._constraintOptions=new d.ConstraintOptions(g.ConstraintTypes.ALL,C.InteractionType.NONE,0,this._beginCamera)}begin(t){if(!this.active)return;const e=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=e,this._rotationMomentumEstimator.enabled=e,this._panMomentumEstimator.enabled=e,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),n.screenPointObjectToArray(t.center,this._beginCenterScreen),u.fromNormalAndOffset(A,0,this._planeHorizontal);const a=h.create(),o=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,a,0===this.view.map.ground.opacity?E.contentIntersectorOptions:{}),r=h.create();c.negate(r,this.startCamera.viewForward);const s=h.create();c.copy(s,A);const m=c.dot(r,s),l=m<0,p=i.asinClamped(l?-m:m);this._panMode=p>=O.ANGLE_THRESHOLD?E.NavigationMode.Horizontal:E.NavigationMode.Vertical;const _=Math.min(E.panDistanceModifier,1/Math.abs(c.dot(s,this.startCamera.viewForward)))*Math.max(Math.abs(this.view.camera.position.z),E.minHeightLimit);u.setOffsetFromPoint(this._planeHorizontal,this._planeHorizontal,a),this.startCamera.aboveGround||u.negate(this._planeHorizontal,this._planeHorizontal);const d=h.create(),g=h.create(),C=h.create();c.subtract(d,a,this.currentCamera.eye);const M=c.length(d);if(c.normalize(d,d),this._panMode===E.NavigationMode.Vertical){c.scale(s,s,m),c.subtract(u.getNormal(this._planeVertical),r,s),c.normalize(u.getNormal(this._planeVertical),u.getNormal(this._planeVertical)),u.setOffsetFromPoint(this._planeVertical,this._planeVertical,a);const e=this.view._stage.renderView.getMinimalDepthForArea(P.getVoxelWasm(this.view),this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,E.screenPixelArea);let i=null!=e?e:_;i=o?Math.min(i,M):i,c.copy(C,c.add(g,this.currentCamera.eye,c.scale(g,d,i))),this._planeVertical[3]=-c.dot(u.getNormal(this._planeVertical),C),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),E.centroid(this._tmpPoints,this._beginCenter)}else{const e=o?M:_;c.copy(C,c.add(g,this.currentCamera.eye,c.scale(g,d,e))),this._planeHorizontal[3]=-c.dot(u.getNormal(this._planeHorizontal),C),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),E.centroid(this._tmpPoints,this._beginCenter)}this._beginCamera.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const e=t.pointers.size>1,i=this._panMode===E.NavigationMode.Horizontal?this._planeHorizontal:this._planeVertical,a=this._beginCenter;if(e){const e=this._beginRadius/t.radius,i=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=i,this._scalingValueSmooth.update(e),E.applyZoomToPoint(this.currentCamera,a,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=C.InteractionType.ZOOM,this._constraintOptions.interactionFactor=_.pixelDistanceToInteractionFactor(Math.abs(t.radius-this._beginRadius)),_.applyAll(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,i,this.currentCamera,this._tmpPoints),E.centroid(this._tmpPoints,this._tmpCentroid3d),n.screenPointObjectToArray(t.center,this._tmpCentroid2d),E.applyPanPlanar(this.currentCamera,a,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=C.InteractionType.PAN,this._constraintOptions.interactionFactor=_.pixelDistanceToInteractionFactor(l.distance(this._beginCenterScreen,this._tmpCentroid2d)),_.applyAll(this.view,this.currentCamera,this._constraintOptions),e){const e=a,i=this._rotationValueSmooth.value,n=i+E.normalizeRotationDelta(t.angle-i),o=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=o,this._rotationValueSmooth.update(n);const r=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(r,.001*t.timestamp);const s=u.getNormal(this._planeHorizontal);E.applyRotation(this.currentCamera,e,p.wrapAxisAngle(s,r)),this._constraintOptions.interactionType=C.InteractionType.TUMBLE,this._constraintOptions.interactionFactor=_.pixelDistanceToInteractionFactor(Math.abs(t.radius*r)),_.applyAll(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const e=this._zoomMomentumEstimator.evaluateMomentum();if(e)return new w.ZoomPlanarMomentumController({view:this.view,momentum:e,zoomCenter:this._beginCenter});const i=this._rotationMomentumEstimator.evaluateMomentum();if(i)return new y.RotationMomentumController({view:this.view,momentum:i,center:this._beginCenter,axis:u.getNormal(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new b.PanPlanarMomentumController({view:this.view,momentum:n}):null}_computePlanePoints(t,e,i,n){n.length=t.size;const a=this._tmp2d;let o=0;return t.forEach((t=>{a[0]=t.x,a[1]=t.y,void 0===n[o]&&(n[o]=h.create()),E.intersectPlaneFromScreenPointAtEye(e,i,a,n[o]),o+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}},t.PinchAndPanController=e.__decorate([m.subclass("esri.views.3d.state.controllers.local.PinchAndPanController")],t.PinchAndPanController),Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
