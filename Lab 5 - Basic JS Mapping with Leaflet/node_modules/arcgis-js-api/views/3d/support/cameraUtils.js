/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../Camera","../../../core/Cyclical","../../../core/Logger","../../../core/mathUtils","../../../core/promiseUtils","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/ellipsoidUtils","../../../geometry/Point","../../../geometry/projection","../../../geometry/SpatialReference","../../../geometry/projection/projectPointToVector","../../../geometry/projection/projectVectorToPoint","../../../geometry/projection/projectVectorToVector","../../ViewingMode","../camera/intersectionUtils","../../../chunks/cameraUtilsPlanar","../../../chunks/cameraUtilsSpherical","./earthUtils","./ElevationProvider","../../support/spatialReferenceSupport"],(function(e,t,n,r,o,i,a,c,l,s,u,f,d,p,m,g,h,y,w,v,T,R){"use strict";const S=()=>r.getLogger("esri.views.3d.support.cameraUtils"),M=39.37,x=96,A=1,C=8,b=5,P=1,V=c.create(),j={heading:0,tilt:0},z=c.create(),D=new n.Cyclical(-20037508.342788905,20037508.342788905),O=new n.Cyclical(-180,180);var U;function I(e){return e.spatialReference??f.WGS84}function E(e){return"global"===e.viewingMode?w.cameraUtilsSpherical:y.cameraUtilsPlanar}function H(e,t,n,r,o){return E(e).headingTiltToDirectionUp(t,n,r,o)}function G(e,t){if(null==t)return null;const n=e.renderSpatialReference,r=E(e).headingTiltToDirectionUp,i=c.create();if(!d.projectPointToVector(t.position,i,n))return null;const l=r(i,t.heading,t.tilt);a.scale(l.direction,l.direction,e.state.camera.distance),a.add(l.direction,l.direction,i);const s=h.cameraOnContentAlongViewDirection(e,i,l.direction,l.up);return s.fov=o.deg2rad(t.fov),s.row=t.layout.row,s.rows=t.layout.rows,s.column=t.layout.column,s.columns=t.layout.columns,s}e.OrientationMode=void 0,(U=e.OrientationMode||(e.OrientationMode={}))[U.LOCKED=0]="LOCKED",U[U.ADJUST=1]="ADJUST";const L=c.create();function q(e,n,r){const i=e.renderSpatialReference,a=K(e,n.eye,n.viewForward,n.up,j);let c=I(e);return m.projectVectorToVector(n.eye,i,L,c)||(c=f.WGS84,m.projectVectorToVector(n.eye,i,L,c)),null==r?r=new t(new s(L,c),a.heading,a.tilt,o.rad2deg(n.fov)):(r.position.x=L[0],r.position.y=L[1],r.position.z=L[2],r.position.spatialReference=c,r.heading=a.heading,r.tilt=a.tilt,r.fov=o.rad2deg(n.fov)),r.layout.row=n.row,r.layout.rows=n.rows,r.layout.column=n.column,r.layout.columns=n.columns,r}function F(e,t,n){const r=e.state.camera,i=r.width/2/r.pixelRatio;e.renderCoordsHelper.viewingMode===g.ViewingMode.Global&&null!=n&&(t*=Math.cos(o.deg2rad(n))),t/=e.renderCoordsHelper.unitInMeters;return i/(x*M/t)/Math.tan(r.fovX/2)}function k(e,t,n){const r=e.state.camera,i=t*Math.tan(r.fovX/2),a=r.width/2/r.pixelRatio;let c=x*M/(a/i);return e.renderCoordsHelper.viewingMode===g.ViewingMode.Global&&null!=n&&(c/=Math.cos(o.deg2rad(n))),c*e.renderCoordsHelper.unitInMeters}async function J(e,t,n,r,o,i){return X(e,t,F(e,n,t.latitude),r,o,i)}function W(e,t,n,r,o,i){return ye(e,Q(e,r.heading,r.tilt,t,n,o),r.fov,i)}async function X(e,t,n,r,o,a){const c=await $(e,r.heading,r.tilt,t,n,o,a);return i.throwIfAborted(a),we(e,c,r.fov,a)}function K(e,t,n,r,o){return E(e).directionToHeadingTilt(t,n,r,o)}function Z(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,z,e.spatialReference)&&e.elevationProvider&&(T.getElevationAtPoint(e.elevationProvider,z)??0)>z[2]-P)}async function Y(e,t,n){if(Z(e,t))return!0;const{elevationProvider:r,spatialReference:o,renderCoordsHelper:a}=e;if(null==r||!a.fromRenderCoords(t,z,o))return!1;const[c,l,s]=z,u=await r.queryElevation(c,l,s,o,"ground",n)??0;return i.throwIfAborted(n),u>s-P}async function N(e,t,n){const r=c.create();if(null==t)return a.copy(r,e.state.camera.center);if(t instanceof s){const{renderSpatialReference:o,basemapTerrain:a,elevationProvider:c}=e,l=t.spatialReference;if(await d.projectPointToVectorAsync(t,r,o,0,{signal:n}),i.throwIfAborted(n),null==t.z&&null!=a&&null!=c){const o=await c.queryElevation(t.x,t.y,t.z??0,l,"ground",n);i.throwIfAborted(n),null!=o&&e.renderCoordsHelper.setAltitude(r,o)}return r}return a.copy(r,t)}function B(e,t){const n=c.create();if(null==t)return a.copy(n,e.state.camera.center);if(t instanceof s){if(!d.projectPointToVector(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:o}=e;if(null==t.z&&null!=r&&null!=o){const r=T.getElevationAtPoint(o,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return a.copy(n,t)}function Q(e,t,n,r,o,i){return _(e,t,n,r instanceof s?r:null,B(e,r),o,i)}async function $(e,t,n,r,o,a,c){const l=r instanceof s?r:null,u=await N(e,r,c);return i.throwIfAborted(c),ee(e,t,n,l,u,o,a,c)}function _(e,t,n,r,o,i,a){if(null==o)return null;if(!r&&(r=new s({spatialReference:I(e)}),!p.projectVectorToPoint(o,e.renderSpatialReference,r)))return null;const c=te(e,t,n,o,i,a);if(ne(e,n,a)&&Z(e,c.eye)){const{tilt:a,mode:c}=re(e,n,o,i);return _(e,t,a,r,o,i,c)}return oe(c,o)}async function ee(e,t,n,r,o,a,c,l){r||(r=new s({spatialReference:I(e)}),await p.projectVectorToPointAsync(o,e.renderSpatialReference,r,{signal:l})||(r=null)),i.throwIfAborted(l);const u=te(e,t,n,o,a,c);if(ne(e,n,c)&&await Y(e,u.eye,l)){i.throwIfAborted(l);const{tilt:c,mode:s}=re(e,n,o,a);return ee(e,t,c,r,o,a,s,l)}return oe(u,o)}function te(e,t,n,r,o,i){const a=fe(e,t,n,r,o=Math.max(o,e.state.constraints.minimumPoiDistance),i);return(0,E(e).eyeForCenterWithHeadingTilt)(r,o,a.heading,a.tilt)}function ne(t,n,r){const o=t.map.ground.navigationConstraint;return r===e.OrientationMode.ADJUST&&"global"===t.viewingMode&&n>0&&(null==o||"stay-above"===o.type)}function re(t,n,r,o){const i=ge(t,r,o,me(t,o,n,r));return{tilt:i,mode:n-i<1?e.OrientationMode.LOCKED:e.OrientationMode.ADJUST}}function oe(e,t){return{...e,center:c.clone(t)}}function ie(e,t){const{state:n,spatialReference:r}=e,o=t.spatialReference;return n.isGlobal&&R.isSpatialReferenceSupported(o,g.ViewingMode.Global)||n.isLocal&&r.equals(o)}function ae(e,t){let n,r,o;if(e.state.isGlobal){const e=new s(t.xmin,t.ymin,t.spatialReference),i=new s(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?O:D;n=new s({x:a.center(e.x,i.x),y:(i.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=l.getReferenceEllipsoid(t.spatialReference),u=v.getGreatCircleSpanAt(n,e,i);r=u.lon,o=u.lat,a.diff(e.x,i.x)>a.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),o=Math.min(o,c.halfCircumference)}else{const i=e.renderSpatialReference??t.spatialReference;i.equals(t.spatialReference)||(t=u.project(t,i)),r=t.xmax-t.xmin,o=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new s({x:t.xmin+.5*r,y:t.ymin+.5*o,z:a,spatialReference:i})}const i=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,c=1/Math.tan(a.fovX/2),f=1/Math.tan(a.fovY/2),d=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*o*f,.5*i*d)/A}}async function ce(e,t,n,r,o,a){const c=ie(e,t)?t:await u.projectWithZConversion(t,e.spatialReference,{signal:a});i.throwIfAborted(a);const{center:l,distance:s}=ae(e,c),f=await $(e,n,r,l,s,o,a);return i.throwIfAborted(a),we(e,f,e.camera.fov,a)}function le(e,t,n,r,o,i){let a;try{a=ie(e,t)?t:u.project(t,e.spatialReference)}catch(f){return null}const{center:c,distance:l}=ae(e,a),s=Q(e,n,r,c,l,o);return null==s?null:ye(e,s,e.camera.fov,i)}function se(e,t,n){const r=e.renderSpatialReference,o=new s({spatialReference:I(e)});if(!p.projectVectorToPoint(n,r,o))return null;const i=Math.tan(t.fovX/2),c=Math.tan(t.fovY/2),l=a.dist(t.eye,n),u=2*l*i*A,f=2*l*c*A;return"global"===e.viewingMode?w.toExtent(e,o,u,f):y.toExtent(e,o,u,f)}function ue(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>C)return!0;const o=e.renderSpatialReference,i=I(e),a=new s({spatialReference:i});if(!p.projectVectorToPoint(t,o,a))return!1;const c=new s({spatialReference:i});if(!p.projectVectorToPoint(e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,o,c))return!1;const l=Math.tan(.5*e.state.camera.fov)*r;return c.distance(a)/l>b}function fe(t,n,r,o,i,a){let c=0;return a===e.OrientationMode.ADJUST&&ue(t,o,i)?(n=0,c=pe(t,i,r,o)):c=he(t,o,i,r),c=t.state.constraints.clampTilt(i,c),{heading:n,tilt:r=ge(t,o,i,c)}}const de=.7;function pe(e,t,n,r){const o=he(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const a=i.min*(1-de)+i.max*de;return Math.min(o,a)}function me(e,t,n,r){let o=he(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);return o=Math.min(o,.5*Math.PI),i.min*(1-de)+o*de}function ge(e,t,n,r){return E(e).lookAtTiltToEyeTilt(r,t,n)}function he(e,t,n,r){return E(e).eyeTiltToLookAtTilt(r,t,n)}function ye(e,n,r,o){if(null==n)return null;const i=e.renderSpatialReference,a=new s({spatialReference:I(e)});return p.projectVectorToPoint(n.eye,i,a)?(o??=new t,o.position=a,o.heading=n.heading,o.tilt=n.tilt,o.fov=r,o):null}async function we(e,n,r,o){const a=e.renderSpatialReference,c=new s({spatialReference:I(e)});return await p.projectVectorToPointAsync(n.eye,a,c,{signal:o}),i.throwIfAborted(o),new t(c,n.heading,n.tilt,r)}function ve(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);S().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Te(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);S().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function Re(e,t){return m.projectVectorToVector(t.center,e.renderSpatialReference,V,f.WGS84),k(e,t.distance,V[1])}e.computeScale=Re,e.directionToHeadingTilt=K,e.distanceToScale=k,e.externalToInternal=G,e.fromCenterDistanceAsync=X,e.fromCenterDistanceSync=W,e.fromCenterScale=J,e.fromExtentAsync=ce,e.fromExtentSync=le,e.getObserverForPointAtDistanceAsync=$,e.getObserverForPointAtDistanceSync=Q,e.getViewSR=I,e.headingTiltToDirectionUp=H,e.internalToExternal=q,e.scaleToDistance=F,e.scaleToZoom=ve,e.toExtent=se,e.zoomToScale=Te,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
