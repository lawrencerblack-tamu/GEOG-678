/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../Camera","../../../geometry","../../../Graphic","../../../Viewpoint","../../../core/asyncUtils","../../../core/has","../../../core/Cyclical","../../../core/Error","../../../core/promiseUtils","../../../core/libs/gl-matrix-2/math/mat3","../../../core/libs/gl-matrix-2/factories/mat3f64","../../../core/libs/gl-matrix-2/factories/mat4f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/projection","../../../geometry/projection/computeTranslationToOriginAndRotation","../../../geometry/projection/projectPointToVector","../../../geometry/projection/projectVectorToPoint","../../../geometry/projection/projectVectorToVector","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/frustum","../../../geometry/support/scaleUtils","../camera/intersectionUtils","./cameraUtils","./ElevationProvider","../../../geometry/Point","../../../geometry/Extent","../../../geometry/SpatialReference","../../../geometry/Geometry","../../../geometry/Multipoint"],(function(e,t,n,a,o,r,i,c,l,s,u,m,f,g,p,y,d,h,w,x,v,T,b,R,S,A,j,z,C,M,G,O){"use strict";const V=.66;function P(e){return 360-c.cyclicalDegrees.normalize(e)}function E(e){return c.cyclicalDegrees.normalize(360-e)}function Z(e,t,n){const a=t.camera;if(null!=a)return B(a,A.getViewSR(e));const{targetGeometry:o}=t;if(null==o)return null;const{camera:r,mode:i}=F(e,t.rotation,n);if("point"===o.type)return U(e,t,o,r,i);const c=o.extent;return null==c?null:A.fromExtentSync(e,c,r.heading,r.tilt,i)}async function D(e,t,n,a){const o=t.camera;if(null!=o)return W(o,A.getViewSR(e),a);const{targetGeometry:r}=t;if(null==r)throw new Error("Viewpoint has no targetGeometry!");const{camera:i,mode:c}=F(e,t.rotation,n);if("point"===r.type)return I(e,t,r,i,c,a);const l=r.extent;if(null==l)throw new Error("Target geometry has no extent!");return A.fromExtentAsync(e,l,i.heading,i.tilt,c,a)}function B(e,t){const n=e.position;let a;try{a=y.tryProjectWithZConversion(n,t)}catch(r){return null}if(!a)return null;const o=e.clone();return o.position=a.clone(),o}async function W(e,t,n){const a=e.position,o=await y.projectWithZConversion(a,t,{signal:n});s.throwIfAborted(n);const r=e.clone();return r.position=o.clone(),r}function F(e,t,n){const a=A.internalToExternal(e,e.state.camera);let o=A.OrientationMode.ADJUST;return null!=t&&(a.heading=P(t),o=A.OrientationMode.LOCKED),null!=n&&(a.tilt=n),{camera:a,mode:o}}function U(e,t,n,a,o){const r=e.spatialReference;let i;try{i=y.tryProjectWithZConversion(n.clone(),r)}catch(l){return null}if(!i)return null;const c=null!=t.scale?A.scaleToDistance(e,t.scale,i.latitude):e.state.camera.distance;return A.fromCenterDistanceSync(e,i,c,a,o)}async function I(e,t,n,a,o,r){const i=e.spatialReference,c=await y.projectWithZConversion(n.clone(),i,{signal:r});s.throwIfAborted(r);const l=null!=t.scale?A.scaleToDistance(e,t.scale,c.latitude):e.state.camera.distance;return A.fromCenterDistanceAsync(e,c,l,a,o,r)}function k(e,t,n=null){return null==n&&(n=new o),H(e,null,t.clone(),n)}async function J(e,n,a){const r=ie(e,n);if(!r)throw new l("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new t({fov:e.camera.fov}),c=new o({camera:i});if(r.target instanceof o){return ce(await _(e,r.target,r,a,c))}if(r.target instanceof t)return ce(await Q(e,r.target,a,c));const s=null!=r.scale||null!=r.zoom;if(r.target instanceof C){const t=r.target.xmin===r.target.xmax||r.target.ymin===r.target.ymax;return ce(s||t?await ee(e,r,r.target.center,i,a,c):await ae(e,r,r.target,i,a,c))}const u={boundingBox:v.empty(),hasZ:!1,screenSpaceObjects:[]},m=s?L(e,r):void 0;if(await X(e,r.target,m,u,a),isFinite(u.boundingBox[0])){let t;if(v.center(u.boundingBox,se),we.x=se[0],we.y=se[1],we.z=se[2],we.spatialReference=e.spatialReference,isFinite(we.z)&&u.hasZ?t=v.isPoint(u.boundingBox):(we.z=void 0,t=T.isPoint(v.toRect(u.boundingBox,ge))),s||t)return ce(await ee(e,r,we,i,a,c));const n=le(e,u.screenSpaceObjects);return ce(await re(e,r,we,u.boundingBox,n,i,a,c))}return r.position?ce(await te(e,r,i,c,a)):ce(await ne(e,r,i,a,c))}function K(e,t){return null==t.scale&&null!=t.zoom?A.zoomToScale(e,t.zoom):t.scale}function L(e,t){const n=K(e,t);return n?R.getResolutionInMetersForScale(n):void 0}function N(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=P(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function H(e,t,n,a){const o=e.spatialReference||M.WGS84;if(null==(t=null!=t?t:A.externalToInternal(e,n)))return a;const r=new z({spatialReference:o});return w.projectVectorToPoint(t.center,e.renderSpatialReference,r)?(a.targetGeometry=r,a.scale=A.computeScale(e,t),a.rotation=E(n.heading),a.camera=n,a):a}async function Y(e,t,n,a){const o=()=>new l("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw o();"mesh"===t.type&&(t=t.extent);const r=t.spatialReference,i=e.spatialReference,c=e.basemapTerrain.spatialReference;if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}null!=n&&null!=c&&null!=e.elevationProvider?(n=await y.projectWithZConversion(n,c,{signal:a}),se[2]=j.getElevationAtPoint(e.elevationProvider,n)??0):se[2]=0}const s=xe[t.type],u=new Array;if(s(t,t.hasZ?e=>{u.push([e[0],e[1],e[2]])}:e=>{u.push([e[0],e[1]])},se),0===u.length)throw o();const m=await y.projectWithZConversion(new O({spatialReference:r,hasZ:t.hasZ,hasM:!1,points:u}),i,{signal:a});if(t.hasZ&&(n.hasZ=!0),t.hasZ)for(const[l,f,g]of m.points)se[0]=l,se[1]=f,se[2]=g,v.expandWithVec3(n.boundingBox,se);else for(const[l,f]of m.points)se[0]=l,se[1]=f,v.expandWithVec3(n.boundingBox,se)}async function q(e,t,n,a,o){const i=await r.result(e.whenViewForGraphic(t));if(!1===i.ok||null==i.value||!("whenGraphicBounds"in i.value))return void await Y(e,t.geometry,a,o);const c=i.value,l=await r.result(c.whenGraphicBounds(t,{minDemResolution:n}));if(!1===l.ok||!l.value)return void await Y(e,t.geometry,a,o);const{screenSpaceObjects:s,boundingBox:u}=l.value;v.expandWithAABB(a.boundingBox,u),s&&s.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(u[2])&&(a.hasZ=!0)}async function X(e,t,n,o,r){if(Array.isArray(t)&&2===t.length){const n=t[0],a=t[1];if("number"==typeof n&&"number"==typeof a)return we.x=n,we.y=a,we.z=void 0,we.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:M.WGS84,void await Y(e,we,o,r)}t&&"map"in t&&"function"==typeof t.map?await Promise.allSettled(t.map((t=>X(e,t,n,o,r)))):t instanceof G?await Y(e,t,o,r):t instanceof a&&await q(e,t,n,o,r)}async function _(e,t,n,a,o){if(null!=t.camera)return Q(e,t.camera,a,o);o.scale=t.scale,o.rotation=t.rotation,o.targetGeometry=null!=t.targetGeometry?t.targetGeometry.clone():null,o.camera=null,null!=n.heading?o.rotation=E(n.heading):null!=n.rotation&&(o.rotation=n.rotation);const r=K(e,n);return null!=r&&(o.scale=r),o.camera=await D(e,o,n.tilt,a),o}async function Q(e,t,n,a){const o=e.spatialReference,r=await y.projectWithZConversion(t.position,o,{signal:n});return(t=t.clone()).fov=e.camera.fov,t.position=r,H(e,null,t,a)}async function $(e,t,n,a,o,r,i){const c=e.renderSpatialReference;return await h.projectPointToVectorAsync(t,de,c,0,{signal:i}),await h.projectPointToVectorAsync(n,ye,c,0,{signal:i}),r.targetGeometry=new z(t),o.position=new z(n),g.subtract(pe,de,ye),A.directionToHeadingTilt(e,ye,pe,a.up,o),r.scale=A.distanceToScale(e,g.distance(ye,de),r.targetGeometry.latitude),r.rotation=E(o.heading),r.camera=o,r}async function ee(e,t,n,a,o,r){if(null==n)throw new l("createfromcenter","invalid point");r.targetGeometry=n.clone();const i=S.cameraOnContentAlongViewDirection(e);if(t.position)return $(e,r.targetGeometry,t.position,i,a,r,o);if(t.zoomFactor){const a=i.distance/t.zoomFactor,o=g.scale(se,i.viewForward,-a);i.eye=g.add(se,i.center,o),r.scale=A.distanceToScale(e,a,n.latitude)}A.internalToExternal(e,i,a);const c=N(a,t)?A.OrientationMode.LOCKED:A.OrientationMode.ADJUST;if(!t.zoomFactor){const l=K(e,t);if(null==l){const{renderSpatialReference:t}=e;await h.projectPointToVectorAsync(n,se,t,0,{signal:o}),b.intersectsPoint(i.frustum,se)?r.scale=A.distanceToScale(e,g.distance(i.eye,se),n.latitude):r.scale=A.computeScale(e,i)}else r.scale=l;r.camera=await A.fromCenterScale(e,r.targetGeometry,r.scale,a,c,o)}return r}async function te(e,t,n,a,o){const r=S.cameraOnContentAlongViewDirection(e);g.copy(pe,r.viewForward),A.directionToHeadingTilt(e,r.eye,pe,r.up,he);const i=e.spatialReference,{position:c}=t;if(c){const e=await y.projectWithZConversion(c,i,{signal:o});n.position=e}else n.position=new z;return n.heading=null!=t.heading?t.heading:he.heading,n.tilt=null!=t.tilt?t.tilt:he.tilt,H(e,null,n,a)}async function ne(e,t,n,a,o){const r=S.cameraOnContentAlongViewDirection(e),{spatialReference:i,renderSpatialReference:c}=e,l=new z({spatialReference:i});return w.projectVectorToPoint(r.center,c,l)?ee(e,t,l,n,a,o):ee(e,t,null,n,a,o)}async function ae(e,t,n,a,o,r){r.targetGeometry=n.clone();const i=S.cameraOnContentAlongViewDirection(e);A.internalToExternal(e,i,a);const c=N(a,t)?A.OrientationMode.LOCKED:A.OrientationMode.ADJUST;return r.camera=await A.fromExtentAsync(e,n,a.heading,a.tilt,c,o),r}function oe(e,t,n,a,o){let r=0;null!=n.z?r=n.z:e.basemapTerrain&&e.elevationProvider&&(r=j.getElevationAtPoint(e.elevationProvider,n)),g.set(se,n.x,n.y,r),d.computeTranslationToOriginAndRotation(e.spatialReference,se,ue,e.renderSpatialReference),u.fromMat4(me,ue),u.transpose(me,me),v.empty(fe);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let u=0;u<i.length;u++){const t=i[u];let n=a[t[2]];isFinite(n)||(n=r),g.set(se,a[t[0]],a[t[1]],n),x.projectVectorToVector(se,e.spatialReference,se,e.renderSpatialReference),v.expandWithVec3(fe,g.transformMat3(se,se,me))}const c=v.width(fe),l=v.height(fe),s=v.depth(fe),m=1/Math.tan(t.fovX/2),f=1/Math.tan(t.fovY/2),p=.5*Math.sqrt(c*c+s*s)*Math.max(f,m)+.5*l,y=.5*l*f+.5*Math.max(c,s);return Math.max(p,y)/o}async function re(e,t,n,a,o,r,i,c){c.targetGeometry=n.clone();const l=S.cameraOnContentAlongViewDirection(e),s=oe(e,l,n,a,o);A.internalToExternal(e,l,r);const u=N(r,t)?A.OrientationMode.LOCKED:A.OrientationMode.ADJUST;return c.scale=A.distanceToScale(e,s,c.targetGeometry.latitude),c.camera=await A.fromCenterScale(e,c.targetGeometry,c.scale,r,u,i),c}function ie(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};return"declaredClass"in t||Array.isArray(t)?n.target=t:(Object.assign(n,t),t.center&&!n.target&&(n.target=t.center)),n}function ce(e){return null!=e?.camera&&(e.rotation=E(e.camera.heading)),e}function le(e,t){const n=V;if(!t.length)return n;let a=Number.NEGATIVE_INFINITY;for(let o=0;o<t.length;o++){const e=t[o].screenSpaceBoundingRect;a=Math.max(a,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-a/Math.min(e.width,e.height)*2}const se=p.create(),ue=f.create(),me=m.create(),fe=v.create(),ge=T.create(),pe=p.create(),ye=p.create(),de=p.create(),he={heading:0,tilt:0},we=new z,xe={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const a=e.hasZ;for(let o=0;o<e.rings.length;o++){const r=e.rings[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},polyline(e,t,n){const a=e.hasZ;for(let o=0;o<e.paths.length;o++){const r=e.paths[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},multipoint(e,t,n){const a=e.points,o=e.hasZ;for(let r=0;r<a.length;r++)n[0]=a[r][0],n[1]=a[r][1],o&&(n[2]=a[r][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(g.set(n,e.xmin,e.ymin,e.zmin)),t(g.set(n,e.xmax,e.ymin,e.zmin)),t(g.set(n,e.xmin,e.ymax,e.zmin)),t(g.set(n,e.xmax,e.ymax,e.zmin)),t(g.set(n,e.xmin,e.ymin,e.zmax)),t(g.set(n,e.xmax,e.ymin,e.zmax)),t(g.set(n,e.xmin,e.ymax,e.zmax)),t(g.set(n,e.xmax,e.ymax,e.zmax))):(t(g.set(n,e.xmin,e.ymin,n[2])),t(g.set(n,e.xmax,e.ymin,n[2])),t(g.set(n,e.xmin,e.ymax,n[2])),t(g.set(n,e.xmax,e.ymax,n[2])))}};e.create=J,e.fromCamera=k,e.toCameraAsync=D,e.toCameraSync=Z,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
