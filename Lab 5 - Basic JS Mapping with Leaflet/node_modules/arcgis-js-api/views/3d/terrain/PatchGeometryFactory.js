/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/mathUtils","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","./ElevationData","./interfaces","./ITile","./PatchGeometry","./PatchGeometryLUT","./PatchRenderData","./terrainUtils","./Tile","./tileUtils","../webgl-engine/lib/Normals"],(function(e,t,n,o,s,r,i,a,l,c,d,u,f,m){"use strict";const p=65536;function g(e,t){const{tile:o,geometry:s,geometryState:i}=e,{extentInRadians:a,surface:l}=o,{isWebMercator:c,renderer:d}=l,{numVerticesPerSide:u,wireframe:f}=i,m=u-1,p=(u-2)**2,g=c&&(t===r.PatchType.HAS_SOUTH_POLE||t===r.PatchType.HAS_BOTH_POLES),M=c&&(t===r.PatchType.HAS_NORTH_POLE||t===r.PatchType.HAS_BOTH_POLES),v=((g?1:0)+(M?1:0))*de*u,y=ae(i),E=p+v+4*y,A=d.tileGeometryCache.acquire(E);s.numVerticesPerSide=u,s.vertexAttributes=A,s.maxEdgeVertexCount=y;const{boundingBox:I}=s;n.empty(I);const B=V(e);ee.update(m,a,B),x(e),s.poleVerticesStartIndex=p;const b=h(e,g,M);s.edgeVerticesStartIndex=p+v,z(e),S(e),q(s,b,f),e.intersectionData=null}function h(e,t,n){const{tile:o,localOrigin:s,geometry:r}=e,{extent:i,ellipsoid:l}=o,{boundingBox:c,numVerticesPerSide:d,vertexAttributes:u,poleVerticesStartIndex:f}=r,p=d-1,g=s[0],h=s[1],x=s[2],M=l.radius,v=i[1],y=i[3],S=[];let E=f;const A=(e,t)=>{const n=t*d;ie(-g,-h,e*M-x,c),S.push({connectedRowOffset:n,connectedOuterEdgeOffset:1===e?0:2,rowOffset:E,latitudeResolution:de});const o=I(-1===e?v:y,M),s=e*Math.PI/2-o,r=.99*(1===e?1:-1),i=M+0,{position:l,uv0:f}=u,{typedBuffer:A,typedBufferStride:B}=u.normalCompressed;for(let d=1;d<=de;++d){const e=o+s*(d/de),t=Math.cos(e),n=Math.sin(e);for(let o=0;o<=p;o++){const e=o/p,s=ee.sinLonLUT[o],d=ee.cosLonLUT[o]*t,u=s*t,M=n,v=d*i-g,y=u*i-h,S=M*i-x;ie(v,y,S,c),l.setValues(E,v,y,S),a.encodeUVInBuffer(f,E,e,r),m.compressNormal(A,E,d,u,M,B),++E}}};return t&&A(-1,0),n&&A(1,p),S}function x(e){const{tile:t}=e;if(!t.intersectsClippingArea)return;const{geometry:n,geometryState:o,localOrigin:r}=e,{numVerticesPerSide:i,samplerData:l}=o,c=i-2,d=i-1,{vertexAttributes:u,boundingBox:f}=n,p=u.position,g=u.uv0,{typedBuffer:h,typedBufferStride:x}=u.normalCompressed,{extent:M}=t,v=M[0],y=M[2],S=M[1],E=M[3],A=t.ellipsoid.radius,I=r[0],B=r[1],b=r[2],V=p.typedBuffer,L=p.typedBufferStride,T=1/d;let P=0;if(1<=c){const e=T,t=S*(1-e)+E*e,n=ee.sinLatLUT[1],o=ee.cosLatLUT[1];for(let r=1;r<=c;r++){const i=r*T,c=v*(1-i)+y*i,d=ee.sinLonLUT[r],u=ee.cosLonLUT[r],m=A+s.sampleElevation(c,t,l),p=m*u*o-I,h=m*d*o-B,x=m*n-b;ie(p,h,x,f);const M=(r-1)*L;V[M]=p,V[M+1]=h,V[M+2]=x,a.encodeUVInBuffer(g,r-1,i,e)}}for(let C=1;C<=c;C++){const e=C*T,t=S*(1-e)+E*e,n=ee.sinLatLUT[C],o=ee.cosLatLUT[C],r=C+1,i=r*T,u=S*(1-i)+E*i,p=ee.sinLatLUT[r],M=ee.cosLatLUT[r],O=ee.sinLonLUT[0],U=ee.cosLonLUT[0],D=A+s.sampleElevation(v,t,l);let R=U*o*D-I,w=O*o*D-B,N=n*D-b;const F=P*L;let q=V[F],H=V[F+1],j=V[F+2];for(let E=1;E<=c;E++){const e=E*T,r=v*(1-e)+y*e,O=ee.sinLonLUT[E],U=ee.cosLonLUT[E];let D=0,F=0,_=0;if(E<c){const e=(P+1)*L;D=V[e],F=V[e+1],_=V[e+2]}else{const e=ee.sinLonLUT[d],r=ee.cosLonLUT[d],i=A+s.sampleElevation(y,t,l);D=r*o*i-I,F=e*o*i-B,_=n*i-b}const W=R,G=w,k=N;R=q,w=H,N=j,q=D,H=F,j=_;const z=D-W,J=F-G,K=_-k;let Q=0,X=0,Y=0;if(C>1){const e=(P-c)*L;Q=V[e],X=V[e+1],Y=V[e+2]}else{const e=ee.sinLatLUT[0],t=ee.cosLatLUT[0],n=A+s.sampleElevation(r,S,l);Q=U*t*n-I,X=O*t*n-B,Y=e*n-b}const Z=A+s.sampleElevation(r,u,l),$=U*M*Z-I,te=O*M*Z-B,ne=p*Z-b;if(C<c){const t=P+c,n=t*L;V[n]=$,V[n+1]=te,V[n+2]=ne,ie($,te,ne,f),a.encodeUVInBuffer(g,t,e,i)}const oe=Q-$,se=X-te,re=Y-ne;let ae=U*o,le=O*o,ce=n;ce*ce<.999&&(ae=K*se-J*re,le=z*re-K*oe,ce=J*oe-z*se);const de=1/Math.sqrt(ae*ae+le*le+ce*ce);m.compressNormal(h,P,ae*de,le*de,ce*de,x),++P}}}function M(e){e.tile.intersectsClippingArea&&(S(e),Y(e),e.intersectionData=null)}function v(e){e.tile.intersectsClippingArea&&(J(e),S(e),Y(e),Z(e),e.intersectionData=null)}function y(e){e.tile.intersectsClippingArea&&(A(e),E(e,!0),Y(e),e.intersectionData=null)}function S(e){e.tile.intersectsClippingArea&&(A(e),E(e))}function E(e,n=!1){const{geometry:o,geometryState:r,tile:i,localOrigin:l}=e,{level:u,extent:m,extentInRadians:p,ellipsoid:g}=i,h=g.radius,x=p[0],M=p[2],v=p[1],y=p[3],{samplerData:S}=r,E=m[0],A=m[2],I=m[1],B=m[3],b=V(e),{boundingBox:L,vertexAttributes:T}=o,P=l[0],C=l[1],O=l[2],U=T.position,D=U.typedBuffer,R=U.typedBufferStride,w=T.uv0;for(let V=0;V<4;++V){const l=1===V||3===V,p=r.edgeResolutions[V];d.internalAssert(t.isPowerOfTwo(p));const g=p+1,T=c.neighborTileIfLoadedOrSelf(i,r.edgePeerNeighbors[V]);if(oe(i,T,V)){K(e,V,T);continue}const U=null!=T;d.internalAssert(!U||T.level===i.level),d.internalAssert(!U||f.compareTilesByLij(i,T)<=0);const N=T?.renderData,F=N?.geometryState;if(d.enableTerrainInternalChecks){const e=i.surface;if(!T&&e&&!e.updatingRootTiles){const t=d.neighborEdgeIndices[V],n=i.findNeighborTile(t,(e=>e.isLoaded||e.isLeaf||e.level===i.level));n?n.intersectsClippingArea&&(d.internalAssert(!n.isLoaded),d.internalAssert(!n.isLeaf),d.internalAssert(n.level===u)):d.internalAssert(null==e?.rootTiles||!i.shouldHaveNeighbor(t))}}const q=1===V?m[2]:m[0],H=T?.extent,j=H&&l?1===V?H[0]:H[2]:q,_=0===V?m[3]:m[1],W=1===V?1:0,G=0===V?1:0,k=1===V?M:x,z=0===V?y:v,J=Math.sin(k),Q=Math.cos(k),X=Math.sin(z),Y=Math.cos(z),Z=F?.samplerData,$=U?(e,t,n)=>.5*(s.sampleElevation(e,t,S)+s.sampleElevation(n,t,Z)):(e,t,n)=>s.sampleElevation(e,t,S),ee=o.outerEdgesOffsetAndLength[2*V+0],te=n&&g>3?g-3:1,ne=null!=S&&S.some((e=>null!=e)),se=null!=Z&&Z.some((e=>null!=e)),re=ne||se,ae=1/p,le=ee;d.internalAssert(!H||d.almostEquals(H[2]-H[0],m[2]-m[0]));(()=>{const e=1===V?-1:3===V?1:0,t=0===V?-1:2===V?1:0,n=(m[2]-m[0])*ae,r=e*n,i=t*n,c=l?e*((M-x)*ae):0,d=l?0:t*ae,u=G,f=l?k+c:k,p=l?Math.sin(f):J,v=l?Math.cos(f):Q,y=l?k-c:k,T=l?Math.sin(y):J,N=l?Math.cos(y):Q,F=l?z:b(u+d),H=l?X:Math.sin(F),K=l?Y:Math.cos(F),ee=l?z:b(u-d),ne=l?X:Math.sin(ee),oe=l?Y:Math.cos(ee);let se=0,ce=0,de=0;{const e=0*ae,t=l?q:E*(1-e)+A*e,n=l?j:t,o=l?I*(1-e)+B*e:_,s=l?k:x*(1-e)+M*e,r=l?J:Math.sin(s),i=l?Q:Math.cos(s),a=l?b(e):z,c=l?Math.sin(a):X,d=l?Math.cos(a):Y,u=h+$(t,o,n);se=i*d*u,ce=r*d*u,de=c*u}let ue=0,fe=0,me=0;{const e=1*ae,t=l?q:E*(1-e)+A*e,n=l?j:t,o=l?I*(1-e)+B*e:_,s=l?k:x*(1-e)+M*e,r=l?J:Math.sin(s),i=l?Q:Math.cos(s),a=l?b(e):z,c=l?Math.sin(a):X,d=l?Math.cos(a):Y,u=h+$(t,o,n);ue=i*d*u,fe=r*d*u,me=c*u}for(let m=1;m<g-1;m+=te){let e=0,t=0,n=0;{const o=(m+1)*ae,s=l?q:E*(1-o)+A*o,r=l?j:s,i=l?I*(1-o)+B*o:_,a=l?k:x*(1-o)+M*o,c=l?J:Math.sin(a),d=l?Q:Math.cos(a),u=l?b(o):z,f=l?Math.sin(u):X,p=l?Math.cos(u):Y,g=h+$(s,i,r);e=d*p*g,t=c*p*g,n=f*g}const c=e,d=t,u=n,f=ue,g=fe,y=me;ue=c,fe=d,me=u;{const e=le+m,t=e*R,n=f-P,o=g-C,s=y-O;D[t]=n,D[t+1]=o,D[t+2]=s,ie(n,o,s,L);const r=m*ae,i=l?W:r,c=l?r:G;a.encodeUVInBuffer(w,e,i,c)}const F=se,ee=ce,te=de;se=f,ce=g,de=y;const pe=f,ge=g,he=y,xe=1/Math.sqrt(pe*pe+ge*ge+he*he),Me=he*xe;let ve=0,ye=0,Se=0;if(re&&Me*Me<.999){let e=0,t=0,n=0;{const o=0===V?-1:1;e=o*(c-F),t=o*(d-ee),n=o*(u-te)}{const o=m*ae,a=l?q:E*(1-o)+A*o,c=l?j:a,d=l?I*(1-o)+B*o:_,u=l?k:x*(1-o)+M*o,f=l?J:Math.sin(u),g=l?Q:Math.cos(u),y=l?b(o):z,L=l?Math.sin(y):X,P=l?Math.cos(y):Y;let C=pe,O=ge,D=he;if(U){const e=c-r,t=d-i,n=h+s.sampleElevation(e,t,Z),o=l?P:oe;C=(l?N:g)*o*n,O=(l?T:f)*o*n,D=(l?L:ne)*n}{const o=a+r,c=d+i,u=h+s.sampleElevation(o,c,S),m=l?P:K,x=(l?v:g)*m*u,M=(l?p:f)*m*u,y=(l?L:H)*u;U||(C=2*pe-x,O=2*ge-M,D=2*he-y);const E=3===V?-1:1,A=E*(C-x),I=E*(O-M),B=E*(D-y);ve=n*I-t*B,ye=e*B-n*A,Se=t*A-e*I;const b=1/Math.sqrt(ve*ve+ye*ye+Se*Se);ve*=b,ye*=b,Se*=b}}}else ve=pe*xe,ye=ge*xe,Se=he*xe;o.setEdgeNormalFromValues(V,m,ve,ye,Se)}})()}}function A(e){Q(e)}function I(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function B(e,t,n,o){return I(e*(1-o)+t*o,n)}function b(e,t,n){return e*(1-n)+t*n}function V(e){const{tile:t}=e;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius;return t=>B(e[1],e[3],n,t)}const n=t.extentInRadians;return e=>b(n[1],n[3],e)}function L(e,t){const{tile:o,geometryState:s,geometry:r}=e,{extent:i,surface:a}=o,{wireframe:l}=s,c=i[0],d=i[1],u=i[2]-c,f=i[3]-d,{numVerticesPerSide:m,clippingArea:p}=s,g=null!=p?Math.max(0,(p[0]-c)/u):0,h=null!=p?Math.max(0,(p[1]-d)/f):0,x=null!=p?Math.min(1,(p[2]-c)/u):1,M=null!=p?Math.min(1,(p[3]-d)/f):1,v=(m-2)**2,y=ae(s),S=v+4*y,E=a.renderer.tileGeometryCache.acquire(S),{boundingBox:A}=r;n.empty(A),r.numVerticesPerSide=m,r.vertexAttributes=E,r.maxEdgeVertexCount=y,r.minu=g,r.minv=h,r.maxu=x,r.maxv=M,T(e),r.edgeVerticesStartIndex=v,z(e),U(e),q(r,[],l),e.intersectionData=null}function T(e){const{tile:n}=e;if(!n.intersectsClippingArea)return;const{geometry:o,geometryState:r,localOrigin:i}=e,{samplerData:l,clippingArea:c,numVerticesPerSide:d}=r,{surface:u,extent:f,ellipsoid:p}=n,{isWebMercatorOnPlateCarree:g}=u,h=null!=c?c:te,x=f[0],M=f[1],v=f[2],y=f[3],S=Math.max(x,h[0]),E=Math.min(v,h[2]),A=Math.max(M,h[1]),I=Math.min(y,h[3]),B=p.radius,b=n.horizontalScale,V=d-1,L=d-2,{minu:T,minv:P,maxu:C,maxv:O,boundingBox:U,vertexAttributes:D}=o,R=D.position,w=D.uv0,{typedBuffer:N,typedBufferStride:F}=D.normalCompressed,q=i[0],H=i[1],j=i[2],_=R.typedBuffer,W=R.typedBufferStride;let G=0;const k=t.clamp(M,A,I),z=g?(Math.PI/2-2*Math.atan(Math.exp(-k/B)))*B:k*b,J=1/V,K=t.clamp(M*(1-J)+y*J,A,I);let Q=z,X=g?(Math.PI/2-2*Math.atan(Math.exp(-K/B)))*B:K*b;for(let Y=1;Y<=L;Y++){const e=Y/V,n=t.clamp(M*(1-e)+y*e,A,I),o=t.clamp(e,P,O),r=X,i=(Y-1)/V,c=t.clamp(M*(1-i)+y*i,A,I),d=Q,u=(Y+1)/V,f=t.clamp(M*(1-u)+y*u,A,I),p=g?(Math.PI/2-2*Math.atan(Math.exp(-f/B)))*B:f*b,h=t.clamp(u,P,O);Q=X,X=p;const D=t.clamp(x,S,E);let R=D*b,k=s.sampleElevation(D,n,l);const z=1/V,J=t.clamp(z,T,C),K=t.clamp(x*(1-J)+v*J,S,E);let Z=J,$=K,ee=K*b,te=s.sampleElevation(K,n,l);if(1===Y){const e=ee-q,n=Q-H,s=te-j,r=0*W;_[r]=e,_[r+1]=n,_[r+2]=s,ie(e,n,s,U);const i=t.clamp(z,T,C);a.encodeUVInBuffer(w,G,i,o)}for(let g=1;g<=L;g++){const e=ee,i=te,u=(g+1)/V,M=t.clamp(u,T,C),y=t.clamp(x*(1-u)+v*u,S,E),A=$;$=y;{const e=G+1,t=e*W;if(1===Y||g===L){const i=y*b,c=s.sampleElevation(y,n,l);if(1===Y&&g<L){const n=i-q,s=r-H,l=c-j;_[t]=n,_[t+1]=s,_[t+2]=l,ie(n,s,l,U),a.encodeUVInBuffer(w,e,M,o)}ee=i,te=c}else ee=_[t]+q,te=_[t+2]+j}const I=ee,B=te,P=R,O=k;R=e,k=i;const D=(G-L)*W,z=1===Y?s.sampleElevation(A,c,l):_[D+2]+j,J=s.sampleElevation(A,f,l);if(Y<L){const t=G+L,n=t*W,o=e-q,s=p-H,r=J-j;_[n]=o,_[n+1]=s,_[n+2]=r,ie(o,s,r,U);const i=Z;Z=M,a.encodeUVInBuffer(w,t,i,h)}{const e=I-P,t=d-p,n=t*(B-O),o=e*(z-J),s=-t*e,r=n*n+o*o+s*s;if(0===r)m.compressNormal(N,G,0,0,1,F);else{const e=1/Math.sqrt(r);m.compressNormal(N,G,n*e,o*e,s*e,F)}}++G}}}function P(e,t){e.tile.intersectsClippingArea&&(R(e),D(e,!0),Y(e),e.intersectionData=null)}function C(e,t){e.tile.intersectsClippingArea&&(J(e),U(e),Y(e),Z(e),e.intersectionData=null)}function O(e,t){e.tile.intersectsClippingArea&&(U(e),Y(e),e.intersectionData=null)}function U(e,t){e.tile.intersectsClippingArea&&(R(e),D(e,!1))}function D(e,n){const{geometry:o,geometryState:r,tile:i,localOrigin:a}=e,{surface:l,extent:u}=i,{clippingArea:m,samplerData:p}=r,g=null!=m?m:te,h=u[0],x=u[2],M=u[1],v=u[3],y=[v>g[3],x>g[2],M<g[1],h<g[0]],S=i.horizontalScale,E=F(l.isWebMercatorOnPlateCarree,i.ellipsoid.radius,S),{minu:A,minv:I,maxu:B,maxv:b,boundingBox:V}=o,L=Math.max(h,g[0]),T=Math.min(x,g[2]),P=Math.max(M,g[1]),C=Math.min(v,g[3]),O=a[0],U=a[1],D=a[2];for(let R=0;R<4;++R){const a=1===R||3===R,u=r.edgeResolutions[R];d.internalAssert(t.isPowerOfTwo(u));const m=u+1,g=y[R],w=c.neighborTileIfLoadedOrSelf(i,r.edgePeerNeighbors[R]);if(!g&&oe(i,w,R)){K(e,R,w);continue}const N=null!=w&&!g,F=w?.renderData,q=F?.geometryState;if(d.enableTerrainInternalChecks&&(d.internalAssert(!N||w.level===i.level),d.internalAssert(!N||f.compareTilesByLij(i,w)<=0),i&&!w&&!l.updatingRootTiles)){const e=d.neighborEdgeIndices[R],t=i.findNeighborTile(e,(e=>e.isLoaded||e.isLeaf||e.level===i.level));l.updatingRootTiles||(t?t.intersectsClippingArea&&(d.internalAssert(!t.isLoaded),d.internalAssert(!t.isLeaf),d.internalAssert(t.level===i.level)):d.internalAssert(null==l?.rootTiles||!i.shouldHaveNeighbor(e)))}const H=t.clamp(1===R?x:h,L,T),j=t.clamp(0===R?v:M,P,C),_=q?.samplerData,W=n&&m>3?m-3:1,G=t.clamp(1===R?1:0,A,B),k=t.clamp(0===R?1:0,I,b),z=N?(e,t)=>.5*(s.sampleElevation(e,t,_)+s.sampleElevation(e,t,p)):(e,t)=>s.sampleElevation(e,t,p),J=(x-h)/u,Q=a?1===R?J:-J:0,X=a?0:0===R?J:-J,Y=-Q,Z=-X;let $=0,ee=0,te=0;{const e=0/u,n=a?H:t.clamp(h*(1-e)+x*e,L,T),o=a?t.clamp(M*(1-e)+v*e,P,C):j,s=z(n,o);$=n*S,ee=E(o),te=s}let ne=0,se=0,re=0;{const e=1/u,n=a?H:t.clamp(h*(1-e)+x*e,L,T),o=a?t.clamp(M*(1-e)+v*e,P,C):j,s=z(n,o);ne=n*S,se=E(o),re=s}for(let e=1;e<m-1;e+=W){const n=e/u,r=ne,i=se,l=re;{const s=a?G:t.clamp(n,A,B),c=a?t.clamp(n,I,b):k,d=r-O,u=i-U,f=l-D;ie(r,u,f,V),o.setEdgeVertexFromValuesRawPositionUV(R,e,d,u,f,s,c)}{const n=(e+1)/u,o=a?H:t.clamp(h*(1-n)+x*n,L,T),s=a?t.clamp(M*(1-n)+v*n,P,C):j,r=z(o,s);ne=o*S,se=E(s),re=r}const c=ne,d=re,f=$,m=ee,g=te;$=r,ee=i,te=l;let y=0,w=0,F=0;if(a){const e=se-i,o=d-l,a=m-i,c=g-l,u=t.clamp(M*(1-n)+v*n,P,C),f=H+Y,h=u,x=f*S-r,E=s.sampleElevation(f,h,p)-l,A=3===R?-1:1;if(y=A*(-a+e)*E,w=A*x*(-c+o),F=-A*x*(-a+e),N){const t=H+Q,n=u,i=t*S-r;y=(-a+e)*(E-(s.sampleElevation(t,n,_)-l)),w=(x-i)*(-c+o),F=-(x-i)*(-a+e)}}else{const e=c-r,o=d-l,a=f-r,u=g-l,m=t.clamp(h*(1-n)+x*n,L,T),M=m,v=j+Z,S=s.sampleElevation(M,v,p)-l,A=E(v)-i,I=2===R?-1:1;if(y=I*A*(-u+o),w=I*(-a+e)*S,F=-I*A*(-a+e),N){const t=m,n=j+X,r=E(n)-i;y=(-A+r)*(-u+o),w=(-a+e)*(-S+(s.sampleElevation(t,n,_)-l)),F=-(-A+r)*(-a+e)}}const q=1/Math.sqrt(y*y+w*w+F*F);o.setEdgeNormalFromValues(R,e,y*q,w*q,F*q)}}}function R(e,t){Q(e)}function w(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}function N(e,t){return e*t}function F(e,t,n){return e?e=>w(e,t):e=>N(e,n)}function q(e,t,n){const{numVerticesPerSide:o,vertexAttributes:s,maxEdgeVertexCount:r}=e,i=o-1,a=s.count,l=2*(o-3)*(o-3),d=4*(i+r-3),u=c.zeroToFour.reduce(((t,n)=>t+(i+e.getEdgeCount(n)-3)),0),f=t.reduce(((e,t)=>e+i*(2*(t.latitudeResolution-1)+1)),0),m=3*(n?2:1),g=(l+d+f)*m,h=a>=p?new Uint32Array(g):new Uint16Array(g);for(let c=0;c<g;++c)h[c]=0;e.indices=h,e.indexCount=(l+u+f)*m,e.poleIndicesStartIndex=l*m,e.edgeIndicesStartIndex=(l+f)*m,n?(W(e),G(e,t),k(e)):(H(e),j(e,t),_(e))}function H(e){const{numVerticesPerSide:t,indices:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=t-2,l=t-3,c=0,d=t-3;let u=0;for(let f=0;f<l;++f){const e=f*a;for(let t=c;t<d;++t){const o=e+t,s=o+1,l=s+a,c=l-1;le(o,s,l,c,i,r)?(n[u]=o,n[u+1]=s,n[u+2]=l,n[u+3]=l,n[u+4]=c,n[u+5]=o):(n[u]=o,n[u+1]=s,n[u+2]=c,n[u+3]=c,n[u+4]=s,n[u+5]=l),u+=6}}}function j(e,t){const{numVerticesPerSide:n,indices:o,poleIndicesStartIndex:s}=e,r=n-1;let i=s;for(const a of t){let t=e.getEdgeVertexIndex(a.connectedOuterEdgeOffset,0),s=1;for(let e=0;e<a.latitudeResolution;++e){const l=0===e?a.rowOffset:t+n;for(let n=0;n<r;n++){const r=l+n;o[i]=t,o[i+1]=t+1,o[i+2]=r,e<a.latitudeResolution-1?(o[i+3]=t+1,o[i+4]=r+1,o[i+5]=r,i+=6):i+=3,t+=s}t=l,s=1}}}function _(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let a=0;a<4;++a){const n=re[a];let o=0,l=0;const c=e.getEdgeCount(a),u=n.count;d.internalAssert(u===s-1);const f=1===a||2===a,m=f?1:2,p=f?2:1,g=e.getEdgeFirstVertexIndex(a),h=1,x=n.vertex0Index,M=n.stride;for(;o<c-1||l<u-1;){const e=x+l*M,n=g+o*h,a=o<c-1,d=l<u-1,f=a&&(!d||(a?0+s*(o+.5)/(c-1):0)<=(d?1+r*(l+.5)/(u-1):0));f?++o:++l;const v=f?n+h:e+M;t[i]=e,t[i+m]=n,t[i+p]=v,i+=3}}e.indexCount=i}function W(e){const{indices:t,numVerticesPerSide:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=n-2;let l=0;for(let c=0;c<n-3;++c){const e=c*a;for(let o=0;o<n-3;++o){const n=c*a+o,s=n+1,d=s+a,u=d-1,f=e+o,m=f+1,p=m+a;le(f,m,p,p-1,i,r)?(ce(t,l,n,s,d),l+=6,ce(t,l,d,u,n)):(ce(t,l,n,s,u),l+=6,ce(t,l,u,d,s)),l+=6}}}function G(e,t){const{indices:n,numVerticesPerSide:o,poleIndicesStartIndex:s}=e,r=o-1;let i=s;for(const a of t){const t=a.connectedOuterEdgeOffset;let s=e.getEdgeVertexIndex(t,0),l=1;for(let e=0;e<a.latitudeResolution;++e){const t=0===e?a.rowOffset:s+o;for(let o=0;o<r;o++)ce(n,i,s,s+1,t+o),i+=6,e<a.latitudeResolution-1&&(ce(n,i,s+1,t+o+1,t+o),i+=6),s+=l;s=t,l=1}}}function k(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let a=0;a<4;++a){const n=re[a];let o=0,l=0;const c=e.getEdgeCount(a),u=n.count;d.internalAssert(u===s-1);const f=1===a||2===a,m=f?1:3,p=f?3:1,g=e.getEdgeFirstVertexIndex(a),h=1,x=n.vertex0Index,M=n.stride;for(;o<c-1||l<u-1;){const e=x+l*M,n=g+o*h,a=o<c-1,d=l<u-1,f=a&&(!d||(a?0+s*(o+.5)/(c-1):0)<=(d?1+r*(l+.5)/(u-1):0));f?++o:++l;const v=f?n+h:e+M;t[i]=e,t[i+m]=n,t[i+m+1]=n,t[i+p]=v,t[i+p+1]=v,t[i+5]=e,i+=6}}e.indexCount=i}function z(e){const{geometry:t,geometryState:n}=e,{edgeResolutions:o}=n,{numVerticesPerSide:s,edgeVerticesStartIndex:r}=t,i=s-2;let a=r;for(let l=0;l<4;++l){{const e=0===l||2===l,t=(0===l?i-1:0)*i+(1===l?i-1:0),n=(e?0:1)*i+(e?1:0),o=re[l];o.vertex0Index=t,o.stride=n,o.count=i}{const e=o[l]+1;t.outerEdgesOffsetAndLength[2*l+0]=a,t.outerEdgesOffsetAndLength[2*l+1]=e,a+=e}}}function J(e){z(e),e.geometryState.wireframe?k(e.geometry):_(e.geometry)}function K(e,n,o){const s=(n+2)%4,{geometryState:r,geometry:i,tile:l,localOrigin:c}=e,u=l.level-o.level,f=1===n||3===n,m=r.edgeResolutions[n];d.internalAssert(t.isPowerOfTwo(m));const p=m+1,{boundingBox:g,minu:h,minv:x,maxu:M,maxv:v,vertexAttributes:y}=i,S=t.clamp(1===n?1:0,h,M),E=t.clamp(0===n?1:0,x,v),A=o.renderData,I=A.geometryState,B=A.geometry,b=B.getEdgeCount(s),V=l.getNeighborEdgeStartVertexIndex(n,o)*m,L=m*2**u;d.internalAssert(I.edgeResolutions[s]===L),d.internalAssert(b-1===L);const T=A.localOrigin[0]-c[0],P=A.localOrigin[1]-c[1],C=A.localOrigin[2]-c[2],O=i.getEdgeFirstVertexIndex(n),U=y.position,D=U.typedBuffer,R=U.typedBufferStride,w=y.normalCompressed,N=w.typedBuffer,F=w.typedBufferStride,q=y.uv0,H=B.vertexAttributes,j=B.getEdgeFirstVertexIndex(s),_=H.position.typedBuffer,W=H.position.typedBufferStride,G=H.normalCompressed.typedBuffer,k=H.normalCompressed.typedBufferStride;for(let d=1;d<p-1;++d){const e=O+d,n=j+(V+d),o=e*R,s=n*W,r=_[s]+T,i=_[s+1]+P,l=_[s+2]+C;D[o]=r,D[o+1]=i,D[o+2]=l,ie(r,i,l,g);const c=e*F,u=n*k;N[c]=G[u],N[c+1]=G[u+1];const p=d/m,y=f?S:t.clamp(p,h,M),A=f?t.clamp(p,x,v):E;a.encodeUVInBuffer(q,e,y,A)}}function Q(e){const{geometry:n,geometryState:o,localOrigin:r,tile:i}=e,{clippingArea:l,samplerData:c}=o,{minu:u,minv:m,maxu:p,maxv:g,boundingBox:h,vertexAttributes:x}=n,{surface:M,ellipsoid:v,extent:y,extentInRadians:S,horizontalScale:E}=i,A="local"===M.view?.viewingMode,I=v.radius;let B=0,b=0,L=0;const T=(e,t,n)=>{const o=S[0===t?1:3],s=S[0===e?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),l=Math.cos(s),c=I+n;B=l*r*c,b=a*r*c,L=i*c},P=A?(()=>{const e=l,n=null!=e&&(y[3]>e[3]||y[2]>e[2]||y[1]<e[1]||y[0]<e[0]),o=F(M.isWebMercatorOnPlateCarree,I,E);return(s,r,i)=>{const a=0===s?y[0]:y[2],l=0===r?y[1]:y[3],c=n?t.clamp(a,e[0],e[2]):a,d=n?t.clamp(l,e[1],e[3]):l,u=i;B=c*E,b=o(d),L=u}})():T;let C=0,O=0,U=0,D=0,R=0,w=0,N=0,q=0,H=0;const j=A&&M.isWebMercatorOnPlateCarree,_=(e,t,n,o,s)=>{let r=0,i=0,a=0;if(A){const e=t*E,s=j?(Math.PI/2-2*Math.atan(Math.exp(-n/I)))*I:n*E;r=e-B,i=s-b,a=o-L}else{const s=V(e),l=e.tile,c=l.extent,d=l.extentInRadians,u=(t-c[0])/(c[2]-c[0]),f=(n-c[1])/(c[3]-c[1]),m=d[0]*(1-u)+d[2]*u,p=s(f),g=Math.cos(p),h=Math.sin(p),x=Math.sin(m),M=Math.cos(m),v=I+o;r=M*g*v-B,i=x*g*v-b,a=h*v-L}switch(s){case 0:N+=r,q+=i,H+=a;break;case 1:D-=r,R-=i,w-=a;break;case 2:N-=r,q-=i,H-=a;break;case 3:D+=r,R+=i,w+=a}},W=l??te,G=y[0],k=y[2],z=y[1],J=y[3],K=[J>W[3],k>W[2],z<W[1],G<W[0]],Q=Math.max(G,W[0]),Y=Math.min(k,W[2]),Z=Math.max(z,W[1]),ee=Math.min(J,W[3]),oe=e=>Math.max(W[0],Math.min(W[2],e)),se=e=>Math.max(W[1],Math.min(W[3],e)),re=e=>{const t=o.cornerNeighborCornerTiles;C=0,O=0,U=1,D=0,R=0,w=0,N=0,q=0,H=0;let n=1/0;for(let o=0;o<4;++o){const s=t[4*e+o];n=Math.min(n,s?.level??1/0)}for(let o=0;o<4;++o){const s=t[4*e+o];ne[o]=s?.level===n?s:null}let r=1,i=0;for(let o=0;o<4;++o){const e=ne[o];e&&(r=Math.max(r,e?.renderData.geometryState.numVerticesPerSide),i=e.extent[2]-e.extent[0])}const a=i,l=r;d.internalAssert(l>1);const c=a/l;for(let o=0;o<4;++o){const e=ne[(o+3)%4],t=ne[o%4];if(!e&&!t)continue;const n=0===o?1:1===o?2:2===o?3:0,r=0===o?2:1===o?3:2===o?0:1;if(e&&t){const i=$[o][0]*c,a=$[o][1]*c,l=e.extent,d=oe(l[0===n||1===n?2:0]+i),u=se(l[0===n||3===n?3:1]+a),f=t.extent,m=oe(f[0===r||1===r?2:0]+i),p=se(f[0===r||3===r?3:1]+a),g=e.renderData,h=t.renderData,x=s.sampleElevation(d,u,g.geometryState.samplerData),M=s.sampleElevation(m,p,h.geometryState.samplerData);_(g,d,u,.5*(x+M),o)}else{const i=e??t,a=e?n:r,l=i.extent,d=$[o],u=oe(l[0===a||1===a?2:0]+d[0]*c),f=se(l[0===a||3===a?3:1]+d[1]*c),m=i.renderData,p=s.sampleElevation(u,f,m.geometryState.samplerData);_(m,u,f,p,o)}}if(!A){const e=Math.sqrt(B*B+b*b+L*L);C=B/e,O=b/e,U=L/e}if(A||U*U<.999){const e=Math.sqrt(D*D+R*R+w*w);D/=e,R/=e,w/=e;const t=Math.sqrt(N*N+q*q+H*H);N/=t,q/=t,H/=t,C=w*q-R*H,O=D*H-w*N,U=R*N-D*q;const n=1/Math.sqrt(C*C+O*O+U*U);C*=n,O*=n,U*=n}},ae=o.cornerNeighborCornerTiles;for(let V=0;V<4;++V){const e=V,l=(V+1)%4,M=0===V||1===V?1:0,v=0===V||3===V?1:0,y=t.clamp(M,u,p),S=t.clamp(v,m,g),E=n.getEdgeFirstVertexIndex(e),A=n.getEdgeCount(e),I=0===V||3===V?A-1:0,T=n.getEdgeFirstVertexIndex(l),D=n.getEdgeCount(l),R=0===V||1===V?D-1:0;let w=-1;for(let t=0;t<4;++t){const e=ae[4*V+t],n=ae[4*V+w];e&&(-1===w||f.compareTilesByLij(n,e)>0)&&(w=t)}const N=w,F=ae[4*V+N];if(F!==i){const e=i.level-F.level,t=2**e,n=[F.lij[0]+e,F.lij[1]*t,F.lij[2]*t],s=[n[1]+t===i.lij[1],0===V&&(1===N||0===N&&F!==ae[4*V+3])||1===V&&(0===N||1===N&&F!==ae[4*V+2]),n[1]===i.lij[1]+1,2===V&&(3===N||2===N&&F!==ae[4*V+1])||3===V&&(2===N||3===N&&F!==ae[4*V+0])],l=s.reduce(((e,t)=>e+(t?1:0)),0);d.internalAssert(1===l||2===l);let c=-1,u=-1;const f=F.renderData;if(1===l){const e=s.findIndex((e=>e));d.internalAssert(0<=e&&e<=3),c=(e+2)%4;const t=o.edgeResolutions[e];u=i.getNeighborEdgeStartVertexIndex(e,F)*t+t*(0===e&&0===V||1===e&&0===V||2===e&&1===V||3===e&&3===V?1:0)}else{d.internalAssert(s[1]||s[3]),c=s[1]?3:1;const e=f.geometryState.edgeResolutions[c];u=0===V||3===V?0:e}const m=f.geometry;{const e=E+I,t=T+R,n=m.getEdgeFirstVertexIndex(c)+u,o=m.vertexAttributes,s=f.localOrigin;{const i=o.position,a=i.typedBuffer,l=n*i.typedBufferStride,c=a[l]+s[0]-r[0],d=a[l+1]+s[1]-r[1],u=a[l+2]+s[2]-r[2];ie(c,d,u,h);const f=x.position,m=f.typedBuffer;{const t=e*f.typedBufferStride;m[t]=c,m[t+1]=d,m[t+2]=u}{const e=t*f.typedBufferStride;m[e]=c,m[e+1]=d,m[e+2]=u}}const i=x.uv0;a.encodeUVInBuffer(i,e,y,S),a.encodeUVInBuffer(i,t,y,S);{const s=o.normalCompressed.typedBuffer,r=n*o.normalCompressed.typedBufferStride,i=x.normalCompressed,a=i.typedBuffer;{const t=e*i.typedBufferStride;a[t]=s[r],a[t+1]=s[r+1]}{const e=t*i.typedBufferStride;a[e]=s[r],a[e+1]=s[r+1]}}}}else{const o=K[e],i=K[l];let a;if(o||i){const e=t.clamp(G*(1-M)+k*M,Q,Y),n=t.clamp(z*(1-v)+J*v,Z,ee);a=s.sampleElevation(e,n,c)}else a=X(ae,V);P(M,v,a),re(V);const d=B-r[0],u=b-r[1],f=L-r[2];ie(d,u,f,h),n.setEdgeVertexFromValuesRawPositionUVNormal(e,I,d,u,f,y,S,C,O,U),n.setEdgeVertexFromValuesRawPositionUVNormal(l,R,d,u,f,y,S,C,O,U)}}for(let t=0;t<4;++t)ne[t]=null}function X(e,t){const n=4*t,o=c.zeroToFour.reduce(((t,o)=>Math.min(t,e[n+o]?.level??1/0)),1/0);d.enableTerrainInternalChecks&&(d.internalAssert(!e[n+0]||!e[n+2]||u.isCornerNeighbor(e[n+0],e[n+2],i.NeighborIndex.SOUTH_WEST)),d.internalAssert(!e[n+1]||!e[n+3]||u.isCornerNeighbor(e[n+1],e[n+3],i.NeighborIndex.NORTH_WEST)));let r=0,a=0;for(let i=0;i<4;++i){const t=e[n+i];if(t&&t.level===o){const e=0===i||1===i,n=0===i||3===i,o=t.extent,l=o[e?0:2],c=o[n?1:3],d=t.renderData?.geometryState?.samplerData;a+=s.sampleElevation(l,c,d),r++}}const l=r?a/r:0;return d.internalAssert(null!=l),l}function Y(e){const{vao:t,geometry:n}=e,{vertexAttributes:o,edgeVerticesStartIndex:s}=n,r=o.position.typedBuffer;t.vertexBuffers.geometry.setSubData(r,s,s,r.length)}function Z(e){const{vao:t,geometry:n}=e,{indices:o,indexCount:s,edgeIndicesStartIndex:r}=n;t.indexBuffer.setSubData(o,r,r,s)}const $=[[0,1],[1,0],[0,-1],[-1,0]],ee=new l.PatchGeometryLUT,te=o.fromValues(-1/0,-1/0,1/0,1/0),ne=[null,null,null,null];function oe(e,t,n){if(!t)return!1;const o=f.compareTilesByLij(e,t);return o>0||0===o&&n>=2}class se{constructor(){this.vertex0Index=0,this.stride=1,this.count=0}getVertexIndex(e){return d.internalAssert(0<=e&&e<this.count),this.vertex0Index+this.stride*e}}const re=[new se,new se,new se,new se];function ie(e,t,n,o){e<o[0]?o[0]=e:e>o[3]&&(o[3]=e),t<o[1]?o[1]=t:t>o[4]&&(o[4]=t),n<o[2]?o[2]=n:n>o[5]&&(o[5]=n)}function ae(e){const{edgeResolutions:t,numVerticesPerSide:n}=e,o=1+Math.max(...t);return Math.max(n,o)}function le(e,t,n,o,s,r){const i=e*s,a=r[i],l=r[i+1],c=r[i+2],d=t*s,u=r[d],f=r[d+1],m=r[d+2],p=n*s,g=r[p],h=r[p+1],x=r[p+2],M=o*s,v=r[M],y=r[M+1],S=r[M+2];return(u-v)*(u-v)+(f-y)*(f-y)+(m-S)*(m-S)>(a-g)*(a-g)+(l-h)*(l-h)+(c-x)*(c-x)}function ce(e,t,n,o,s){e[t]=n,e[t+1]=o,e[t+2]=o,e[t+3]=s,e[t+4]=s,e[t+5]=n}const de=6;e.createPlanarGlobePatch=L,e.createSphericalGlobePatch=g,e.updateCornerSpherical=y,e.updateCornersPlanar=P,e.updateEdgeElevationsAndResolutionsPlanar=C,e.updateEdgeElevationsAndResolutionsSpherical=v,e.updateEdgesAndCornersPlanar=O,e.updateEdgesAndCornersSpherical=M,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
