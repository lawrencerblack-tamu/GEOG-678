/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/mathUtils","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/projection/lonLatToSphericalPCPF","../../../geometry/support/DoubleArray","../../../geometry/support/frustum","../../../chunks/sphere","./interfaces","./ITile","./PatchGeometryFactory","./terrainUtils","./Tile","./tileUtils"],(function(e,t,i,s,n,o,r,a,l,c,h,u,d,p){"use strict";class f extends d.Tile{constructor(e,t,i,s,n){super(),this._convexHull=new Array(24),this._boundingSphere=a.create(),this._baseUsedMemory=1816,this.init(e,t,i,s,n)}init(e,s,o,r,a){super.init(e,s,o,r,a);const l=this.ellipsoid.radius,c=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],d=this.extentInRadians[3],p=t.lerp(h,d,.5),f=t.lerp(c,u,.5),m=0===e?0:Math.min(Math.abs(h),Math.abs(d));this._edgeLen=(u-c)*Math.cos(m)*l,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=l-Math.sqrt(l*l-this._edgeLen2/4),n.lonLatToSphericalPCPF(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),i.normalize(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const e=this._center;if(0===this.lij[0])i.set(a.getCenter(e[d.CenterPosition.MIDDLE]),0,0,0),i.set(e[d.CenterPosition.TOP],0,0,0),i.set(e[d.CenterPosition.BOTTOM],0,0,0),e[d.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const t=e[d.CenterPosition.MIDDLE],i=this.convexHull;let s=0;for(let e=0;e<8;++e)s=Math.max(s,g(a.getCenter(t),i,3*e));e[d.CenterPosition.MIDDLE][3]=Math.sqrt(s)}}_calculateFrustumVisibilityStatus(e){if(!r.intersectsSphere(e,this._boundingSphere))return c.TileFrustumVisibility.OUTSIDE;if(this.lij[0]<10)return c.TileFrustumVisibility.INTERSECTS;const t=this.convexHull,i=this.surface.view.state.camera.near;let s=!0;for(let n=0;n<r.numPlanes;n++){const o=n===r.PlaneIndex.NEAR,a=e[n],l=a[0],h=a[1],u=a[2],d=a[3]-(o?i:0);let p=!1;for(let e=0;e<8;++e){const i=3*e;if(l*t[i]+h*t[i+1]+u*t[i+2]+d<0){if(p=!0,!s)break}else s=!1}if(!p)return c.TileFrustumVisibility.OUTSIDE}return s?c.TileFrustumVisibility.INSIDE:c.TileFrustumVisibility.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){h.createSphericalGlobePatch(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),u.enableTerrainInternalChecks&&this._checkBVs()}_updateBoundingSphere(){const e=this._boundingSphere,t=a.getCenter(e),s=this.elevationBoundsMin,n=this.elevationBoundsMax,o=this.ellipsoid.radius,r=n;if(0===this.level)i.set(t,0,0,0),e[3]=o+r;else{const r=this.extentInRadians,a=.5*(r[0]+r[2]),l=r[1],c=r[3];b(_,a,l,o),b(v,a,c,o),i.add(t,_,v);const h=o+.5*(s+n);i.scale(t,t,h/i.len(t));const u=this.convexHull;let d=0;const p=(e,t)=>{const i=e[0]-u[3*t],s=e[1]-u[3*t+1],n=e[2]-u[3*t+2];return Math.sqrt(i*i+s*s+n*n)};for(let e=0;e<8;++e){const i=p(t,e);d=Math.max(d,i)}const f=d;e[3]=f+2}}_updateConvexHull(){const e=this.extentInRadians,t=this.ellipsoid.radius;if(0===this.level)return;const n=this.elevationBoundsMin,o=this.elevationBoundsMax,r=this._getPatchType(),a=this.surface.isWebMercator,c=a&&r===l.PatchType.HAS_NORTH_POLE,h=a&&r===l.PatchType.HAS_SOUTH_POLE,d=h||c,p=Math.PI/2,f=e[0],m=e[2],g=h?-p:e[1],x=c?p:e[3],_=.5*(f+m),v=n,T=t+(d?Math.min(0,v-1):v),M=(e,t,i)=>b(e,t,i,T),S=s.create(),P=s.create(),y=s.create(),E=s.create();M(S,f,g),M(P,f,x),M(y,m,x),M(E,m,g);const C=(e,t)=>{for(let i=0;i<3;++i)this._convexHull[3*t+i]=e[i]};C(S,0),C(P,1),C(y,2),C(E,3);const A=o,I=t+(d?Math.max(0,A+1):A),B=s.create(),L=s.create(),D=s.create();b(L,_,x,T),b(D,_,g,T),i.add(B,L,D),i.normalize(B,B);const H=s.create(),R=s.create(),j=(e,t)=>{i.sub(R,e,t),i.normalize(R,R);const s=-i.dot(e,H)/i.dot(R,H);u.internalAssert(s>=0),i.scale(R,R,s),i.add(e,e,R)};if(2**this.lij[0]>2*this.lij[1]){const e=D,t=s.create();i.cross(t,$,e),i.normalize(t,t),i.cross(H,e,t),i.normalize(H,H),u.internalAssert(u.almostEquals(i.dot(H,e)/i.len(e),0)),j(S,P),j(E,y),C(S,0),C(E,3)}else if(2**this.lij[0]!==2*this.lij[1]){const e=L,t=s.create();i.cross(t,$,e),i.normalize(t,t),i.cross(H,t,e),i.normalize(H,H),j(P,S),j(y,E),C(P,1),C(y,2)}const V=(e,t)=>{const s=I/i.dot(t,B);for(let i=0;i<3;++i)this._convexHull[3*e+i]=t[i]*s};V(4,S),V(5,P),V(6,y),V(7,E)}_getPatchType(){const e=this.lij[1],t=0===e,i=e===(1<<this.level)-1;return t?i?l.PatchType.HAS_BOTH_POLES:l.PatchType.HAS_NORTH_POLE:i?l.PatchType.HAS_SOUTH_POLE:l.PatchType.REGULAR}intersectsRay(e,t,i,s){const n=this._boundingSphere,o=n[3]+i,r=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],a=n[0]-e[0],l=n[1]-e[1],c=n[2]-e[2],h=(a*t[0]+l*t[1]+c*t[2])/r,u=t[0]*h-a,d=t[1]*h-l,p=t[2]*h-c;return u*u+d*d+p*p<o*o}getDefaultVerticesPerSide(){return this.level<m.length?m[this.level]+1:2}updateCornerElevations(){h.updateCornerSpherical(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){h.updateEdgesAndCornersSpherical(this.renderData),this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){h.updateEdgeElevationsAndResolutionsSpherical(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!u.enableTerrainInternalChecks)return;if(this.level<=2)return;const e=this._boundingSphere,t=e[3],n=a.getCenter(e),r=s.create(),l=this.ellipsoid.radius,c=this.elevationBoundsMin,h=this.elevationBoundsMax,f=l+c,m=1,g=0,$=this._center[d.CenterPosition.MIDDLE][3],_=this.convexHull,v=(e,t)=>{for(let i=0;i<3;++i)e[i]=_[3*t+i]};{const e=s.create(),t=s.create(),n=s.create(),o=s.create(),r=s.create(),a=(s,a,l,c)=>{v(t,s),v(n,a),v(o,l),i.sub(t,t,n),i.sub(o,o,n),i.cross(e,t,o),i.normalize(e,e);const h=i.dot(e,n);v(r,c);const d=i.dot(e,r),p=Math.abs(d-h);u.internalAssert(u.almostEquals(p,0),`Non coplanar ${s},${a},${l},${c} diff = ${p}`)};a(0,1,2,3),a(4,5,6,7),a(0,1,4,5),a(1,2,5,6),a(2,3,6,7),a(3,0,7,4)}const T=o.newDoubleArray(24),M=(e,t,i)=>{const s=4*e;for(let n=0;n<3;++n)T[s+n]=t[n];T[s+3]=i},S=s.create(),P=s.create(),y=s.create(),E=s.create(),C=(e,t,s,n)=>{v(S,t),v(P,s),v(y,n),i.sub(S,S,P),i.normalize(S,S),i.sub(y,y,P),i.normalize(y,y),i.cross(E,S,y),i.normalize(E,E);const o=i.dot(E,P);M(e,E,o)};C(0,0,1,2),C(1,1,0,4),C(2,1,5,2),C(3,3,2,6),C(4,4,0,3),C(5,4,6,5);const A=1,I=(e,t,i,s)=>{const n=4*e;return T[n]*t+T[n+1]*i+T[n+2]*s-T[n+3]},B=(e,t,i,s)=>I(e,t,i,s)>=-A,L=(e,t)=>B(e,t[0],t[1],t[2]),D=2**this.lij[0]>2*this.lij[1],H=(e,i,s)=>Math.sqrt(x(e,i,s,n[0],n[1],n[2]))<t,R=e=>H(e[0],e[1],e[2]),j=(e,t)=>H(e[t],e[t+1],e[t+2]),V=this.extentInRadians,O=.5*(V[0]+V[2]),F=V[1],z=V[3],k=s.create(),N=s.create();b(k,O,z,f),b(N,O,F,f);const U=D?"Upper":"Lower";let q=!0;for(let i=0;i<6;++i){for(let e=0;e<8;++e){const t=3*e,s=B(i,_[t],_[t+1],_[t+2]);q&&=s,u.internalAssert(s,`Tile[${this.lij}] Convex hull point ${e} outside of plane ${i}`)}u.internalAssert(L(i,N),`Tile[${this.lij}] (${U}) bottom mid outside of plane ${i}`),u.internalAssert(L(i,k),`Tile[${this.lij}] (${U}) top mid outside of plane ${i}`)}u.internalAssert(q,"Not all convex hull points are inside  convex hull polyhedron"),u.internalAssert(R(N),`Tile[${this.lij}] (${U}) bottom mid outside of bounding sphere`),u.internalAssert(R(k),`Tile[${this.lij}] (${U}) top mid outside of bounding sphere`);for(let i=0;i<8;++i){const e=j(_,3*i);u.internalAssert(e,`Tile[${this.lij}] Convex hull point ${i} outside of bounding sphere`)}for(let i=0;i<6;++i)for(let e=0;e<8;++e){const t=3*e;B(i,_[t],_[t+1],_[t+2])||console.error(`Tile[${this.lij}] Convex hull point ${e} outside of plane ${i}`)}const{extentInRadians:w}=this,G=Math.max(w[2]-w[0],w[3]-w[1]),W=Math.round(G*l),{renderData:J}=this;if(!J)return;const{geometry:K,geometryState:Q,localOrigin:X}=J,Y=K.vertexAttributes?.position;if(!Y)return;const Z=s.create(),ee=K.numVerticesPerSide-2,{indices:te,indexCount:ie,edgeVerticesStartIndex:se,poleVerticesStartIndex:ne}=K;if(!te)return;const oe=new Set;for(let s=0;s<ie;++s){const e=te[s];if(oe.has(e))continue;oe.add(e);const o=e<ne,a=e>=se;let u=!1,d=-1;if(a){let t=se;for(let i=0;i<4;++i){const s=Q.edgeResolutions[i];if(e===t||e===t+s-1){u=!0;break}if(t+=s,e<t){d=i;break}}}const f=a?Q.edgePeerNeighbors[d]:null,x=a&&f&&p.compareTilesByLij(this,f)>0;Y.getVec(e,r),i.add(Z,r,X);const b=i.len(Z)-l;let _=0,v=!1;const T=c-b,M=b-h,S=T>m,P=M>m,y=S||P,E=()=>{const t=o?"internal":a&&!u?"edge":u?"corner":"pole";return`Tile[${this.lij}].vertex[${e}]:${t}`+(S?"(below)":P?"(above)":"")+(x?"(Neighbor)":"")},C=i.dist(Z,n);if(C>=t+g){const e=C-t;y||(console.error(`${E()} is out of the bounding sphere by ${e.toFixed(0)} / ${t.toFixed(0)}[tol=${g}] h=${b.toFixed(0)} / [${c.toFixed(0)}..${h.toFixed(0)}] (${(e/t).toFixed(0)})`),v=!0)}for(let i=0;i<6;++i)if(!B(i,Z[0],Z[1],Z[2])){const s=I(i,Z[0],Z[1],Z[2]),n=e%ee,o=(e-n)/ee;0===i&&T||5===i&&M||(console.error(`${E()} (${n},${o})|${ee}] is out of the bounding trapezoid plane ${i} h=${Math.round(b)} / [${Math.round(c)}..${Math.round(h)}] dist=${Math.round(s)} radii = ${Math.round(t)}/${Math.round($)}} : maxL = ${W}`),++_)}if(v||_>0)break}}get convexHull(){return this._convexHull}}const m=[128,64,64,32,16,8,8,4];function g(e,t,i){return x(e[0],e[1],e[2],t[i],t[i+1],t[i+2])}function x(e,t,i,s,n,o){const r=s-e,a=n-t,l=o-i;return r*r+a*a+l*l}const b=(e,t,i,s)=>{const n=Math.cos(t),o=Math.sin(t),r=Math.cos(i),a=Math.sin(i);e[0]=s*r*n,e[1]=s*r*o,e[2]=s*a},$=[0,0,1],_=s.create(),v=s.create();e.SphericalPatch=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
