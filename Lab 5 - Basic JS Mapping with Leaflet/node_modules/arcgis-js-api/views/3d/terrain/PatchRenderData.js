/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/arrayUtils","../../../core/mathUtils","../../../core/maybe","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/support/aaBoundingRect","../../../geometry/support/Ellipsoid","../support/buffer/glUtil","./GeometryState","./ITile","./LayerClass","./PatchGeometry","./TerrainConst","./terrainUtils","./TextureFader","./Tile","./TileOverlayData","./tileUtils","../webgl-engine/lib/VertexArrayObject","../webgl-engine/shaders/TerrainTechnique","../../webgl/BufferObject","../../webgl/enums"],(function(e,t,r,i,s,n,a,l,o,d,g,h,c,u,m,f,y,p,x,A,_,v,b){"use strict";class E{constructor(){this.geometry=new c.PatchGeometry,this.intersectionData=null,this.geometryState=null,this._vao=null,this._texture=null,this._textureRef=new f.TextureFader((()=>this.tile.surface.fadeDuration)),this.overlay=new p,this._localOrigin=null,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._modifiedFlags=0}get tile(){return this._tile}get localOrigin(){return this._localOrigin}init(e,t){this.clear(),this._tile=e,this.geometry.reset(),this.intersectionData=null,this.geometryState=new d.GeometryState,this._localOrigin=t,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this.wireframeChanged||this.clippingAreaChanged||this.samplerDataChanged||this.numVerticesPerSideChanged||this.dirtyCorners||this.dirtyEdgeResolutions||this.dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),m.enableTerrainInternalChecks&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)m.internalAssert(this.geometry.getEdgeCount(t)===this.geometryState.edgeResolutions[t]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,n=m.neighborEdgeIndices[e];if(!t)return m.internalAssert(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(n)),i;if(t.isLoaded){const r=t,n=r.renderData.geometryState,a=s-r.level;if(m.internalAssert(a>=0),0===a){const e=n.numVerticesPerSide-1;return Math.max(e,i)}const l=2**a,o=n.edgeResolutions[(e+2)%4]/l;return Math.max(1,o)}m.internalAssert(!t.isLeaf);let a=i;return t.forAllSubtreeOnSide(m.oppositeEdge(n),(e=>e===r||(e.isLoaded?(a=Math.max(a,2**(e.level-s)),!0):(m.internalAssert(!e.isLeaf),!1)))),a}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const t=e.renderData.geometryState,i=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=t.edgePeerNeighbors,n=t.edgePeerNeighborSamplerVersions;for(let a=0;a<4;++a){const l=e.findNeighborTile(m.neighborEdgeIndices[a],i),o=I(e,l),d=o?.renderData?.geometryState.samplerDataVersion??-1,g=s[a],h=o!==I(e,g),c=n[a]!==d;m.enableTerrainInternalChecks&&l&&(m.internalAssert(e.level>=l.level),m.internalAssert(e.level-l.level<=u.maxTileNeighborLevelDelta)),s[a]=l,(h||c)&&(n[a]=d,this._markEdgeDirty(a));const f=t.edgeResolutions[a],y=this._calculateEdgeResolution(a,l);m.internalAssert(r.isPowerOfTwo(y)),m.internalAssert(y>=1),t.edgeResolutions[a]=y,f!==y&&this._markEdgeResolutionDirty(a)}for(let r=0;r<4;++r){const n=e.findNeighborTile(m.neighborCornerIndices[r],i);t.cornerPeerNeighbors[r]=n;const a=I(e,s[r]),l=I(e,s[(r+1)%4]),o=I(e,n);R[r]=o,R[(r+1)%4]=l,R[(r+2)%4]=e,R[(r+3)%4]=a,m.internalAssert(R.some((t=>t?.isLoaded||t===e)));const d=R.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);R.forEach(((e,t)=>{e&&e?.level>d&&(R[t]=null)})),m.internalAssert(R.some((t=>t?.isLoaded||t===e)));const g=t.cornerNeighborCornerTiles,h=t.cornerNeighborCornerTileSamplerVersions;for(let e=0;e<4;++e){const t=R[e],i=t?.renderData.geometryState.samplerDataVersion??-1,s=4*r+e,n=g[s]!==t,a=!n&&h[s]!==i;(n||a)&&(g[s]=t,h[s]=i,this._markCornerDirty(r))}m.enableTerrainInternalChecks&&m.internalAssert(k.some((t=>g[4*r+t]?.isLoaded||g[4*r+t]===e)))}m.enableTerrainInternalChecks&&m.internalAssert(this.geometryState.edgeResolutions.every((e=>e>0)));for(let r=0;r<4;++r)R[r]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;m.enableTerrainInternalChecks&&m.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const{tile:t,_vao:r,geometry:i,geometryState:s}=this,n=!r||!{geometry:i}||this.wireframeChanged||this.samplerDataChanged||this.clippingAreaChanged||this.numVerticesPerSideChanged,a=0!==this.dirtyEdgeResolutions,l=s.edgeResolutions.reduce(((e,t)=>e+t+1),0),o=n||a&&l>(i?.maxEdgeVertexCount??0),d=!o&&a,g=!d&&(0!==this.dirtyEdges||a),h=!g&&0!==this.dirtyCorners;o?(this.releaseGeometry(),this._createGeometry(e)):d?t.updateEdgeElevationsAndResolutions():g||h?t.updateEdgeElevations():h?t.updateCornerElevations():console.warn("Update for no reason?"),this._modifiedFlags=0}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao=i.disposeMaybe(this._vao),this.geometry.release(),!0)}ensureTexture(e,t,r){const i=t?b.PixelFormat.RGBA:b.PixelFormat.RGB;return null==this._texture||this._texture.descriptor.width===e&&this._texture.descriptor.pixelFormat===i||this.releaseTexture(),null==this._texture&&(this._texture=r(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){null!=this._texture&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}get numVerticesPerSideChanged(){return 0!=(this._modifiedFlags&N)}get samplerDataChanged(){return 0!=(this._modifiedFlags&P)}get clippingAreaChanged(){return 0!=(this._modifiedFlags&w)}get wireframeChanged(){return 0!=(this._modifiedFlags&O)}get dirtyEdges(){return this._modifiedFlags>>F&15}get dirtyCorners(){return this._modifiedFlags>>G&15}get dirtyEdgeResolutions(){return this._modifiedFlags>>j&15}_markCornerDirty(e){const t=1<<e<<G;this._modifiedFlags|=t}_markEdgeDirty(e){const t=1<<e<<F;this._modifiedFlags|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e<<j;this._modifiedFlags|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._modifiedFlags|=15<<G|15<<F|15<<j}updateGeometryState(){const e=this._getElevationInfo(),r=this.tile,i=e.samplerData?r.getElevationVerticesPerSide(e.maxTileLevel):r.getDefaultVerticesPerSide(),s=Math.max(i,5);let n=r.clippingArea;r.intersectsClippingArea&&!r.isWithinClippingArea||(n=null);const a=this.geometryState;let l=!1;a.numVerticesPerSide!==s&&(this._modifiedFlags|=1,a.numVerticesPerSide=s,a.samplerDataVersion++,l=!0),e.changed&&(this._modifiedFlags|=2,a.samplerData=e.samplerData,a.samplerDataVersion++,l=!0),t.equals(a.clippingArea,n)||(this._modifiedFlags=4,a.clippingArea=n,l=!0);const o=r.surface.wireframe;return a.wireframe!==o&&(this._modifiedFlags=8,a.wireframe=o,l=!0),this._geometryStateChangedSinceLastUpdate||=l,l&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const t=this.geometry.vertexAttributes,r=this.geometry.indices,i=e.gl;this._vao=new A.VertexArrayObject(e,_.terrainVertexAttributeLocations,{geometry:o.glLayout(t.layout)},{geometry:v.BufferObject.createVertex(e,i.STATIC_DRAW,t.buffer)},v.BufferObject.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=f.ActivationTime.Immediate){null!=e&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[h.LayerClass.ELEVATION],r=t.length,i=new Array(r);let s=0,n=0,a=!1;for(let d=0;d<r;d++){const r=t[d];if(null!=r.upsampleInfo){const t=r.upsampleInfo.tile,l=t.layerInfo[h.LayerClass.ELEVATION][d].data,o=l&&l.samplerData;e&&e[s]===o||(a=!0),i[s++]=o,n=Math.max(n,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(d,h.LayerClass.ELEVATION);if(x.fallsWithinLayer(this.tile,t.layer,!1)){const t=r.data;e&&e[s]===t.samplerData||(a=!0),i[s++]=t.samplerData,n=this.tile.level}}}null!=e&&e.length!==s&&(a=!0);const l=s>0,o=l?i:null;return l&&(i.length=s),{changed:a,samplerData:o,maxTileLevel:n}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){return{hasTexture:null!=this._texture}}checkGeometryWaterproofness(){if(!m.enableTerrainInternalChecks)return;const e=this.tile;if(!e.isLoaded||!e.intersectsClippingArea||0===e.level)return void m.internalAssert(e?.isLoaded);const t=e.surface.extent;if(null!=t&&!e.intersectsExtent(t))return;const i=m.neighborEdgeIndices.map(((r,i)=>null!=t&&(i<2?-1:1)*(e.extent[3-i]-t[3-i])<0)),o=e.level;m.internalAssert(0===this.dirtyCorners),m.internalAssert(0===this.dirtyEdges),m.internalAssert(0===this.dirtyEdgeResolutions),m.internalAssert(!this.numVerticesPerSideChanged),m.internalAssert(!this.samplerDataChanged),m.internalAssert(!this.clippingAreaChanged),m.internalAssert(!this.wireframeChanged);const d=m.neighborCornerIndices.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),h=this.geometryState;for(let r=0;r<4;++r){const t=h.cornerPeerNeighbors[r],i=d[r];m.internalAssert(i===t,`Tile[${e.lij}].corner[${r}] out of date: cur=[${t?.lij}] exp=[${i?.lij}]`)}m.neighborEdgeIndices.forEach(((t,d)=>{if(i[d])return;const h=e.findNeighborTile(t,(e=>(e.level===o||e?.isLoaded)&&e?.intersectsClippingArea));if(!h){const r=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(t);return void m.internalAssert(!r)}m.internalAssert(h.isLoaded||h.level===e.level),m.internalAssert(h===this.geometryState.edgePeerNeighbors[d]);const c=o-h.level;if(!h.isLoaded)return m.internalAssert(!h.isLeaf),void m.internalAssert(0===c);const u=h.renderData;m.internalAssert(y.isEdgeNeighbor(e,h,t)),m.internalAssert(c>=0);const f=2**c;if(c<0)return void m.internalAssert(!1);const p=e.renderData,x=p.geometry,A=p.localOrigin,_=x.getEdgeCount(d),v=x.numVerticesPerSide-1,b=u.geometry;if(!b)return void m.internalAssert(!1);const E=u.localOrigin,R=this.geometryState.edgePeerNeighbors[d];if(R?.isLoaded){const e=R.renderData;m.internalAssert(p.geometryState.edgePeerNeighborSamplerVersions[d]===e.geometryState.samplerDataVersion),m.internalAssert(this.geometryState.edgePeerNeighborSamplerVersions[d]===e.geometryState.samplerDataVersion)}const I=(d+2)%4,N=b.getEdgeCount(I),P=_-1,w=N-1;m.internalAssert(P*f===w,`Tile[${e.lij}]:e${d},res=${P} edgeRes mismatch with Neighbor[${h.lij}]:e${I},res=${w} (expected:${P*f})`);const O=e.extent,F=t===g.NeighborIndex.NORTH||t===g.NeighborIndex.SOUTH,G=N-1,j=G>>c,k=_-1;if(j<1)return void m.internalAssert(1===k);m.internalAssert(j===k),m.internalAssert(r.isPowerOfTwo(j));const M=b.numVerticesPerSide-1;m.internalAssert(c>0||j===Math.max(M,v));const U=e.getNeighborEdgeStartVertexIndex(d,h);m.internalAssert(0<=U&&U<f);const B=U*j;m.internalAssert(0<=B&&B<=G-j);let X=0,W=B;x.getEdgeVertexPosition(d,C,A,0),x.getEdgeVertexPosition(d,S,A,_-1);const H=s.distance(C,S),q=Math.max(V,1e-4*H);for(let r=0;r<=j;++r){x.getEdgeVertexPosition(d,C,A,X),b.getEdgeVertexPosition(I,S,E,W);const i=r/j,o=F?O[0]+i*(O[2]-O[0]):t===g.NeighborIndex.WEST?O[0]:O[2],c=F?t===g.NeighborIndex.SOUTH?O[1]:O[3]:O[1]+i*(O[3]-O[1]),f=e.surface.extent;if(null==f||a.containsXY(f,o,c)){const t=s.dist(C,S),r=s.len(C)-l.earth.radius,i=s.len(S)-l.earth.radius,a=t<q;if(!a){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${d}[${X}/${_}] and [${h.lij}].edge${I}[${W}/${N}]`),null!=f&&console.warn("  surface extent= ",f," x,y=",o,",",c);const l=n.create();s.subtract(l,p.localOrigin,u.localOrigin),s.len(l)>0&&console.warn(`   localOrigins: ${p.localOrigin} vs ${u.localOrigin} d=${s.len(l)} [${l}]`);(()=>{const t=n.clone(C),r=n.clone(S);e.updateEdgeElevations(),h.updateEdgeElevations(),x.getEdgeVertexPosition(d,C,A,X),b.getEdgeVertexPosition(I,S,E,W);const i=n.create();s.sub(i,C,t),s.len(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${C} d=${s.len(i)} [${i}]`),s.sub(i,S,r),s.len(i)>0&&console.warn(`  XXX Neighbor[${h.lij}] edge out of date: ${r} vs ${S} d=${s.len(i)} [${i}]`)})();const g=x.getEdgeCount(d),y=b.getEdgeCount(N);m.internalAssert(a,`Mismatch in tile [${e.lij}].edge[${d}][${X}/${g}] vs neighbor [${h.lij}].edge[${I}][${W}/${y}] ${m.v32s(C)} vs ${m.v32s(S)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}x.getEdgeNormal(d,T,X),b.getEdgeNormal(I,$,W),s.normalize(D,T),s.normalize(L,$);const g=s.dot(D,L),y=1-g<.01||!1||e===h;if(!y){const t=n.create();s.sub(t,T,$);const r=()=>`Mismatch in tile edge normal ${m.lij2s(e.lij)} (${X}/${_-1}) edge ${d} vs neighbor ${m.lij2s(h.lij)}  (${W}/${N-1}) nedge ${I} :${m.v32s(T)} vs ${m.v32s($)}  dot = ${g} : ${m.v32s(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),h.updateEdgeElevations();const t=n.create(),r=n.create();x.getEdgeNormal(d,t,X),b.getEdgeNormal(I,r,W),s.equals(T,t)||console.warn("Missing update in tile normal: ",m.v32s(T)," => ",m.v32s(t)),s.equals($,r)||console.warn("Missing update in neighbor normal: ",m.v32s($)," => ",m.v32s(r))}m.internalAssert(y,r())}}X+=1,W+=1}}))}}const C=n.create(),S=n.create(),T=n.create(),$=n.create(),D=n.create(),L=n.create(),V=1,R=[null,null,null,null];function I(e,t){return t?.isLoaded||t===e?t:null}const N=1,P=2,w=4,O=8,F=4,G=8,j=12,k=[0,1,2,3];Object.defineProperty(e,"ActivationTime",{enumerable:!0,get:()=>f.ActivationTime}),e.PatchRenderData=E,e.neighborTileIfLoadedOrSelf=I,e.zeroToFour=k,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
