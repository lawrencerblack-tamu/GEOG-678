/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/mathUtils","../../../core/maybe","../../../core/ObjectPool","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../core/libs/gl-matrix-2/math/common","../../../geometry/ellipsoidUtils","../../../geometry/support/aaBoundingRect","../../../chunks/sphere","../../../layers/support/layerUtils","../../2d/engine/vectorTiles/VectorTile","../support/StreamDataLoader","./ElevationBounds","./ElevationTileAgent","./interfaces","./ITile","./LayerClass","./MapTileAgent","./RasterTile","./TerrainConst","./terrainUtils","./TileAgent","./TilePerLayerInfo","./TileTexture","./TileUpdate","./tileUtils"],(function(e,t,i,s,n,r,a,l,o,h,d,u,c,g,p,f,_,y,T,m,A,E,M,I,v,L,D){"use strict";const x=.1;class C{constructor(){this._lij=[0,0,0],this._children=[null,null,null,null],this._pendingUpdates=0,this.renderData=null,this._dirty=!0,this._previouslyRendered=!1,this.extent=o.create(),this._elevationBoundsMin=NaN,this._elevationBoundsMax=0,this.layerInfo=[[],[]],this.extentInRadians=o.create(),this.centerAtSeaLevel=r.create(),this._center=[r.create(),h.create(),r.create()],this.up=r.unitZ(),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._maxTesselation=0,this._usedMemory=null,this._mapTileMemoryInternal=0,this._mapDataRefCount=0,this.screenDepth=0,this.renderOrder=0,this._edgeLen=0,this._edgeLen2=0,this._curvatureHeight=0,this.extentMidX=0,this.extentMidY=0,this.distanceToPOI=-1,this._lastPOI=r.create(),this.maxLevelDeltaNeighborCount=0,this.unmergableChildCount=0}get lij(){return this._lij}static prune(){U.prune(0),S.prune(0),I.TilePerLayerInfo.prune()}get _isCached(){return!this.isLeaf&&this._mapDataRefCount<=0}get maxTesselation(){return this._maxTesselation}get isWithinClippingArea(){return this._isWithinClippingArea}get intersectsClippingArea(){return this._intersectsClippingArea}get clippingArea(){return this._clippingArea}get parent(){return this._parent}get children(){return this._children}get surface(){return this._surface}get elevationBoundsMin(){return this._elevationBoundsMin}get elevationBoundsMax(){return this._elevationBoundsMax}get level(){return this._lij[0]}get key(){return`${this._lij[0]}/${this._lij[1]}/${this._lij[2]}`}get edgeLen(){return this._edgeLen}get radius(){return this._center[e.CenterPosition.MIDDLE][3]}get visible(){return this._dirty&&this.computeVisibility(),this._visible}get frustumVisibility(){return this._dirty&&this.computeVisibility(),this._frustumVisibility}computeVisibility(){this._dirty=!1;const e=this.parent,t=e?.frustumVisibility??_.TileFrustumVisibility.INTERSECTS;this._frustumVisibility=t===_.TileFrustumVisibility.INSIDE?_.TileFrustumVisibility.INSIDE:t===_.TileFrustumVisibility.OUTSIDE?_.TileFrustumVisibility.OUTSIDE:this._calculateFrustumVisibilityStatus(this.surface.frustum);const i=this._frustumVisibility!==_.TileFrustumVisibility.OUTSIDE&&this._intersectsClippingArea;i!==this._visible&&(this._visible=i,this._surface.emit("tiles-visibility-changed"),this._surface.renderer.setDirty(),this.updateAgentSuspension())}get loadable(){return this.visible||this._surface.view.state.fixedContentCamera}get rendered(){const e=!!this.renderData;return e!==this._previouslyRendered&&(this._surface.emit("tiles-visibility-changed"),this._previouslyRendered=e,this._surface.renderer.setDirty()),e}init(t,i,s,n,r){this._lij[0]=t,this._lij[1]=i,this._lij[2]=s,this.ellipsoid=l.getReferenceEllipsoid(r.tilingScheme.spatialReference),r.tilingScheme.getExtent(t,i,s,this.extent),r.tilingScheme.convertExtentToRadians(this.extent,this.extentInRadians),this.extentMidX=.5*(this.extent[0]+this.extent[2]),this.extentMidY=.5*(this.extent[1]+this.extent[3]),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._clippingArea=null,this._mapDataRefCount=0,r.upsampleMapCache.pop(this.key),this._edgeLen=0,this._edgeLen2=0,this._center[e.CenterPosition.MIDDLE][3]=0,this.elevationLevel=t,n&&!Number.isNaN(n.elevationBoundsMin)?(this._elevationBoundsMin=n.elevationBoundsMin,this._elevationBoundsMax=n.elevationBoundsMax):(this._elevationBoundsMin=0,this._elevationBoundsMax=0),this._pendingUpdates=0,this.renderData=null,this.screenDepth=0,this._visible=!1,this._previouslyRendered=!1,this._parent=n,this.unsetChildren(),this._surface=r,this.updateVisibility(),this.maxLevelDeltaNeighborCount=0,this.unmergableChildCount=0;for(const e of y.LayerClasses){const t=r.numLayers(e),i=this.layerInfo[e];for(const e of i)e.release();i.length=t;for(let s=0;s<t;s++)i[s]=I.TilePerLayerInfo.acquire(this._surface.upsampleInfoPool),e===y.LayerClass.ELEVATION&&this.findElevationBoundsForLayer(s,-1)}this.computeElevationBounds(),this._maxTesselation=Math.min(r.tilingScheme.pixelSize,A.maxPatchTesselation)}dispose(){E.weakAssert(!this.renderData,"tile.renderData was not unloaded"),this._surface.upsampleMapCache.pop(this.key);for(const e of y.LayerClasses){for(const t of this.layerInfo[e])t.release();this.layerInfo[e].length=0}this._parent=null;for(let e=0;e<4;++e)this._children[e]=null;this._surface=null,this.setMemoryDirty()}refMapData(){++this._mapDataRefCount,this._isCached||this._surface.upsampleMapCache.pop(this.key)}unrefMapData(){if(--this._mapDataRefCount,this._isCached){this.setMemoryDirty();const e=this._cachedMemory;e>0&&this._surface.upsampleMapCache.put(this.key,this,e)}}setMemoryDirty(){this._usedMemory=null}get usedMemory(){return this._ensureUsedMemory()+(this._isCached?0:this._mapTileMemoryInternal)}get _cachedMemory(){return this._isCached?this._mapTileMemory:0}get _mapTileMemory(){return this._ensureUsedMemory(),this.layerInfo[y.LayerClass.MAP].reduce(((e,t)=>e+(t instanceof u.VectorTile?t.usedMemory/t.referenced:0)),this._mapTileMemoryInternal)}get _cpuImageMemorySize(){const e=4,t=this._surface.tilingScheme.pixelSize;return t*t*e}_ensureUsedMemory(){if(null!=this._usedMemory)return this._usedMemory;this._usedMemory=this._baseUsedMemory,this._mapTileMemoryInternal=0;let e=0;for(const{data:i}of this.layerInfo[y.LayerClass.MAP])i instanceof u.VectorTile?e+=this._getTerrainDataMemory(i):this._mapTileMemoryInternal+=this._getTerrainDataMemory(i);const t=this._cpuImageMemorySize;for(const i of this.layerInfo[y.LayerClass.ELEVATION])this._usedMemory+=i.data?t:0;return this.renderData&&(this._usedMemory+=this.renderData.estimatedGeometryMemoryUsage,this._mapTileMemoryInternal+=this.renderData.texture?.usedMemory??0),this._isCached&&this._surface.upsampleMapCache.updateSize(this.key,this,this._mapTileMemoryInternal+e),this._usedMemory}getUsedMemoryForLayer(e,t){const i=this.layerInfo[e][t];return i?.data?e===y.LayerClass.MAP?this._isCached?0:this._getTerrainDataMemory(i.data):e===y.LayerClass.ELEVATION?this._cpuImageMemorySize:0:0}_getTerrainDataMemory(e){return e instanceof v?e.texture.usedMemory:e instanceof HTMLImageElement||e instanceof c.ImageWithType?this._cpuImageMemorySize:e instanceof m.RasterTile?e.memoryUsage:e instanceof u.VectorTile?e.usedMemory/e.referenced:0}updateScreenDepth(t){const i=this._center[e.CenterPosition.MIDDLE],s=t,n=i[0],r=i[1],a=i[2],l=s[2]*n+s[6]*r+s[10]*a+s[14];this.screenDepth=l<0?0:l/(s[3]*n+s[7]*r+s[11]*a+s[15])}shouldSplit(t,i,s){if(!this.visible)return L.TileUpdate.NONE;if(t.frustum&&(!this._intersectsClippingArea||this._calculateFrustumVisibilityStatus(t.frustum)===_.TileFrustumVisibility.OUTSIDE))return L.TileUpdate.NONE;const r=this.level;n.subtract(w,h.getCenter(this._center[e.CenterPosition.MIDDLE]),i);let a=n.squaredLength(w),l=w,o=h.getCenter(this._center[e.CenterPosition.MIDDLE]);n.subtract(G,this._center[e.CenterPosition.TOP],i);const d=n.squaredLength(G);d<a&&(a=d,l=G,o=this._center[e.CenterPosition.TOP]),n.subtract(F,this._center[e.CenterPosition.BOTTOM],i);const u=n.squaredLength(F);if(u<a&&(a=u,l=F,o=this._center[e.CenterPosition.BOTTOM]),this._edgeLen2>a&&r<t.maxLod)return L.TileUpdate.SPLIT;const c=Math.sqrt(a),g=t.fovX*c*2,p=this._edgeLen/g,f=()=>{if(r<t.maxLod)return this.elevationLevel=r,L.TileUpdate.NONE;const e=r+Math.ceil(-Math.log2(t.relativeWidthLimit/p));return e!==this.elevationLevel?(this.elevationLevel=e,L.TileUpdate.ELEVATION):L.TileUpdate.NONE},y=null!=s?s-r:1/0;if(y<=.5)return f();const T=n.dot(this.up,w),m=this._elevationBoundsMax-this._elevationBoundsMin,A=m/this.edgeLen;if(t.aboveGround&&T>0&&A<.001){if(T/c-Math.sin(this._curvatureHeight/(this.edgeLen*Math.SQRT1_2)*Math.PI)-A>0)return L.TileUpdate.NONE}const E=null!=s?3-Math.min(y,2):1;if(p*E<t.relativeWidthLimit||r>=t.maxLod)return f();if(r<7)return L.TileUpdate.SPLIT;n.scale(H,this.up,T),n.subtract(H,H,l);const M=n.squaredLength(H);if(M<=this.radius*this.radius)return L.TileUpdate.SPLIT;n.scale(H,H,this.radius/Math.sqrt(M)),n.add(H,H,o),n.subtract(H,i,H);const I=Math.min(1,(Math.abs(n.dot(H,this.up))+.5*m+this._curvatureHeight)/n.length(H)),v=x/t.angledSplitBias,D=t.fovY*c*2;return I*(this._edgeLen/D*E)<v*t.relativeHeightLimit?L.TileUpdate.NONE:L.TileUpdate.SPLIT}setChildren(e,t,i,s){E.weakAssert(!!(e&&t&&i&&s),"Null child passed");const n=this._children;return n[0]=e,n[1]=t,n[2]=i,n[3]=s,n}unsetChildren(){this._children[0]=null,this._children[1]=null,this._children[2]=null,this._children[3]=null}get isLoaded(){return this.renderData?.hasGeometry??!1}load(){this.refMapData();for(const e of y.LayerClasses)this._createOrUpdateAgents(0,e);this.surface.renderer.loadTile(this)}unload(e){e.unloadTile(this);for(const t of y.LayerClasses){const e=this.layerInfo[t];for(const t of e)t.loadingAgent&&t.loadingAgent!==M.tileAgentDone&&(N(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0}this.resetPendingUpdate(L.TileUpdate.GEOMETRY),this.resetPendingUpdate(L.TileUpdate.TEXTURE_NOFADING),this.resetPendingUpdate(L.TileUpdate.TEXTURE_FADING),this.unrefMapData()}unloadMapData(){const e=this.layerInfo[y.LayerClass.MAP];for(const t of e)t.loadingAgent&&t.loadingAgent!==M.tileAgentDone&&(N(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0;this.renderData&&this.renderData.releaseTexture(),this.setMemoryDirty()}updateClippingStatus(e){if(o.equals(e,this._clippingArea))return!1;const t=this._intersectsClippingArea,i=this._isWithinClippingArea;null!=e?(this._intersectsClippingArea=this.intersectsExtent(e),this._isWithinClippingArea=this._isWithinExtent(e)):(this._intersectsClippingArea=!0,this._isWithinClippingArea=!0),this._clippingArea=e,this.updateVisibility();const s=i&&this._isWithinClippingArea,n=!(i||t||this._isWithinClippingArea||this._intersectsClippingArea);return!this.renderData||s||n||this.setPendingUpdate(L.TileUpdate.GEOMETRY),!0}updateVisibility(){this._dirty=!0,this._surface.setTileTreeDirty()}getLayerInfo(e,t){return this.layerInfo[t][e]}hasLayerData(e,t){const i=this.layerInfo[t][e];return!(!i?.data||i.dataInvalidated)}get updating(){if(this.hasPendingUpdates)return!0;for(const e of y.LayerClasses){const t=this.layerInfo[e];for(const e of t)if(e.loadingAgent&&e.loadingAgent!==M.tileAgentDone&&e.loadingAgent.updating)return!0}return!1}_isSuspended(e){return!!this.hasPendingUpdate(L.TileUpdate.SPLIT)||e!==y.LayerClass.ELEVATION&&!this.loadable}get hasPendingUpdates(){return 0!==this._pendingUpdates}hasPendingUpdate(e){return(this._pendingUpdates&e)===e}setPendingUpdate(e){const t=this._pendingUpdates;return this._pendingUpdates|=e,e===L.TileUpdate.SPLIT||e===L.TileUpdate.MERGE?this._surface.setTileTreeDirty():this._surface.requestUpdate(),t!==this._pendingUpdates}resetPendingUpdate(e){return!!this.hasPendingUpdate(e)&&(this._pendingUpdates&=~e,!0)}requestLayerData(e,t,s){const n=this.layerInfo[t][e];if(n.waitingAgents.has(s))return console.warn("agent already requested this piece of map data (tile %s, agent tile %s, layer: %d/%d)",this._lij.toString(),s.tile.lij.toString(),t,e),!0;if(n.waitingAgents.push(s),n.data&&!n.dataInvalidated){console.warn("agent requested existing data (tile %s, agent tile %s, layer: %d/%d)",this._lij.toString(),s.tile.lij.toString(),t,e);const i=n.data&&"type"in n.data&&"vector-tile"===n.data.type;return s.dataArrived(this,i),!0}if(n.requestPromise)return!0;i.abortMaybe(n.requestAbort),n.requestAbort=new AbortController;const r=this._surface.requestTileData(this,e,t,n.requestAbort);if(!r)return n.requestAbort=null,!1;const a=()=>{n.requestPromise===r&&(n.requestPromise=null,n.requestAbort=null)};return n.requestPromise=r,r.then(a,a),!0}get isLeaf(){return null==this._children[0]}hasLij(e){return this._lij[0]===e[0]&&this._lij[1]===e[1]&&this._lij[2]===e[2]}findByLij(e){if(this.hasLij(e))return this;const t=this._children;if(!t[0])return null;return t[0].findByLij(e)||t[1].findByLij(e)||t[2].findByLij(e)||t[3].findByLij(e)}distanceToSquared(t){return n.squaredLength(n.subtract(H,h.getCenter(this._center[e.CenterPosition.MIDDLE]),t))}containsPoint(e){const t=this.extent;return e[0]>=t[0]&&e[1]>=t[1]&&e[0]<=t[2]&&e[1]<=t[3]}containsPointXY(e,t){const i=this.extent;return e>=i[0]&&t>=i[1]&&e<=i[2]&&t<=i[3]}unrequestLayerData(e,t,i){const s=this.layerInfo[t][e],n=s.waitingAgents,r=null!=n.removeUnordered(i);E.weakAssert(r,"agent has not requested this piece of map data"),n.length<1&&(s.abortRequest(),this.setMemoryDirty())}dataArrived(e,t,i){const s=null!=i&&"type"in i&&"vector-tile"===i.type,n=this.layerInfo[t][e];n.data=i,n.dataInvalidated=!1,n.waitingAgents.forAll((e=>e.dataArrived(this,s))),n.waitingAgents.clear(),this.setMemoryDirty()}dataMissing(e,t,i){i.notInTilemap||console.error(`Tile ${this._lij.toString()} layer ${t}/${e} error ${i}`);const s=this.layerInfo[t][e];s.dataMissing=!0,s.waitingAgents.forAll((e=>e.dataMissing())),s.waitingAgents.clear(),this.setMemoryDirty()}updateRenderData(e,t,i){switch(i&&this.forEachLoadedNeighbor((i=>i.updateRenderData(e,t))),e){case y.LayerClass.MAP:return this._updateTexture(t);case y.LayerClass.ELEVATION:return this._updateGeometry()}}_updateTexture(e){this.renderData&&(this.resetPendingUpdate(e===f.TextureUpdate.FADING?L.TileUpdate.TEXTURE_NOFADING:L.TileUpdate.TEXTURE_FADING),this.setPendingUpdate(e===f.TextureUpdate.FADING?L.TileUpdate.TEXTURE_FADING:L.TileUpdate.TEXTURE_NOFADING))}_updateGeometry(){this.setPendingUpdate(L.TileUpdate.GEOMETRY);for(const e of this.layerInfo[y.LayerClass.ELEVATION])e.pendingUpdates|=L.TileUpdate.GEOMETRY}invalidateLayerData(e,t){this.layerInfo[t][e].invalidateSourceData(),this.restartAgents(t)}computeElevationBounds(){const e=this._elevationBoundsMin,t=this._elevationBoundsMax;let i=1/0,s=-1/0;const n=this.layerInfo[y.LayerClass.ELEVATION];let r=!0;for(const a of n)null!=a.elevationBounds&&(i=Math.min(i,a.elevationBounds.min),s=Math.max(s,a.elevationBounds.max),a.elevationBounds.hasNoDataValues||(r=!1));r&&(i=Math.min(i,0),s=Math.max(s,0)),e===i&&t===s||(this._elevationBoundsMin=i,this._elevationBoundsMax=s,this.updateRadiusAndCenter(),this._surface.setTileTreeDirty())}_updateCenter(){const t=this._elevationBoundsMin,i=this._elevationBoundsMax,s=.5*(t+i),r=this._center;n.scale(H,this.up,s),n.add(h.getCenter(r[e.CenterPosition.MIDDLE]),this.centerAtSeaLevel,H),n.scale(H,this.up,t),n.add(r[e.CenterPosition.TOP],this.centerAtSeaLevel,H),n.scale(H,this.up,i),n.add(r[e.CenterPosition.BOTTOM],this.centerAtSeaLevel,H)}findElevationBoundsForLayer(e,t){const i=this.layerInfo[y.LayerClass.ELEVATION][e],s=A.getElevationDesiredResolutionLevel(this.level),n=Math.max(this.elevationLevel-s,0),r=i.elevationBounds;if(null!=r&&r.level>=t&&r.level<=n)return;const a=this._surface.layerViewByIndex(e,y.LayerClass.ELEVATION),l=E.getLayerWithExtentRange(a);if(!D.fallsWithinLayer(this,l,!1))return;const o=O;let h=!1;const d=i.data;if(d&&d.level<=n){const e=i.data;o.min=e.samplerData.data.minValue,o.max=e.samplerData.data.maxValue,o.hasNoDataValues=e.samplerData.data.hasNoDataValues,o.level=this.level,h=!0}else{let t,i,r=0;for(let a=this._parent;a&&(!i||r<s)&&(r=this.elevationLevel-a.level,t=i||t,i=a.layerInfo[y.LayerClass.ELEVATION][e].data,!(!i&&t&&a.level<=n));a=a.parent);i=i||t,i&&(i.computeMinMaxValue(this._lij[0],this._lij[1],this._lij[2],o),o.min!==1/0&&(o.level=i.level,h=!0))}h&&(null==i.elevationBounds&&(i.elevationBounds=new g.ElevationBounds),i.elevationBounds.copyFrom(o))}modifyLayers(e,t,i){const s=this.layerInfo[i];for(const a of s)a.loadingAgent&&a.loadingAgent!==M.tileAgentDone&&(N(a.loadingAgent),a.loadingAgent=null),a.waitingAgents.clear();for(let a=0;a<s.length;++a)void 0===e[a]&&s[a].release();const n=new Array(...s),r=t.length;s.length=r;for(let a=0;a<r;a++){const e=t[a];s[a]=e>-1?n[e]:I.TilePerLayerInfo.acquire(this._surface.upsampleInfoPool)}this.setMemoryDirty()}restartAgents(e){this.renderData&&(this._createOrUpdateAgents(0,e),this.updateRenderData(e,f.TextureUpdate.FADING))}updateAgents(e){if(this.renderData){const t=this.layerInfo[e];for(const e of t)e.loadingAgent===M.tileAgentDone&&(e.loadingAgent=null);this._createOrUpdateAgents(0,e)}}updateAgentSuspension(){for(const e of y.LayerClasses){const t=this._isSuspended(e);for(const i of this.layerInfo[e])i.loadingAgent&&i.loadingAgent!==M.tileAgentDone&&(i.loadingAgent.setSuspension(t),i.loadingAgent===M.tileAgentDone&&this.updateRenderData(e,f.TextureUpdate.FADING))}}removeLayerAgent(e,t){const i=this.layerInfo[t][e];i.loadingAgent&&i.loadingAgent!==M.tileAgentDone&&i.loadingAgent.dispose(),i.loadingAgent=null}agentDone(e,t){const i=this.layerInfo[t][e];i.loadingAgent=M.tileAgentDone,i.data||null!=i.upsampleInfo||this._createOrUpdateAgents(e+1,t)}_hasBlendableAncestor(e){return"normal"!==e.blendMode||d.isGroupLayer(e.parent)&&this._hasBlendableAncestor(e.parent)}_hasBlendModes(e,t,i){for(let s=e;s<t;++s){const e=this._surface.layerViewByIndex(s,i);if(E.isBlendableLayerView(e)&&"normal"!==e?.layer?.blendMode||d.isGroupLayer(e?.layer?.parent)&&this._hasBlendableAncestor(e?.layer?.parent))return!0}return!1}_createOrUpdateAgents(e,t){const i=this.layerInfo[t];if(0===i.length)return;const s=this._isSuspended(t);for(let n=e;n<i.length;++n){const r=i[n];let a=!1;const l=this._surface.layerViewByIndex(n,t),o=E.getLayerWithExtentRange(l);if(r.loadingAgent?D.fallsWithinLayer(this,o,!1)?(r.loadingAgent!==M.tileAgentDone&&r.loadingAgent.setSuspension(s),r.loadingAgent!==M.tileAgentDone&&(a=r.loadingAgent.update())):r.dispose():D.fallsWithinLayer(this,o,!1)&&(r.loadingAgent=b(this,n,t,s),a=r.loadingAgent.startLoading(),a?r.loadingAgent===M.tileAgentDone&&this.setPendingUpdate(L.TileUpdate.GEOMETRY):(N(r.loadingAgent),r.loadingAgent=M.tileAgentDone)),r.loadingAgent===M.tileAgentDone&&this.updateRenderData(t,f.TextureUpdate.FADING),!this._hasBlendModes(e,i.length,t)&&a&&l.isOpaque)return}}_isWithinExtent(e){const t=this.extent;return t[0]>=e[0]&&e[2]>=t[2]&&t[1]>=e[1]&&e[3]>=t[3]}intersectsExtent(e){const t=this.extent;return t[2]>=e[0]&&e[2]>=t[0]&&t[3]>=e[1]&&e[3]>=t[1]}getElevationVerticesPerSide(e){const i=this.elevationLevel-this.level,s=Math.max(this.level-e,A.getElevationDesiredResolutionLevel(this.level)-i),n=t.clamp(1+(this.maxTesselation>>s),2,this.maxTesselation+1),r=this.getDefaultVerticesPerSide();return Math.max(n,r)}get test(){return{cachedMemory:this._cachedMemory}}_findLIJ(e,t){if(!e)return null;const i=this.surface.rootTiles;if(null!=i)for(const s of i)if(B(s,e)){let i=s,n=e[0]-i.level-1;for(;n>=0&&!i.isLeaf&&!t(i);){const t=e[1]>>n&1,s=e[2]>>n&1;i=i.children[2*t+s],n--}return t(i)?i:null}return null}findNeighborTile(e,t){const i=this._lij,s=this.getNeighborLIJ(i,e);return s?V(i,s)?t(this)?this:null:this._findLIJ(s,t):null}findCorner(e,t){const i=e===_.NeighborIndex.NORTH_EAST?1:e===_.NeighborIndex.NORTH_WEST?0:e===_.NeighborIndex.SOUTH_WEST?2:3;let s=this;for(;s.children[0]&&(!t||!t(s));)s=s.children[i];return s}findNeighborCornerTileExact(e,t){return this.findNeighborTile(e,(e=>t(e)||e.level===this.level))?.findCorner(E.oppositeCorner(e),t)||null}forAllSubtreeOnSide(e,t){const i=e===_.NeighborIndex.NORTH?[0,1]:e===_.NeighborIndex.NORTH_EAST?[1]:e===_.NeighborIndex.EAST?[1,3]:e===_.NeighborIndex.SOUTH_EAST?[3]:e===_.NeighborIndex.SOUTH?[2,3]:e===_.NeighborIndex.SOUTH_WEST?[2]:e===_.NeighborIndex.WEST?[0,2]:[0],s=e=>{const n=e.children;!t(e)&&n[0]&&i.forEach((e=>s(n[e])))};s(this)}getNeighborEdgeStartVertexIndex(e,t){if(!t)return 0;const i=this.level-t.level;if(E.internalAssert(!E.enableTerrainInternalChecks||i>=0),0===i)return 0;const s=2**i,n=1==(1&e),r=n?0:1,a=t.lij[r+1]*s,l=this._lij[r+1],o=l-a,h=n?s-1-o:o;return E.enableTerrainInternalChecks&&(E.internalAssert(a<=l&&l<a+s),E.internalAssert(0<=h&&h<s)),h}forEachLoadedNeighbor(e){const t=this.level,i=e=>e.level===t||e.isLoaded;E.neighborEdgeIndices.forEach((t=>{const s=this.findNeighborTile(t,i);null!=s&&s!==this&&s.forAllSubtreeOnSide(E.oppositeEdge(t),(i=>!!i.isLoaded&&(e(i,t),!0)))})),E.neighborCornerIndices.forEach((t=>{const s=this.findNeighborTile(t,i)?.findCorner(E.oppositeCorner(t),(e=>e.isLoaded));E.internalAssert(!s||q(this,s,t)),s?.isLoaded&&e(s,t)}))}getNeighborLIJ(e,t){const i=E.isNorth(t)?-1:E.isSouth(t)?1:0,s=E.isWest(t)?-1:E.isEast(t)?1:0,n=[e[0],e[1]+i,e[2]+s];return n[1]<0?null:this.surface.isGlobal?this.wrapLIJ(n):n[2]<0?null:n}wrapLIJ(e){return!e||e[1]<0||e[1]>=2**e[0]?null:this.surface.wrapEastWest(e)}get westNeighborWestExtent(){return this.extent[0]*(this.isWestEnd?-1:1)}get eastNeighborEastExtent(){return this.extent[2]*(this.isEastEnd?-1:1)}get isEastEnd(){return this._lij[2]===this.surface.lijEastEnd(this.level)-1}get isWestEnd(){return 0===this._lij[2]}get isNorthEnd(){return 0===this._lij[1]}get isSouthEnd(){const e=this.surface.extent,t=e?.[1]??null;return null!=t&&this.extent[1]+a.getEpsilon()>=t}checkGeometryWaterproofness(){E.enableWaterproofnessTests&&(E.internalAssert(this.isLoaded),this.renderData?.checkGeometryWaterproofness())}shouldHaveNeighbor(e){const t=this.extent,i=this.surface.rootTilesExtent,s=.25*(t[2]-t[0]);if(E.isNorth(e)&&t[3]+s>=i[3])return!1;if(E.isSouth(e)&&t[1]-s<=i[1])return!1;const n=this.surface.isGlobal;return!(!n&&E.isWest(e)&&t[0]-s<=i[0])&&!(!n&&E.isEast(e)&&t[2]+s>=i[2])}updateDistanceToPOI(t){const i=this._lastPOI;if(this.distanceToPOI>=0&&i[0]===t[0]&&i[1]===t[1]&&i[2]===t[2])return;n.copy(this._lastPOI,t);const s=this._center[e.CenterPosition.MIDDLE],r=t[0]-s[0],a=t[1]-s[1],l=t[2]-s[2];this.distanceToPOI=r*r+a*a+l*l}}function b(e,t,i,s){const n=i===y.LayerClass.ELEVATION?S.acquire():U.acquire();return n.init(e,t,i,s),n}function N(e){e.dispose(),e instanceof p.ElevationTileAgent?S.release(e):e instanceof T.MapTileAgent&&U.release(e)}const U=new s(T.MapTileAgent),S=new s(p.ElevationTileAgent),O=new g.ElevationBounds;var P;function B(e,t){const i=e.lij,s=t[0]-i[0];return!(s<0)&&(t[1]>>s===i[1]&&t[2]>>s===i[2])}function V(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function R(e,t,i){if(null==e||null==t)return!1;if(0===e.level&&0===t.level){if(e.isEastEnd&&t.isWestEnd&&i===_.NeighborIndex.EAST)return!0;if(e.isWestEnd&&t.isEastEnd&&i===_.NeighborIndex.WEST)return!0}const s=Math.max(1e-6*(e.extent[2]-e.extent[0]),1);switch(i){case _.NeighborIndex.NORTH:return E.almostEquals(e.extent[3],t.extent[1],s);case _.NeighborIndex.SOUTH:return E.almostEquals(e.extent[1],t.extent[3],s);case _.NeighborIndex.EAST:return E.almostEquals(e.extent[2],t.extent[0],s)||E.almostEquals(e.extent[2],-t.extent[0],s);case _.NeighborIndex.WEST:return E.almostEquals(e.extent[0],t.extent[2],s)||E.almostEquals(e.extent[0],-t.extent[2],s)}}function q(e,t,i){return null!=e&&null!=t&&t!==e&&(e.level>=t.level?j(e,t,i):j(t,e,E.oppositeCorner(i)))}function j(e,t,i){E.internalAssert(e.level>=t.level);const s=E.isWestCorner(i),n=E.isNorthCorner(i),r=e.extent,a=t.extent,l=[s?r[0]:r[2],n?r[3]:r[1]],o=[s?a[2]:a[0],n?a[1]:a[3]],h=1e-5*(r[2]-r[0]),d=E.almostEquals(l[0],o[0],h)||e.surface.isGlobal&&E.almostEquals(l[0],-o[0],h),u=E.almostEquals(l[1],o[1],h);if(d&&u)return!0;if(e.level===t.level)return E.internalAssert(!1),!1;if(!d&&!u)return E.internalAssert(!1),!1;const c=d?W(a[1],a[3],r[1],r[3],h):W(a[0],a[2],r[0],r[2],h);return E.internalAssert(c),c}function W(e,t,i,s,n){return e-n<=i&&i<=s&&s<=t+n}e.CenterPosition=void 0,(P=e.CenterPosition||(e.CenterPosition={}))[P.TOP=0]="TOP",P[P.MIDDLE=1]="MIDDLE",P[P.BOTTOM=2]="BOTTOM";const w=r.create(),G=r.create(),F=r.create(),H=r.create();e.Tile=C,e.isCornerNeighbor=q,e.isEdgeNeighbor=R,e.lijEquals=V,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
