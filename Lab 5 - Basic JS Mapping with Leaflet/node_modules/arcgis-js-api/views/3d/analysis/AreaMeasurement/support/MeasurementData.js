/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/mathUtils","../../../../../core/quantityUtils","../../../../../core/libs/gl-matrix-2/math/vec2","../../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../../chunks/vec32","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../../geometry/ellipsoidUtils","../../../../../geometry/projection","../../../../../geometry/SpatialReference","../../../../../geometry/spatialReferenceEllipsoidUtils","../../../../../geometry/projection/projectDirection","../../../../../geometry/projection/projectPointToVector","../../../../../geometry/projection/projectPointToWGS84ComparableLonLat","../../../../../geometry/projection/projectVectorToVector","../../../../../geometry/support/Axis","../../../../../geometry/support/Indices","../../../../../geometry/support/intersectsBase","../../../../../chunks/sphere","../../../../../geometry/support/triangle","../../interfaces","../../support/measurementUtils","../../../support/ElevationProvider","../../../support/mathUtils","../../../../support/euclideanAreaMeasurementUtils"],(function(e,t,s,i,o,r,n,h,a,d,c,l,g,p,m,u,_,C,S,f,L,P,M,R,A,V){"use strict";class j{get numVertices(){return this._length}get hasStagedVertex(){return this._hasCursorPoint}constructor(e,t){this.validMeasurement=!1,this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.areaCentroidWorldCoords=n.create(),this.areaCentroidRenderCoords=n.create(),this.geodesicAreaCentroidRenderCoords=n.create(),this.area=null,this.geodesicArea=null,this.pathLength=null,this.geodesicPathLength=null,this.perimeterLength=null,this._length=0,this._centroidRenderCoords=n.create(),this._planeWorldCoords=h.create(),this._worldUp=n.create(),this._worldTangent=n.create(),this._frame=[n.create(),n.create(),n.create()],this._pathVersion=-1,this._hasCursorPoint=!1,this._mode=null,this._tempU=n.create(),this._tempV=n.create(),this._tempVec3=n.create(),this._tempSphere=f.create(),this._sceneView=e,this.unitNormalizer=t}update(e,t,s,i,o,r){const n=null!=t,h=this._pathVersion===e.version,a=this._hasCursorPoint===n,d=this._mode===o;return!(h&&!r&&a&&d&&e.isValidPolygon)&&(this._pathVersion=e.version,this._hasCursorPoint=n,this._updateCursorSegmentLength(e,t),this._update(e,t,s,i,o),!0)}_update(e,t,i,o,n){const h=this.unitNormalizer,a=this._sceneView.renderSpatialReference,c=this.unitNormalizer.spatialReference;let g=e.numVertices;const u=!(null==t||t.equals(e.lastPoint)||g>2&&t.equals(e.firstPoint));u&&(g+=1);const _=!e.polygonIsClosed&&g>2,C=e.polygonIsClosed||_;this._resize(g);const S=l.getSphericalPCPF(i.spatialReference),f=d.canProjectWithoutEngine(i.spatialReference,S)&&d.canProjectToWGS84ComparableLonLat(i.spatialReference),{positionsGeographic:L,positionsWorldCoords:P,positionsRenderCoords:M,positionsSpherical:R}=this,A=(e,t)=>{W(i.elevationProvider,e),p.projectPointToVector(e,P[t],c),p.projectPointToVector(e,M[t],a),f&&(m.projectPointToWGS84ComparableLonLat(e,L[t]),p.projectPointToVector(e,R[t],S),r.normalize(R[t],R[t]))};e.forEachVertexPosition(((e,t)=>A(e,t))),u&&A(t,g-1);const V=this._updatePathLengths(C);if(this.pathLength=this._length>1?s.createLength(h.normalizeDistance(V),"meters"):null,f){const e=this._updateGeodesicPathLengths(C,c);this.geodesicPathLength=this._length>1?s.createLength(e,"meters"):null}else this.geodesicPathLength=null;if(this._updateMode(n),!C)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),void(this.validMeasurement=!1);this._updateAreaAndPerimeterLength(i,h,a,c,o),f&&this._updateGeodesicArea(i),this.validMeasurement=!0}getData(){return{validMeasurement:this.validMeasurement,numVertices:this.numVertices,hasStagedVertex:this.hasStagedVertex,positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(n.create()),this.positionsRenderCoords.push(n.create()),this.positionsProjectedWorldCoords.push(o.create()),this.positionsFittedRenderCoords.push(n.create()),this.positionsGeographic.push(n.create()),this.positionsSpherical.push(n.create()),this.positionsStereographic.push(o.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const n=s[o]=r.distance(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=n)}return i}_updateGeodesicPathLengths(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let r=0;r<this._length;++r){const n=i[r]=M.segmentLengthGeodesicVector(s[r],s[(r+1)%this._length],t??void 0);(r<this._length-1||e)&&(o+=n)}return o}_updateAreaAndPerimeterLength(e,t,o,n,h){const a=e.renderCoordsHelper,d=this.positionsWorldCoords,c=this.positionsRenderCoords,l=this.positionsProjectedWorldCoords,p=this.positionsFittedRenderCoords,m=this._planeWorldCoords,C=this._centroidRenderCoords;A.midpoint3d(c,C),a.worldUpAtPosition(C,this._worldUp),a.worldBasisAtPosition(C,_.Axis.X,this._worldTangent),g.projectDirection(C,this._worldUp,o,this._worldUp,n),g.projectDirection(C,this._worldTangent,o,this._worldTangent,n),d.length>2&&M.bestFitPlane(d,m),this.fittingMode=this._selectFittingMode(m,d,this._worldUp,h);let S=0;if("horizontal"===this.fittingMode){let e=-1/0;c.forEach(((t,s)=>{const i=a.getAltitude(c[s]);i>e&&(e=i,S=s)}))}const f=d[S];let L=m,P=this._worldTangent;"horizontal"===this.fittingMode?L=this._worldUp:"vertical"===this.fittingMode&&(L=this._tempVec3,P=this._worldUp,A.makeOrthonormal(m,this._worldUp,L)),r.copy(this._frame[2],L),A.makeOrthonormal(P,L,this._frame[0]),r.cross(this._frame[1],this._frame[0],this._frame[2]),r.negate(this._frame[1],this._frame[1]);const R=this._tempVec3,V=this._tempU,j=this._tempV;for(let s=0;s<this._length;++s){const e=l[s],t=p[s];r.subtract(R,d[s],f),i.set(e,r.dot(this._frame[0],R),r.dot(this._frame[1],R)),r.scale(V,this._frame[0],e[0]),r.scale(j,this._frame[1],e[1]),r.add(R,V,j),r.add(R,R,f),u.projectVectorToVector(R,n,t,o)}this.perimeterLength=this._length>0?s.createLength(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,A.midpoint3d(p,this.areaCentroidRenderCoords),u.projectVectorToVector(this.areaCentroidRenderCoords,o,this.areaCentroidWorldCoords,n),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?s.createArea(t.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const{renderCoordsHelper:t,spatialReference:o}=e,{positionsSpherical:n,positionsStereographic:h}=this,d=this._tempVec3,c=M.fitHemisphere(n,d);if(!c)return void(this.geodesicArea=null);const g=this._tempU,p=this._tempV;A.tangentFrame(d,g,p);for(let s=0;s<this._length;++s){const e=r.dot(n[s],g),t=r.dot(n[s],p),o=r.dot(n[s],d);i.set(h[s],e/o,t/o)}r.scale(d,d,a.getReferenceEllipsoid(o).radius),t.toRenderCoords(d,l.getSphericalPCPF(o),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=c&&0===this.geodesicIntersectingSegments.size?s.createArea(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let o=0;o<this._length;++o){s+=t[o]=i.distance(e[o],e[(o+1)%this._length])}return s}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];S.segmentIntersects(o,r,n,h)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=this.triangleIndices=C.compactIndices(V.triangulate(e));let s=0;for(let i=0;i<t.length;i+=3)s+=L.areaPoints2d(e[t[i]],e[t[i+1]],e[t[i+2]]);return s}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];S.segmentIntersects(o,r,n,h)&&(t.add(s),t.add(i))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=this.positionsStereographic,s=this.geodesicTriangleIndices=C.compactIndices(V.triangulate(t));let i=0;for(let o=0;o<s.length;o+=3)i+=M.triangleAreaGeodesic(e[s[o]],e[s[o+1]],e[s[o+2]],c.WGS84);return i}_selectFittingMode(e,s,i,o){const n=s.map((t=>Math.abs(M.planePointDistance(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);M.boundingSphere(s,this._tempSphere);const h=n/(2*this._tempSphere[3]),a=h<o.maxRelativeErrorCoplanar,d=h<o.maxRelativeErrorAlmostCoplanar;let c="horizontal";if(a)c="oblique";else if(d){c=Math.abs(r.dot(i,e))>Math.cos(t.deg2rad(o.verticalAngleThreshold))?"horizontal":"vertical"}return c}_updateCursorSegmentLength(e,t){const i=e.lastPoint;e.isValidPolygon||null==i||null==t?(this.geodesicStagedSegmentLength=null,this.stagedSegmentLength=null):(this.geodesicStagedSegmentLength=s.createLength(M.segmentLengthGeodesic(i,t),"meters"),this.stagedSegmentLength=s.createLength(this.unitNormalizer.normalizeDistance(M.segmentLengthEuclidean(i,t,this.unitNormalizer.spatialReference)),"meters"))}_updateMode(e){if(e===P.MeasurementMode.Auto){this.actualMeasurementMode="euclidean";let e=0;null!=this.geodesicPathLength&&(e+=this.geodesicPathLength.value),e>v&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=e===P.MeasurementMode.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=e}}function W(e,t){t.hasZ||(t.z=R.getElevationAtPoint(e,t,"ground")??0)}const v=1e5;e.MeasurementDataManager=j,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
