/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../core/has","../../../../core/Logger","../../../../core/mathUtils","../../../../core/screenUtils","../../../../core/libs/gl-matrix-2/math/vec2","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../geometry/support/frustum","../../../../geometry/support/lineSegment","../../../../geometry/support/plane","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutput","../lib/GLMaterial","../lib/Material","../lib/RenderSlot","../lib/Util","../lib/VertexAttribute","./VisualVariablePassParameters","../shaders/LineMarkerTechniqueConfiguration","../../../../chunks/RibbonLine.glsl","../shaders/RibbonLineTechnique","../shaders/RibbonLineTechniqueConfiguration"],(function(e,t,r,a,i,s,n,o,c,l,u,d,h,p,T,A,f,m,_,R,b,E,S,O){"use strict";var g;!function(e){e[e.LEFT_JOIN_START=-2]="LEFT_JOIN_START",e[e.LEFT_JOIN_END=-1]="LEFT_JOIN_END",e[e.LEFT_CAP_START=-4]="LEFT_CAP_START",e[e.LEFT_CAP_END=-5]="LEFT_CAP_END",e[e.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",e[e.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",e[e.RIGHT_CAP_START=4]="RIGHT_CAP_START",e[e.RIGHT_CAP_END=5]="RIGHT_CAP_END"}(g||(g={}));class I extends A.Material{constructor(e){super(e,new v),this._configuration=new O.RibbonLineTechniqueConfiguration,this.produces=new Map([[f.RenderSlot.OPAQUE_MATERIAL,e=>e===p.ShaderOutput.Highlight||e===p.ShaderOutput.ObjectAndLayerIdColor||(e===p.ShaderOutput.Color||e===p.ShaderOutput.Alpha)&&this.parameters.renderOccluded===A.RenderOccludedFlag.OccludeAndTransparentStencil],[f.RenderSlot.OPAQUE_NO_SSAO_DEPTH,e=>e===p.ShaderOutput.LinearDepth],[f.RenderSlot.OCCLUDER_MATERIAL,e=>p.isColorAlphaHighlightOIDOrDepth(e)&&this.parameters.renderOccluded===A.RenderOccludedFlag.OccludeAndTransparentStencil],[f.RenderSlot.TRANSPARENT_OCCLUDER_MATERIAL,e=>p.isColorAlphaHighlightOIDOrDepth(e)&&this.parameters.renderOccluded===A.RenderOccludedFlag.OccludeAndTransparentStencil],[f.RenderSlot.TRANSPARENT_MATERIAL,e=>(e===p.ShaderOutput.Color||e===p.ShaderOutput.Alpha)&&this.parameters.writeDepth&&this.parameters.renderOccluded!==A.RenderOccludedFlag.OccludeAndTransparentStencil],[f.RenderSlot.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,e=>(e===p.ShaderOutput.Color||e===p.ShaderOutput.Alpha)&&!this.parameters.writeDepth&&this.parameters.renderOccluded!==A.RenderOccludedFlag.OccludeAndTransparentStencil],[f.RenderSlot.DRAPED_MATERIAL,e=>p.is2DGeometryOutput(e)]]),this._vertexAttributeLocations=S.vertexAttributeLocations}getConfiguration(e,t){this._configuration.output=e,this._configuration.draped=t.slot===f.RenderSlot.DRAPED_MATERIAL;const r=null!=this.parameters.stipplePattern&&e!==p.ShaderOutput.Highlight;return this._configuration.stippleEnabled=r,this._configuration.stippleOffColorEnabled=r&&null!=this.parameters.stippleOffColor,this._configuration.stipplePreferContinuous=r&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins="round"===this.parameters.join,this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=null!=this.parameters.markerParameters&&x(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&null!=this.parameters.innerColor,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===A.RenderOccludedFlag.OccludeAndTransparentStencil,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(e,t,r,i,s,n){if(!r.options.selectionMode)return;const o=e.attributes.get(_.VertexAttribute.POSITION).data,c=e.attributes.get(_.VertexAttribute.SIZE);let l=this.parameters.width;if(this.parameters.vvSize){const t=e.attributes.get(_.VertexAttribute.SIZEFEATUREATTRIBUTE).data[0];l*=a.clamp(this.parameters.vvSize.offset[0]+t*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else c&&(l*=c.data[0]);const u=i[0],d=i[1],h=(l/2+4)*e.screenToWorldRatio;let p=Number.MAX_VALUE,T=0;for(let A=0;A<o.length-5;A+=3){const e=o[A],t=o[A+1],r=u-e,i=d-t,s=o[A+3]-e,n=o[A+4]-t,c=s*r+n*i,l=s*s+n*n,h=a.clamp(c/l,0,1),f=s*h-r,m=n*h-i,_=f*f+m*m;_<p&&(p=_,T=A/3)}p<h*h&&s(n.dist,n.normal,T,!1)}intersect(e,t,i,o,c,h){if(!i.options.selectionMode||!e.visible)return;if(!m.isTranslationMatrix(t))return void r.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const p=e.attributes,T=p.get(_.VertexAttribute.POSITION).data;let A=this.parameters.width;if(this.parameters.vvSize){const e=p.get(_.VertexAttribute.SIZEFEATUREATTRIBUTE).data[0];A*=a.clamp(this.parameters.vvSize.offset[0]+e*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else p.has(_.VertexAttribute.SIZE)&&(A*=p.get(_.VertexAttribute.SIZE).data[0]);const f=i.camera,R=U;s.copy(R,i.point);const b=A*f.pixelRatio/2+4*f.pixelRatio;n.set(Z[0],R[0]-b,R[1]+b,0),n.set(Z[1],R[0]+b,R[1]+b,0),n.set(Z[2],R[0]+b,R[1]-b,0),n.set(Z[3],R[0]-b,R[1]-b,0);for(let r=0;r<4;r++)if(!f.unprojectFromRenderScreen(Z[r],W[r]))return;d.fromPoints(f.eye,W[0],W[1],q),d.fromPoints(f.eye,W[1],W[2],Y),d.fromPoints(f.eye,W[2],W[3],X),d.fromPoints(f.eye,W[3],W[0],Q);let E=Number.MAX_VALUE,S=0;const O=y(this.parameters,p)?T.length-2:T.length-5;for(let r=0;r<O;r+=3){C[0]=T[r]+t[12],C[1]=T[r+1]+t[13],C[2]=T[r+2]+t[14];const e=(r+3)%T.length;if(D[0]=T[e]+t[12],D[1]=T[e+1]+t[13],D[2]=T[e+2]+t[14],d.signedDistance(q,C)<0&&d.signedDistance(q,D)<0||d.signedDistance(Y,C)<0&&d.signedDistance(Y,D)<0||d.signedDistance(X,C)<0&&d.signedDistance(X,D)<0||d.signedDistance(Q,C)<0&&d.signedDistance(Q,D)<0)continue;if(f.projectToRenderScreen(C,M),f.projectToRenderScreen(D,w),M[2]<0&&w[2]>0){n.subtract(V,C,D);const e=f.frustum,t=-d.signedDistance(e[l.PlaneIndex.NEAR],C)/n.dot(V,d.getNormal(e[l.PlaneIndex.NEAR]));n.scale(V,V,t),n.add(C,C,V),f.projectToRenderScreen(C,M)}else if(M[2]>0&&w[2]<0){n.subtract(V,D,C);const e=f.frustum,t=-d.signedDistance(e[l.PlaneIndex.NEAR],D)/n.dot(V,d.getNormal(e[l.PlaneIndex.NEAR]));n.scale(V,V,t),n.add(D,D,V),f.projectToRenderScreen(D,w)}else if(M[2]<0&&w[2]<0)continue;M[2]=0,w[2]=0;const a=u.distance2(u.fromPoints(M,w,H),R);a<E&&(E=a,n.copy(B,C),n.copy(J,D),S=r/3)}const g=i.rayBegin,I=i.rayEnd;if(E<b*b){let e=Number.MAX_VALUE;if(u.closestLineSegmentPoint(u.fromPoints(B,J,H),u.fromPoints(g,I,G),F)){n.subtract(F,F,g);const t=n.length(F);n.scale(F,F,1/t),e=t/n.distance(g,I)}h(e,F,S,!1)}}get _layout(){const e=h.newLayout().vec3f(_.VertexAttribute.POSITION).vec3f(_.VertexAttribute.PREVPOSITION).vec3f(_.VertexAttribute.NEXTPOSITION).f32(_.VertexAttribute.SUBDIVISIONFACTOR).vec2f(_.VertexAttribute.UV0);return this.parameters.vvSize?e.f32(_.VertexAttribute.SIZEFEATUREATTRIBUTE):e.f32(_.VertexAttribute.SIZE),this.parameters.vvColor?e.f32(_.VertexAttribute.COLORFEATUREATTRIBUTE):e.vec4f(_.VertexAttribute.COLOR),this.parameters.vvOpacity&&e.f32(_.VertexAttribute.OPACITYFEATUREATTRIBUTE),t("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(_.VertexAttribute.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new L(this._layout,this.parameters)}createGLMaterial(e){return new P(e)}validateParameters(e){"miter"!==e.join&&(e.miterLimit=0),null!=e.markerParameters&&(e.markerScale=e.markerParameters.width/e.width)}}class P extends T{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==p.ShaderOutput.Color&&this._output!==p.ShaderOutput.Alpha||this._updateOccludeeState(e);const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters({stippleTexture:this._stippleTextureRepository.swap(t,this._stipplePattern)}),this._stipplePattern=t),this.ensureTechnique(S.RibbonLineTechnique,e)}}class v extends R.VisualVariablePassParameters{constructor(){super(...arguments),this.width=0,this.color=c.ONES,this.join="miter",this.cap=O.CapType.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class L{constructor(e,t){this.vertexBufferLayout=e,this._parameters=t,this.numJoinSubdivisions=0;const r=t.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=r;break;case"round":this.numJoinSubdivisions=E.ribbonlineNumRoundJoinSubdivisions+r}}_isClosed(e){return y(this._parameters,e.attributes)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=2,r=e.attributes.get(_.VertexAttribute.POSITION).indices.length/2+1,a=this._isClosed(e);let i=a?2:2*t;return i+=((a?r:r-1)-(a?0:1))*(2*this.numJoinSubdivisions+4),i+=2,this._parameters.wireframe&&(i=2+4*(i-2)),i}write(e,r,a,i,s){const o=z,c=j,l=k,u=a.attributes.get(_.VertexAttribute.POSITION),d=u.indices,h=u.data.length/3,p=a.attributes.get(_.VertexAttribute.DISTANCETOSTART)?.data;d&&d.length!==2*(h-1)&&console.warn("RibbonLineMaterial does not support indices");const T=a.attributes.get(_.VertexAttribute.SIZEFEATUREATTRIBUTE)?.data[0]??a.attributes.get(_.VertexAttribute.SIZE)?.data[0]??1;let A=[1,1,1,1],f=0;const m=this.vertexBufferLayout.fields.has(_.VertexAttribute.COLORFEATUREATTRIBUTE);m?f=a.attributes.get(_.VertexAttribute.COLORFEATUREATTRIBUTE).data[0]:a.attributes.has(_.VertexAttribute.COLOR)&&(A=a.attributes.get(_.VertexAttribute.COLOR).data);const R=t("enable-feature:objectAndLayerId-rendering")?a.objectAndLayerIdColor:null,b=this.vertexBufferLayout.fields.has(_.VertexAttribute.OPACITYFEATUREATTRIBUTE),E=b?a.attributes.get(_.VertexAttribute.OPACITYFEATUREATTRIBUTE).data[0]:0,S=new Float32Array(i.buffer),O=t("enable-feature:objectAndLayerId-rendering")?new Uint8Array(i.buffer):null,I=this.vertexBufferLayout.stride/4;let P=s*I;const v=P;let L=0;const y=p?(e,t,r)=>L=p[r]:(e,t,r)=>L+=n.distance(e,t),x=t("enable-feature:objectAndLayerId-rendering"),C=(e,t,r,a,i,s,n)=>{if(S[P++]=t[0],S[P++]=t[1],S[P++]=t[2],S[P++]=e[0],S[P++]=e[1],S[P++]=e[2],S[P++]=r[0],S[P++]=r[1],S[P++]=r[2],S[P++]=a,S[P++]=n,S[P++]=i,S[P++]=T,m)S[P++]=f;else{const e=Math.min(4*s,A.length-4);S[P++]=A[e],S[P++]=A[e+1],S[P++]=A[e+2],S[P++]=A[e+3]}b&&(S[P++]=E),x&&(null!=R&&(O[4*P]=R[0],O[4*P+1]=R[1],O[4*P+2]=R[2],O[4*P+3]=R[3]),P++)};P+=I,n.set(c,u.data[0],u.data[1],u.data[2]),e&&n.transformMat4(c,c,e);const D=this._isClosed(a);if(D){const t=u.data.length-3;n.set(o,u.data[t],u.data[t+1],u.data[t+2]),e&&n.transformMat4(o,o,e)}else n.set(l,u.data[3],u.data[4],u.data[5]),e&&n.transformMat4(l,l,e),C(c,c,l,1,g.LEFT_CAP_START,0,0),C(c,c,l,1,g.RIGHT_CAP_START,0,0),n.copy(o,c),n.copy(c,l);const V=D?0:1,F=D?h:h-1;for(let t=V;t<F;t++){const r=(t+1)%h*3;n.set(l,u.data[r],u.data[r+1],u.data[r+2]),e&&n.transformMat4(l,l,e),y(o,c,t),C(o,c,l,0,g.LEFT_JOIN_END,t,L),C(o,c,l,0,g.RIGHT_JOIN_END,t,L);const a=this.numJoinSubdivisions;for(let e=0;e<a;++e){const r=(e+1)/(a+1);C(o,c,l,r,g.LEFT_JOIN_END,t,L),C(o,c,l,r,g.RIGHT_JOIN_END,t,L)}C(o,c,l,1,g.LEFT_JOIN_START,t,L),C(o,c,l,1,g.RIGHT_JOIN_START,t,L),n.copy(o,c),n.copy(c,l)}D?(n.set(l,u.data[3],u.data[4],u.data[5]),e&&n.transformMat4(l,l,e),L=y(o,c,F),C(o,c,l,0,g.LEFT_JOIN_END,V,L),C(o,c,l,0,g.RIGHT_JOIN_END,V,L)):(L=y(o,c,F),C(o,c,c,0,g.LEFT_CAP_END,F,L),C(o,c,c,0,g.RIGHT_CAP_END,F,L)),N(S,v+I,S,v,I);P=N(S,P-I,S,P,I),this._parameters.wireframe&&this._addWireframeVertices(i,v,P,I)}_addWireframeVertices(e,t,r,a){const i=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT),s=new Float32Array(e.buffer,t*Float32Array.BYTES_PER_ELEMENT,r-t);let n=0;const o=e=>n=N(s,e,i,n,a);for(let c=0;c<s.length-1;c+=2*a)o(c),o(c+2*a),o(c+1*a),o(c+2*a),o(c+1*a),o(c+3*a)}}function N(e,t,r,a,i){for(let s=0;s<i;s++)r[a++]=e[t++];return a}function y(e,t){if(!e.isClosed)return!1;return t.get(_.VertexAttribute.POSITION).indices.length>2}function x(e){return e.anchor===b.LineMarkerAnchor.Tip&&e.hideOnShortSegments&&"begin-end"===e.placement&&e.worldSpace}const C=o.create(),D=o.create(),V=o.create(),F=o.create(),U=o.create(),M=i.createRenderScreenPointArray3(),w=i.createRenderScreenPointArray3(),B=o.create(),J=o.create(),H=u.create(),G=u.create(),z=o.create(),j=o.create(),k=o.create(),Z=[i.createRenderScreenPointArray3(),i.createRenderScreenPointArray3(),i.createRenderScreenPointArray3(),i.createRenderScreenPointArray3()],W=[o.create(),o.create(),o.create(),o.create()],q=d.create(),Y=d.create(),X=d.create(),Q=d.create();e.Parameters=v,e.RibbonLineMaterial=I,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
