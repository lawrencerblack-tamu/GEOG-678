/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../core/has","../../../../core/mathUtils","../../../../core/libs/gl-matrix-2/math/mat3","../../../../core/libs/gl-matrix-2/factories/mat3f64","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../core/libs/gl-matrix-2/types/mat4","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/buffer/BufferView","../../layers/support/FastSymbolUpdates","../../support/debugFlags","../../support/buffer/InterleavedLayout","../core/shaderLibrary/ShaderOutput","../core/shaderLibrary/hud/HUD.glsl","../lib/GLTextureMaterial","../lib/Material","../lib/RenderSlot","../lib/screenSizePerspectiveUtils","../lib/Util","../lib/VertexAttribute","./ScaleInfo","./internal/bufferWriterUtils","./internal/MaterialUtil","../../../../chunks/HUDMaterial.glsl","../shaders/HUDMaterialTechnique","../shaders/HUDMaterialTechniqueConfiguration"],(function(e,t,r,a,i,s,n,o,l,c,u,f,h,d,p,g,m,b,A,S,O,x,T,v,V,y,E,I,R,_,P){"use strict";class C extends O.Material{constructor(e){super(e,new $),this._configuration=new P.HUDMaterialTechniqueConfiguration,this.produces=new Map([[x.RenderSlot.HUD_MATERIAL,e=>b.isColorAlphaHighlightOrOID(e)&&!this.parameters.drawInSecondSlot],[x.RenderSlot.LABEL_MATERIAL,e=>b.isColorAlphaHighlightOrOID(e)&&this.parameters.drawInSecondSlot],[x.RenderSlot.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[x.RenderSlot.DRAPED_MATERIAL,e=>b.isColorAlphaHighlightOrOID(e)]])}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===x.RenderSlot.OCCLUSION_PIXELS&&this.parameters.occlusionTest,e===b.ShaderOutput.Color&&(this._configuration.debugDrawLabelBorder=!!g.debugFlags.LABELS_SHOW_BORDER),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,r,i,n,o){if(!(r.options.selectionMode&&r.options.hud&&e.visible&&r.point))return;const u=this.parameters,f=r.point,h=r.camera;let{scaleX:d,scaleY:p}=this._getScreenScale(e);d*=h.pixelRatio,p*=h.pixelRatio,a.fromMat4(G,t),e.attributes.has(V.VertexAttribute.FEATUREATTRIBUTE)&&w(G);const g=e.attributes.get(V.VertexAttribute.POSITION),m=e.attributes.get(V.VertexAttribute.SIZE),b=e.attributes.get(V.VertexAttribute.NORMAL),A=e.attributes.get(V.VertexAttribute.CENTEROFFSETANDDISTANCE);v.assert(g.size>=3);const S=R.calculateAnchorPosForRendering(u),O="screen"===this.parameters.centerOffsetUnits;for(let a=0;a<g.data.length/g.size;a++){const e=a*g.size;l.set(U,g.data[e],g.data[e+1],g.data[e+2]),l.transformMat4(U,U,t);const i=a*m.size;K[0]=m.data[i]*d,K[1]=m.data[i+1]*p,l.transformMat4(U,U,h.viewMatrix);const n=a*A.size;if(l.set(W,A.data[n],A.data[n+1],A.data[n+2]),!O&&(U[0]+=W[0],U[1]+=W[1],0!==W[2])){const e=W[2];l.normalize(W,U),l.subtract(U,U,l.scale(W,W,e))}const x=a*b.size;if(l.set(N,b.data[x],b.data[x+1],b.data[x+2]),this._normalAndViewAngle(N,G,h,Z),this._applyVerticalOffsetTransformationView(U,Z,h,L),h.applyProjection(U,z),z[0]>-1){O&&(W[0]||W[1])&&(z[0]+=W[0]*h.pixelRatio,0!==W[1]&&(z[1]+=T.applyScaleFactor(W[1],L.factorAlignment)*h.pixelRatio),h.unapplyProjection(z,U)),z[0]+=this.parameters.screenOffset[0]*h.pixelRatio,z[1]+=this.parameters.screenOffset[1]*h.pixelRatio,z[0]=Math.floor(z[0]),z[1]=Math.floor(z[1]),T.applyPrecomputedScaleFactor(K,L.factor,K);const e=k*h.pixelRatio;let t=0;if(u.textureIsSignedDistanceField&&(t=u.outlineSize*h.pixelRatio/2),F(f,z[0],z[1],K,e,t,u,S)){const e=r.ray;if(l.transformMat4(H,U,s.invert(j,h.viewMatrix)),z[0]=f[0],z[1]=f[1],h.unprojectFromRenderScreen(z,U)){const t=c.create();l.copy(t,e.direction);const r=1/l.length(t);l.scale(t,t,r);o(l.distance(e.origin,U)*r,t,-1,!0,1,H)}}}}}intersectDraped(e,t,r,a,i,s){const n=e.attributes.get(V.VertexAttribute.POSITION),o=e.attributes.get(V.VertexAttribute.SIZE),l=this.parameters,c=R.calculateAnchorPosForRendering(l);let{scaleX:u,scaleY:f}=this._getScreenScale(e);u*=e.screenToWorldRatio,f*=e.screenToWorldRatio;const h=J*e.screenToWorldRatio;for(let d=0;d<n.data.length/n.size;d++){const t=d*n.size,r=n.data[t],p=n.data[t+1],g=d*o.size;K[0]=o.data[g]*u,K[1]=o.data[g+1]*f;let m=0;l.textureIsSignedDistanceField&&(m=l.outlineSize*e.screenToWorldRatio/2),F(a,r,p,K,h,m,l,c)&&i(s.dist,s.normal,-1,!1)}}createBufferWriter(){return new re(this)}_normalAndViewAngle(e,t,r,i){return f.isMat4(t)&&(t=a.fromMat4(q,t)),l.transformMat3(i.normal,e,t),l.transformMat4(i.normal,i.normal,r.viewInverseTransposeMatrix),i.cosAngle=l.dot(B,Q),i}_updateScaleInfo(e,t,r){const a=this.parameters;null!=a.screenSizePerspective?T.precomputeScaleFactor(r,t,a.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),null!=a.screenSizePerspectiveAlignment?T.precomputeScaleFactor(r,t,a.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,t,r,a,i,s,n){const o=this._normalAndViewAngle(t,r,i,Z);return this._applyVerticalGroundOffsetView(e,o,i,n),this._applyVerticalOffsetTransformationView(n,o,i,s),this._applyPolygonOffsetView(n,o,a[3],i,n),this._applyCenterOffsetView(n,a,n),n}applyShaderOffsetsNDC(e,t,r,a,i){return this._applyCenterOffsetNDC(e,t,r,a),null!=i&&l.copy(i,a),this._applyPolygonOffsetNDC(a,t,r,a),a}_applyPolygonOffsetView(e,t,a,i,s){const n=i.aboveGround?1:-1;let o=Math.sign(a);0===o&&(o=n);const c=n*o;if(this.parameters.shaderPolygonOffset<=0)return l.copy(s,e);const u=r.clamp(Math.abs(t.cosAngle),.01,1),f=1-Math.sqrt(1-u*u)/u/i.viewport[2];return c>0?l.scale(s,e,f):l.scale(s,e,1/f),s}_applyVerticalGroundOffsetView(e,t,r,a){const i=l.length(e),s=r.aboveGround?1:-1,n=r.computeRenderPixelSizeAtDist(i)*A.HUDVerticalPixelOffset,o=l.scale(U,t.normal,s*n);return l.add(a,e,o),a}_applyVerticalOffsetTransformationView(e,t,r,a){const i=this.parameters;if(!i.verticalOffset?.screenLength){if(i.screenSizePerspective||i.screenSizePerspectiveAlignment){const r=l.length(e);this._updateScaleInfo(a,r,t.cosAngle)}else a.factor.scale=1,a.factorAlignment.scale=1;return e}const s=l.length(e),n=i.screenSizePerspectiveAlignment??i.screenSizePerspective,o=I.verticalOffsetAtDistance(r,s,i.verticalOffset,t.cosAngle,n);return this._updateScaleInfo(a,s,t.cosAngle),l.scale(t.normal,t.normal,o),l.add(e,e,t.normal)}_applyCenterOffsetView(e,t,r){const a="screen"!==this.parameters.centerOffsetUnits;return r!==e&&l.copy(r,e),a&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(l.normalize(N,r),l.add(r,r,l.scale(N,N,t[2])))),r}_applyCenterOffsetNDC(e,t,r,a){const i="screen"!==this.parameters.centerOffsetUnits;return a!==e&&l.copy(a,e),i||(a[0]+=t[0]/r.fullWidth*2,a[1]+=t[1]/r.fullHeight*2),a}_applyPolygonOffsetNDC(e,t,r,a){const i=this.parameters.shaderPolygonOffset;if(e!==a&&l.copy(a,e),i){const e=r.aboveGround?1:-1,s=e*Math.sign(t[3]);a[2]-=(s||e)*i}return a}createGLMaterial(e){return new D(e)}calculateRelativeScreenBounds(e,t,r=h.create()){return M(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}_getScreenScale(e){const t=e.attributes.get(V.VertexAttribute.FEATUREATTRIBUTE);if(null==t)return{scaleX:1,scaleY:1};const r=u.fromArray(t.data,Y),[a,i]=p.evaluateModelTransformScale(X,this.parameters,r);return{scaleX:a,scaleY:i}}}class D extends S.GLTextureMaterial{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(_.HUDMaterialTechnique,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function M(e,t,r,a){a[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*r,a[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*r}function w(e){const t=e[0],r=e[1],a=e[2],i=e[3],s=e[4],n=e[5],o=e[6],l=e[7],c=e[8],u=1/Math.sqrt(t*t+r*r+a*a),f=1/Math.sqrt(i*i+s*s+n*n),h=1/Math.sqrt(o*o+l*l+c*c);return e[0]=t*u,e[1]=r*u,e[2]=a*u,e[3]=i*f,e[4]=s*f,e[5]=n*f,e[6]=o*h,e[7]=l*h,e[8]=c*h,e}function F(e,t,r,a,i,s,n,o){let l=t-i-(o[0]>0?a[0]*o[0]:0),c=l+a[0]+2*i,u=r-i-(o[1]>0?a[1]*o[1]:0),f=u+a[1]+2*i;const h=n.distanceFieldBoundingBox;return n.textureIsSignedDistanceField&&null!=h&&(l+=a[0]*h[0],u+=a[1]*h[1],c-=a[0]*(1-h[2]),f-=a[1]*(1-h[3]),l-=s,c+=s,u-=s,f+=s),e[0]>l&&e[0]<c&&e[1]>u&&e[1]<f}const L=new y.ScaleInfo,U=c.create(),N=c.create(),z=u.create(),B=c.create(),H=c.create(),G=i.create(),q=i.create(),j=n.create(),W=c.create(),X=c.create(),Y=u.create(),Z={normal:B,cosAngle:0},k=1,J=2,K=[0,0],Q=c.fromValues(0,0,1);class $ extends S.GLTextureMaterialBindParameters{constructor(){super(...arguments),this.renderOccluded=O.RenderOccludedFlag.Occlude,this.isDecoration=!1,this.color=u.fromValues(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=o.fromValues(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=u.fromValues(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.draped=!1}}const ee=m.newLayout().vec3f(V.VertexAttribute.POSITION).vec3f(V.VertexAttribute.NORMAL).vec2f(V.VertexAttribute.UV0).vec4u8(V.VertexAttribute.COLOR).vec2f(V.VertexAttribute.SIZE).vec4f(V.VertexAttribute.CENTEROFFSETANDDISTANCE).vec4f(V.VertexAttribute.FEATUREATTRIBUTE),te=ee.clone().vec4u8(V.VertexAttribute.OBJECTANDLAYERIDCOLOR);class re{constructor(e){this._material=e,this.vertexBufferLayout=t("enable-feature:objectAndLayerId-rendering")?te:ee}elementCount(e){return 6*e.attributes.get(V.VertexAttribute.POSITION).indices.length}write(e,t,r,a,i){E.writePosition(r.attributes.get(V.VertexAttribute.POSITION),e,a.position,i,6),E.writeNormal(r.attributes.get(V.VertexAttribute.NORMAL),t,a.normal,i,6);const s=r.attributes.get(V.VertexAttribute.UV0).data;let n,o,l,c;if(null==s||s.length<4){const e=this._material.parameters;n=0,o=0,l=e.texCoordScale[0],c=e.texCoordScale[1]}else n=s[0],o=s[1],l=s[2],c=s[3];l=Math.min(1.99999,l+1),c=Math.min(1.99999,c+1);let u=r.attributes.get(V.VertexAttribute.POSITION).indices.length,f=i;const h=a.uv0;for(let d=0;d<u;++d)h.set(f,0,n),h.set(f,1,o),f++,h.set(f,0,l),h.set(f,1,o),f++,h.set(f,0,l),h.set(f,1,c),f++,h.set(f,0,l),h.set(f,1,c),f++,h.set(f,0,n),h.set(f,1,c),f++,h.set(f,0,n),h.set(f,1,o),f++;E.writeColor(r.attributes.get(V.VertexAttribute.COLOR),4,a.color,i,6);const{data:p,indices:g}=r.attributes.get(V.VertexAttribute.SIZE);u=g.length;const m=a.size;f=i;for(let d=0;d<u;++d){const e=p[2*g[d]],t=p[2*g[d]+1];for(let r=0;r<6;++r)m.set(f,0,e),m.set(f,1,t),f++}if(r.attributes.get(V.VertexAttribute.CENTEROFFSETANDDISTANCE)?E.writeBufferVec4(r.attributes.get(V.VertexAttribute.CENTEROFFSETANDDISTANCE),a.centerOffsetAndDistance,i,6):E.writeBufferVec4Zeros(a.centerOffsetAndDistance,i,6*u),r.attributes.get(V.VertexAttribute.FEATUREATTRIBUTE)?E.writeBufferVec4(r.attributes.get(V.VertexAttribute.FEATUREATTRIBUTE),a.featureAttribute,i,6):E.writeBufferVec4Zeros(a.featureAttribute,i,6*u),null!=r.objectAndLayerIdColor){const e=r.attributes.get(V.VertexAttribute.POSITION)?.indices;if(e){const t=e.length,s=a.getField(V.VertexAttribute.OBJECTANDLAYERIDCOLOR,d.BufferViewVec4u8);E.writeObjectAndLayerIdColor(r.objectAndLayerIdColor,s,t,i,6)}}}}e.HUDMaterial=C,e.Parameters=$,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
