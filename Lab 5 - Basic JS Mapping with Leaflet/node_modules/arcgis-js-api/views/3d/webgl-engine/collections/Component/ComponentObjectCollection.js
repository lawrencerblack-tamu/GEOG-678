/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../../core/has","../../../../../core/Logger","../../../../../core/PooledArray","../../../../../core/typedArrayUtil","../../../../../chunks/vec32","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../geometry/support/aaBoundingBox","../../../../../geometry/support/Indices","../../../../../chunks/vec3","../../../../../chunks/vec33","../../../../ViewingMode","../../../layers/support/symbolColorUtils","../../../support/orientedBoundingBox","../../../support/buffer/glUtil","../../../support/buffer/InterleavedLayout","./ComponentData","./ComponentObject","./IntersectionGeometry","./Renderable","./RenderGeometry","./RenderSubmitSystem","./SourceGeometry","./UniformComponentParameters","./Material/ComponentMaterial","./Material/ComponentTechnique","./Material/shader/ComponentData.glsl","../../lib/ComponentUtils","../../lib/Util","../../lib/VertexAttribute","../../lib/verticalOffsetUtils","../../lib/edgeRendering/bufferLayouts","../../lib/edgeRendering/edgeProcessing","../../lib/TextureBackedBuffer/BufferManager","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/VertexArrayObject"],(function(e,t,n,o,i,r,a,s,l,c,h,m,u,f,d,g,p,b,y,C,v,_,M,O,x,w,A,R,S,D,V,I,P,j,E,B,L){"use strict";const U=()=>n.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class N{constructor(e,n){this._renderManager=e,this._viewingMode=n,this._elevationRangeCacheVerticalOffset=NaN,this._elevationRangeCacheMin=NaN,this._elevationRangeCacheMax=NaN,this._visible=new o,this._hidden=new o,this._renderSubmit=new _.RenderSubmitSystem(this),this._renderManager.register(this._renderSubmit),this._hasObjectAndLayerId=t("enable-feature:objectAndLayerId-rendering"),this._componentBufferManager=new j.BufferManager(e.rctx,2+(this._hasObjectAndLayerId?1:0))}destroy(){S.assert(0===this._hidden.length&&0===this._visible.length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy(),this._visible.forAll((e=>e.destroy())),this._hidden.forAll((e=>e.destroy())),this._visible.clear(),this._hidden.clear()}createObject(e){const t=e.geometry,n=new p(this._componentBufferManager,l.compactIndices(t.componentOffsets)),o=this._createRenderable(e,n),i=new y(this._viewingMode,t.positionData,n),r=new b.ComponentObject(e.transform,e.toMapSpace,e.obb.clone(),n,o,i);return(r.visible?this._visible:this._hidden).push(r),r}destroyObject(e){const t=e;(t.visible?this._visible:this._hidden).removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const n=e;t!==n.visible&&(t?(this._hidden.removeUnordered(n),this._visible.push(n)):(this._visible.removeUnordered(n),this._hidden.push(n)),n.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=r.squaredDistance(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const n=e.renderable.material;t(n),n.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const n=e;n.components.visibility.reset(t),n.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,n=t.components.visibility.componentCount;return{visible:n,invisible:t.components.count-n}}setComponentData(e,t){const n=e,o=n.renderable.material,i=n.components,r=i.materialDataBuffer,a=i.materialDataIndices,s=new O.UniformComponentParameters,l=r.textureBuffer,c=new Uint8Array(4),h=new Uint32Array(c.buffer);let m=0,d=0,g=0,p=i.verticalOffsets,b=1/0,y=-1/0,C=!1,v=!1,_=0;for(let f=0;f<i.count;f++){t(f,s),m+=+(s.externalColor[3]<1),d+=+(s.externalColorMixMode===u.ColorMixModeEnum.Replace&&1===s.externalColor[3]),g+=+s.castShadows,u.encodeSymbolColor(s.externalColor,s.externalColorMixMode,c),c[2]=254&c[2]|+s.castShadows,l.setData(a[f],0,c[0],c[1],c[2],c[3]),C||=f>0&&_!==h[0],_=h[0],v||=0!==s.elevationOffset,v&&null==p&&(p=new Array(f).fill(0)),null!=p&&(p[f]=s.elevationOffset),b=Math.min(b,s.elevationOffset),y=Math.max(y,s.elevationOffset),A.encodeElevationOffset(s.elevationOffset,c),l.setData(a[f],1,c[0],c[1],c[2],c[3]);const e=s.objectAndLayerIdColor;null!=e&&l.setData(a[f],2,e[0],e[1],e[2],e[3]),s.pickable!==R.getVisibility(i.pickability,f)&&(i.pickability=R.updateVisibilityWithCount(i.pickability,i.count,f,s.pickable))}i.verticalOffsets=v?p:null,n.offsetObb=v?f.computeOffsetObb(n.obb,b,y,this._viewingMode,n.offsetObb??n.obb.clone()):null,C||v||this._hasObjectAndLayerId?(o.componentParameters=new x.ComponentParametersVarying,o.componentParameters.castShadows=G(g,i.count),o.componentParameters.transparent=G(m,i.count),o.componentParameters.opaqueOverride=G(d,i.count),o.componentParameters.texture=l,l.updateTexture()):(o.componentParameters=new x.ComponentParametersUniform,o.componentParameters.castShadows=s.castShadows?x.ComponentParameterSummary.All:x.ComponentParameterSummary.None,o.componentParameters.externalColor=s.externalColor,o.componentParameters.externalColorMixMode=s.externalColorMixMode),this._elevationRangeCacheVerticalOffset=NaN,this._notifyDirty()}getComponentAabb(e,t,n,o=!1){e.intersectionGeometry.getComponentAabb(t,n);const i=e,r=i.components.verticalOffsets;if(o||null==r)return n;const a=r[t];if(this._viewingMode===m.ViewingMode.Local||0===a)return n[2]+=a,n[5]+=a,n;const s=V.getVerticalOffsetI3S(a);return s.localOrigin=i.transform.position,s.applyToAabb(n)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,n){return e.intersectionGeometry.getComponentPositions(t,n)}expandRangeWithComponentObjectElevationRange(e,t,n,o){Number.isNaN(this._elevationRangeCacheVerticalOffset)||this._elevationRangeCacheVerticalOffset!==t||o.expandElevationRangeValues(this._elevationRangeCacheMin,this._elevationRangeCacheMax);const i=e,r=i.components,a=r.count,s=r.verticalOffsets,l=i.intersectionGeometry,c=this._viewingMode===m.ViewingMode.Local,h=l.getComponentAabbs(),u=k;let f=1/0,d=-1/0;for(let m=0;m<a;m++){const e=6*m,r=s?.[m]??0;let a=1/0,l=-1/0;if(c)a=h[e+2]+r+t,l=h[e+5]+r+t;else{if(u[0]=h[e],u[1]=h[e+1],u[2]=h[e+2],u[3]=h[e+3],u[4]=h[e+4],u[5]=h[e+5],0!==r){const e=V.getVerticalOffsetI3S(r);e.localOrigin=i.transform.position,e.applyToAabb(u)}const a=Math.max(Math.abs(u[3]),Math.abs(u[0])),s=Math.max(Math.abs(u[4]),Math.abs(u[1])),l=t+u[5]+n;o.expandElevationRangeValues(t+u[2],Math.sqrt(a*a+s*s+l*l)-n)}o.expandElevationRangeValues(a,l),f=Math.min(f,a),d=Math.max(d,l)}this._elevationRangeCacheVerticalOffset=t,this._elevationRangeCacheMin=f,this._elevationRangeCacheMax=d}intersect(e,t,n,o,i,r,a){const s=e,{transform:l}=s,{position:c}=l;return null!=i&&(i.localOrigin=c),s.intersectionGeometry.intersect(t,n,o,i,s.components.verticalOffsets,r,l,a??!1)}addEdges(e,t,n,o){const i=e,{indices:r,positions:a}=i.intersectionGeometry,s=i.components.offsets;return t.addComponentObject(i,a,r,s,n,o)}async extractEdgeInformation(e,t,n){const o=e,i=o.components.visibility;if(i.allInvisible())return{buffer:P.extractComponentsEdgeLocationsLayout.createBuffer(0),origin:[0,0,0]};const{indices:r,positions:s}=o.intersectionGeometry,l=o.components.offsets,m=I.EdgeInputBufferLayout.createBuffer(s.length/3);h.copy(m.position.typedBuffer,s,m.position.typedBufferStride,3),c.transformMat3View(m.position,m.position,o.transform.rotationScale),this._setComponentIndices(m.componentIndex,r,l);const u=m.count,f=this._computeVisibilityIndices(r,i,l,u);return{origin:a.clone(o.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:f,indicesLength:f.length,skipDeduplicate:!0,data:m,writerSettings:{reducedPrecision:!1,variants:0}},n)}}_setComponentIndices(e,t,n){let o=0;for(let i=0;i<n.length-1;i++){const r=n[i],a=n[i+1];for(let n=r;n<a;n++){const i=t?t[n]:n;e.set(i,o)}o++}}_computeVisibilityIndices(e,t,n,o){if(e&&t.allVisible())return e;let r=0;t.forEachComponentRange(((e,t)=>(r+=n[t]-n[e],!0)));const a=i.isArray(e)?new Array(r):2===e?.BYTES_PER_ELEMENT||o<=65536?new Uint16Array(r):new Uint32Array(r);let s=0;return t.forEachComponentRange(((t,o)=>{const i=n[t],r=n[o];for(let n=i;n<r;n++)a[s++]=e?e[n]:n;return!0})),a}addComponentHighlight(e,t){const n=e.components;null==n.highlightCounts&&(n.highlightCounts=new Uint32Array(n.count+1));0===n.highlightCounts[t]++&&(n.highlightsDirty(),this._notifyDirty()),n.highlightCounts[n.count]++}removeComponentHighlight(e,t){const n=e.components;if(null==n.highlightCounts)return void U().warn("Removing non-existing highlight.");const o=n.highlightCounts[t],i=n.highlightCounts[n.count];if(0!==o){if(o>1)return n.highlightCounts[t]=o-1,void(n.highlightCounts[n.count]=i-1);n.highlightCounts[t]=0,n.highlightsDirty(),this._notifyDirty(),1===i?n.highlightCounts=null:n.highlightCounts[n.count]=i-1}else U().warn("Removing non-existing highlight.")}clearHighlights(e){const t=e.components;null!=t.highlightCounts&&(t.highlightCounts=null,t.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._visible}_createRenderable(e,t){const n=this._renderManager.rctx,o=e.geometry,i=o.vertices.layoutParameters,r=E.BufferObject.createVertex(n,B.Usage.STATIC_DRAW,o.vertices.data),a=o.indices?E.BufferObject.createIndex(n,B.Usage.STATIC_DRAW,o.indices):null,s=d.glLayout(M.createVertexBufferLayout(i)),l=new Uint16Array(o.vertices.count);for(let d=0;d<t.count;d++){const e=t.offsets[d],n=t.offsets[d+1],i=t.materialDataIndices[d];if(null!=o.indices)for(let t=e;t<n;t++){l[o.indices[t]]=i}else for(let t=e;t<n;t++)l[t]=i}const c=E.BufferObject.createVertex(n,B.Usage.STATIC_DRAW,l.buffer),h=new x.ComponentMaterial(e.transform,e.toMapSpace),m=new L.VertexArrayObject(n,w.attributeLocations,{data:s,componentIndices:T},{data:r,componentIndices:c},a),u=new v.RenderGeometry(m,B.PrimitiveType.TRIANGLES,i,null!=a),f={cameraDepthSquared:.5,gpuMemoryEstimate:r.usedMemory+c.usedMemory+(null!=a?a.usedMemory:0)};return new C.Renderable(h,u,f)}_notifyDirty(){this._renderManager.notifyDirty()}}const T=d.glLayout(g.newLayout().u16(D.VertexAttribute.COMPONENTINDEX));function G(e,t){return e===t?x.ComponentParameterSummary.All:0===e?x.ComponentParameterSummary.None:x.ComponentParameterSummary.Some}const k=s.create();e.ComponentObjectCollection=N,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
