/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../../core/ObjectPool","../../../../core/PooledArray","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/support/frustum","../../../../geometry/support/ray","../../../../chunks/sphere","./Util"],(function(e,t,n,o,r,s,i,h){"use strict";class a{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(e,t){this.objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new d,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth))}destroy(){this._degenerateObjects.clear(),d.clearPool(),x[0]=null,D.prune(),A.prune()}add(e,t=e.length){this._objectCount+=t,this._grow(e,t);const n=d.acquire();for(let o=0;o<t;o++){const t=e[o];this._isDegenerate(t)?this._degenerateObjects.add(t):(n.init(this._root),this._add(t,n))}d.release(n)}remove(e,t=null){this._objectCount-=e.length;const n=d.acquire();for(const o of e){const e=t??i.copy(this.objectToBoundingSphere(o),E);g(e[3])?(n.init(this._root),this._remove(o,e,n)):this._degenerateObjects.delete(o)}d.release(n),this._shrink()}update(e,t){if(!g(t[3])&&this._isDegenerate(e))return;const n=N(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const o=s.wrap(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNode(o,e))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObject(o,e)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObject(o,e)&&n(e)})),!0}))}forEachAlongRayWithVerticalOffset(e,t,n,o){const r=s.wrap(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNodeWithOffset(r,e,o))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObjectWithOffset(r,e,o)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObjectWithOffset(r,e,o)&&n(e)})),!0}))}forEach(e){this._forEachNode(this._root,(t=>{const n=t.node;return n.terminals.forAll(e),null!==n.residents&&n.residents.forAll(e),!0})),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,o,s=(()=>!0),h=1/0){let a=1/0,d=1/0,l=null;const u=_(e,t),c=n=>{if(--h,!s(n))return;const u=this.objectToBoundingSphere(n);if(!r.intersectsSphere(o,u))return;const c=p(e,t,i.getCenter(u)),f=c-u[3],m=c+u[3];f<a&&(a=f,d=m,l=n)};return this._forEachNodeDepthOrdered(this._root,(s=>{if(h<=0||!r.intersectsSphere(o,s.bounds))return!1;n.scale(T,u,s.halfSize),n.add(T,T,i.getCenter(s.bounds));if(p(e,t,T)>d)return!1;const a=s.node;return a.terminals.forAll((e=>c(e))),null!==a.residents&&a.residents.forAll((e=>c(e))),!0}),e,t),l}forEachInDepthRange(e,t,o,s,h,d,l){let u=-1/0,c=1/0;const f={setRange:e=>{o===a.DepthOrder.FRONT_TO_BACK?(u=Math.max(u,e.near),c=Math.min(c,e.far)):(u=Math.max(u,-e.far),c=Math.min(c,-e.near))}};f.setRange(s);const m=p(t,o,e),g=_(t,o),b=_(t,-o),S=e=>{if(!l(e))return;const n=this.objectToBoundingSphere(e),s=i.getCenter(n),a=p(t,o,s)-m,_=a-n[3],g=a+n[3];_>c||g<u||!r.intersectsSphere(d,n)||h(e,f)};this._forEachNodeDepthOrdered(this._root,(e=>{if(!r.intersectsSphere(d,e.bounds))return!1;n.scale(T,g,e.halfSize),n.add(T,T,i.getCenter(e.bounds));if(p(t,o,T)-m>c)return!1;n.scale(T,b,e.halfSize),n.add(T,T,i.getCenter(e.bounds));if(p(t,o,T)-m<u)return!1;const s=e.node;return s.terminals.forAll((e=>S(e))),null!==s.residents&&s.residents.forAll((e=>S(e))),!0}),t,o)}forEachNode(e){this._forEachNode(this._root,(t=>e(t.node,t.bounds,t.halfSize,t.depth)))}forEachNeighbor(e,t){const o=i.getRadius(t),r=i.getCenter(t),s=t=>{const s=this.objectToBoundingSphere(t),h=i.getRadius(s),a=o+h;return!(n.squaredDistance(i.getCenter(s),r)-a*a<=0)||e(t)};let h=!0;const a=e=>{h&&(h=s(e))};this._forEachNode(this._root,(e=>{const t=i.getRadius(e.bounds),s=o+t;if(n.squaredDistance(i.getCenter(e.bounds),r)-s*s>0)return!1;const d=e.node;return d.terminals.forAll(a),h&&null!==d.residents&&d.residents.forAll(a),h})),h&&this.forEachDegenerateObject(a)}_intersectsNode(e,t){return c(i.getCenter(t.bounds),2*-t.halfSize,z),c(i.getCenter(t.bounds),2*t.halfSize,C),h.rayBoxTest(e.origin,e.direction,z,C)}_intersectsNodeWithOffset(e,t,n){return c(i.getCenter(t.bounds),2*-t.halfSize,z),c(i.getCenter(t.bounds),2*t.halfSize,C),n.applyToMinMax(z,C),h.rayBoxTest(e.origin,e.direction,z,C)}_intersectsObject(e,t){const n=this.objectToBoundingSphere(t);return!(n[3]>0)||i.intersectsRay(n,e)}_intersectsObjectWithOffset(e,t,n){const o=this.objectToBoundingSphere(t);return!(o[3]>0)||i.intersectsRay(n.applyToBoundingSphere(o),e)}_forEachNode(e,t){let n=d.acquire().init(e);const o=[n];for(;0!==o.length;){if(n=o.pop(),t(n)&&!n.isLeaf())for(let e=0;e<n.node.children.length;e++){n.node.children[e]&&o.push(d.acquire().init(n).advance(e))}d.release(n)}}_forEachNodeDepthOrdered(e,t,n,o=a.DepthOrder.FRONT_TO_BACK){let r=d.acquire().init(e);const s=[r];for(m(n,o,F);0!==s.length;){if(r=s.pop(),t(r)&&!r.isLeaf())for(let e=7;e>=0;--e){const t=F[e];r.node.children[t]&&s.push(d.acquire().init(r).advance(t))}d.release(r)}}_remove(e,t,n){D.clear();const o=n.advanceTo(t,((e,t)=>{D.push(e.node),D.push(t)}))?n.node.terminals:n.node.residents;if(o.removeUnordered(e),0===o.length)for(let r=D.length-2;r>=0;r-=2){const e=D.data[r],t=D.data[r+1];if(!this._purge(e,t))break}}_nodeIsEmpty(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0}_purge(e,n){return n>=0&&(e.children[n]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new t({shrink:!0})),!0)}_add(e,t){t.advanceTo(this.objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const o=d.acquire().init(e);this._add(t.at(n),o),d.release(o)}}_grow(e,t){if(0!==t&&(f(e,t,(e=>this.objectToBoundingSphere(e)),M),g(M[3])&&!this._fitsInsideTree(M)))if(this._nodeIsEmpty(this._root.node))i.copy(M,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const e=this._rootBoundsForRootAsSubNode(M);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(M,e):this._growRootAsSubNode(e),d.release(e)}}_rebuildTree(e,t){n.copy(i.getCenter(B),i.getCenter(t.bounds)),B[3]=t.halfSize,f([e,B],2,(e=>e),R);const o=d.acquire().init(this._root);this._root.initFrom(null,R,R[3]),this._root.increaseHalfSize(1.25),this._forEachNode(o,(e=>(this.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&this.add(e.node.residents.data,e.node.residents.length),!0))),d.release(o)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,(e=>(n=Math.max(n,e.depth),n+t<=this._maximumDepth))),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let o=-1/0;const r=this._root.bounds,s=this._root.halfSize;for(let h=0;h<3;h++){const e=r[h]-s-(n[h]-t),i=n[h]+t-(r[h]+s),a=Math.max(0,Math.ceil(e/(2*s))),d=Math.max(0,Math.ceil(i/(2*s)))+1,l=2**Math.ceil(Math.log(a+d)*Math.LOG2E);o=Math.max(o,l),y[h].min=a,y[h].max=d}for(let h=0;h<3;h++){let e=y[h].min,t=y[h].max;const n=(o-(e+t))/2;e+=Math.ceil(n),t+=Math.floor(n);const i=r[h]-s-e*s*2;j[h]=i+(t+e)*s}const i=o*s;return j[3]=i*O,d.acquire().initFrom(null,j,i,0)}_growRootAsSubNode(e){const t=this._root.node;n.copy(i.getCenter(M),i.getCenter(this._root.bounds)),M[3]=this._root.halfSize,this._root.init(e),e.advanceTo(M,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,o=0;for(;o<t.length&&null==e;)n=o++,e=t[n];for(;o<t.length;)if(t[o++])return-1;return n}_isDegenerate(e){return!g(this.objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}toJSON(){const{maximumDepth:e,maximumObjectsPerNode:t,_objectCount:n}=this,o=this._nodeToJSON(this._root.node);return{maximumDepth:e,maximumObjectsPerNode:t,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:o}}}_nodeToJSON(e){const t=e.children.map((e=>e?this._nodeToJSON(e):null)),n=e.residents?.map((e=>this.objectToBoundingSphere(e))),o=e.terminals?.map((e=>this.objectToBoundingSphere(e)));return{children:t,residents:n,terminals:o}}static fromJSON(e){const t=new a((e=>e),{maximumDepth:e.maximumDepth,maximumObjectsPerNode:e.maximumObjectsPerNode});return t._objectCount=e.objectCount,t._root.initFrom(e.root.node,e.root.bounds,e.root.halfSize,e.root.depth),t}}class d{constructor(){this.bounds=i.create(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(e,t,n,o=this.depth){return this.node=null!=e?e:d.createEmptyNode(),t&&i.copy(t,this.bounds),this.halfSize=n,this.depth=o,this}increaseHalfSize(e){this.halfSize*=e,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*O}advance(e){let t=this.node.children[e];t||(t=d.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=b[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const o=this._childIndex(e);t&&t(this,o),this.advance(o)}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new t({shrink:!0}),residents:new t({shrink:!0})}}static acquire(){return d._pool.acquire()}static release(e){d._pool.release(e)}static clearPool(){d._pool.prune()}}function l(e,t){e[0]=Math.min(e[0],t[0]-t[3]),e[1]=Math.min(e[1],t[1]-t[3]),e[2]=Math.min(e[2],t[2]-t[3])}function u(e,t){e[0]=Math.max(e[0],t[0]+t[3]),e[1]=Math.max(e[1],t[1]+t[3]),e[2]=Math.max(e[2],t[2]+t[3])}function c(e,t,n){n[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t}function f(e,t,o,r){if(1===t){const t=o(e[0]);i.copy(t,r)}else{z[0]=1/0,z[1]=1/0,z[2]=1/0,C[0]=-1/0,C[1]=-1/0,C[2]=-1/0;for(let n=0;n<t;n++){const t=o(e[n]);g(t[3])&&(l(z,t),u(C,t))}n.lerp(i.getCenter(r),z,C,.5),r[3]=Math.max(C[0]-z[0],C[1]-z[1],C[2]-z[2])/2}}function m(e,t,n){if(!A.length)for(let o=0;o<8;++o)A.push({index:0,distance:0});for(let o=0;o<8;++o){const n=b[o];A.data[o].index=o,A.data[o].distance=p(e,t,n)}A.sort(((e,t)=>e.distance-t.distance));for(let o=0;o<8;++o)n[o]=A.data[o].index}function _(e,t){let n,o=1/0;for(let r=0;r<8;++r){const s=p(e,t,S[r]);s<o&&(o=s,n=S[r])}return n}function p(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}function g(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}d._pool=new e(d),function(e){var t;(t=e.DepthOrder||(e.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(a||(a={}));const b=[o.fromValues(-1,-1,-1),o.fromValues(1,-1,-1),o.fromValues(-1,1,-1),o.fromValues(1,1,-1),o.fromValues(-1,-1,1),o.fromValues(1,-1,1),o.fromValues(-1,1,1),o.fromValues(1,1,1)],S=[o.fromValues(-1,-1,-1),o.fromValues(-1,-1,1),o.fromValues(-1,1,-1),o.fromValues(-1,1,1),o.fromValues(1,-1,-1),o.fromValues(1,-1,1),o.fromValues(1,1,-1),o.fromValues(1,1,1)],O=Math.sqrt(3),x=[null];function N(e){return x[0]=e,x}const j=i.create(),T=o.create(),z=o.create(),C=o.create(),D=new t,E=i.create(),M=i.create(),B=i.create(),R=i.create(),y=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],A=new t,F=[0,0,0,0,0,0,0,0];return a}));
