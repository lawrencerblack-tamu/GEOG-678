/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["require","exports","../../../geometry/SpatialReference","../../../geometry/support/DoubleArray","../../../geometry/support/MeshGeoreferencedVertexSpace","../../../geometry/support/MeshLocalVertexSpace","../../../chunks/vec3","../../../libs/i3s/enums","../../../libs/i3s/I3SModule","./i3s/I3SNode"],(function(e,t,r,o,n,i,s,a,f,c){"use strict";async function l(e){w=await x();const t=[e.geometryBuffer];return{result:I(w,e,t),transferList:t}}async function u(e){w=await x();const t=[e.geometryBuffer],{geometryBuffer:r}=e,o=r.byteLength,n=w._malloc(o),i=new Uint8Array(w.HEAPU8.buffer,n,o);i.set(new Uint8Array(r));const s=w.dracoDecompressPointCloudData(n,i.byteLength);if(w._free(n),s.error.length>0)throw new Error(`i3s.wasm: ${s.error}`);const a=s.featureIds?.length>0?s.featureIds.slice():null,f=s.positions.slice();return a&&t.push(a.buffer),t.push(f.buffer),{result:{positions:f,featureIds:a},transferList:t}}async function d(e){await x(),A(e);const t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function y(e){await x(),E(e)}async function m(e){w=await x(),w.setLegacySchema(e.context,e.jsonSchema)}async function p(t){const{localMatrix:s,origin:a,positions:f,vertexSpace:c,localMode:l}=t,u=r.fromJSON(t.inSpatialReference),d=r.fromJSON(t.outSpatialReference);let y;if("georeferenced"===c.type&&null==c.origin){const[{projectBuffer:t},{initializeProjection:r}]=await Promise.all([new Promise(((t,r)=>e(["../../../geometry/projection/projectBuffer"],t,r))),new Promise(((t,r)=>e(["../../../geometry/projection"],t,r)))]);await r(u,d),y=new Float64Array(f.length),t(f,u,0,y,d,0,y.length/3)}else{const t="georeferenced"===c.type?n.fromJSON(c):i.fromJSON(c),{project:r}=await new Promise(((t,r)=>e(["../../../geometry/support/meshUtils/georeference"],t,r)));y=o.toFloat64Array(r({positions:f,transform:s?{localMatrix:s}:void 0,vertexSpace:t,inSpatialReference:u,outSpatialReference:d,localMode:l}))}const m=y.length,[p,b,g]=a;for(let e=0;e<m;e+=3)y[e]-=p,y[e+1]-=b,y[e+2]-=g;return{result:{projected:y,original:f},transferList:[y.buffer,f.buffer]}}async function b({normalMatrix:e,normals:t}){const r=new Float32Array(t.length);return s.transformMat3(r,t,e),s.normalize(r,r),{result:{transformed:r,original:t},transferList:[r.buffer,t.buffer]}}function g(e){S(e)}let h,w;function E(e){if(!w)return;const t=e.modifications,r=w._malloc(8*t.length),o=new Float64Array(w.HEAPU8.buffer,r,t.length);for(let n=0;n<t.length;++n)o[n]=t[n];w.setModifications(e.context,r,t.length,e.isGeodetic),w._free(r)}function I(e,t,r){const{context:o,localOrigin:n,globalTrafo:i,mbs:s,obbData:f,elevationOffset:c,geometryBuffer:l,geometryDescriptor:u,indexToVertexProjector:d,vertexToRenderProjector:y}=t,m=e._malloc(l.byteLength),p=33,b=e._malloc(p*Float64Array.BYTES_PER_ELEMENT),g=new Uint8Array(e.HEAPU8.buffer,m,l.byteLength);g.set(new Uint8Array(l));const h=new Float64Array(e.HEAPU8.buffer,b,p);L(h,n);let w=h.byteOffset+3*h.BYTES_PER_ELEMENT,E=new Float64Array(h.buffer,w);L(E,i),w+=16*h.BYTES_PER_ELEMENT,E=new Float64Array(h.buffer,w),L(E,s),w+=4*h.BYTES_PER_ELEMENT,f&&(E=new Float64Array(h.buffer,w),L(E,f));const I=u,M={isDraco:!1,isLegacy:!1,color:t.layouts.some((e=>e.some((e=>"color"===e.name)))),normal:t.needNormals&&t.layouts.some((e=>e.some((e=>"normalCompressed"===e.name)))),uv0:t.layouts.some((e=>e.some((e=>"uv0"===e.name)))),uvRegion:t.layouts.some((e=>e.some((e=>"uvRegion"===e.name)))),featureIndex:I.featureIndex},A=e.process(o,!!t.obbData,m,g.byteLength,I,M,b,c,d,y,t.normalReferenceFrame);if(e._free(b),e._free(m),A.error.length>0)throw new Error(`i3s.wasm: ${A.error}`);if(A.discarded)return null;const S=A.componentOffsets.length>0?A.componentOffsets.slice():null,P=A.featureIds.length>0?A.featureIds.slice():null,x=A.anchorIds.length>0?Array.from(A.anchorIds):null,_=A.anchors.length>0?Array.from(A.anchors):null,O=A.interleavedVertedData.slice().buffer,T=A.indicesType===a.IndexType.Int16?new Uint16Array(A.indices.buffer,A.indices.byteOffset,A.indices.byteLength/2).slice():new Uint32Array(A.indices.buffer,A.indices.byteOffset,A.indices.byteLength/4).slice(),N=A.positions.slice(),U=A.positionIndicesType===a.IndexType.Int16?new Uint16Array(A.positionIndices.buffer,A.positionIndices.byteOffset,A.positionIndices.byteLength/2).slice():new Uint32Array(A.positionIndices.buffer,A.positionIndices.byteOffset,A.positionIndices.byteLength/4).slice(),F={layout:t.layouts[0],interleavedVertexData:O,indices:T,hasColors:A.hasColors,hasModifications:A.hasModifications,positionData:{data:N,indices:U}};return P&&r.push(P.buffer),S&&r.push(S.buffer),r.push(O),r.push(T.buffer),r.push(N.buffer),r.push(U.buffer),{componentOffsets:S,featureIds:P,anchorIds:x,anchors:_,transformedGeometry:F,obb:A.obb}}function M(e){return 0===e?c.NodeIMModificationImpact.Unmodified:1===e?c.NodeIMModificationImpact.PotentiallyModified:2===e?c.NodeIMModificationImpact.Culled:c.NodeIMModificationImpact.Unknown}function A(e){if(!w)return;const{context:t,buffer:r}=e,o=w._malloc(r.byteLength),n=r.byteLength/Float64Array.BYTES_PER_ELEMENT,i=new Float64Array(w.HEAPU8.buffer,o,n),s=new Float64Array(r);i.set(s),w.filterOBBs(t,o,n),s.set(i),w._free(o)}function S(e){w&&0===w.destroy(e)&&(w=null)}function L(e,t){for(let r=0;r<t.length;++r)e[r]=t[r]}async function P(){w||await x()}function x(){return w?Promise.resolve(w):(h||(h=f.get().then((e=>(w=e,h=null,w)))),h)}const _={transform:(e,t)=>w&&I(w,e,t),destroy:S};t.destroyContext=g,t.dracoDecompressPointCloudData=u,t.filterObbsForModifications=d,t.filterObbsForModificationsSync=A,t.initialize=P,t.interpretObbModificationResults=M,t.process=l,t.project=p,t.setLegacySchema=m,t.setModifications=y,t.setModificationsSync=E,t.test=_,t.transformNormals=b,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
