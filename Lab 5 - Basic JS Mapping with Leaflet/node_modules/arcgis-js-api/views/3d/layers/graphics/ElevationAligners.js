/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/projection/computeTranslationToOriginAndRotation","../../../../geometry/projection/projectBuffer","./elevationAlignmentUtils","../../support/debugFlags","../../support/ElevationProvider","../../webgl-engine/lib/GeometryWithMapPositions","../../webgl-engine/lib/VertexAttribute"],(function(e,t,n,o,a,r,i,s,l,c,u,f){"use strict";function g(e,t,n,o,a){const r=e.stageObject,i=r.geometries;let s=0;for(const l of i){if(!u.isGeometryWithMapPositions(l))continue;const{update:e,averageGeometrySampledElevation:i}=E(l,t,n,o,a);s+=i,e&&r.geometryVertexAttributeUpdated(l,f.VertexAttribute.POSITION)}return s/i.length}function m(e,n,a,i,c,u){const f=e.stageObject,g=n.centerPointInElevationSR;let m=0;if(f.usesVerticalDistanceToGround)i(g,h),s.updateVertexPointGroundDistance(f,h.verticalDistanceToGround),m=h.sampledElevation;else{i(g,h);"absolute-height"!==n.mode&&(m=h.sampledElevation)}const d=t.copy(p,u??f.transformation),b=o.set(O,d[12],d[13],d[14]);l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=g.x,T[1]=g.y,T[2]=h.z,r.computeTranslationToOriginAndRotation(g.spatialReference,T,d,c.spatialReference)&&(u?t.copy(u,d):f.transformation=d)):c.setAltitudeOfTransformation(h.z,d);const S=I/c.unitInMeters;return(Math.abs(d[12]-b[0])>=S||Math.abs(d[13]-b[1])>=S||Math.abs(d[14]-b[2])>=S)&&(u?t.copy(u,d):f.transformation=d),m}const p=n.create();function d(e,t,n,a,i){const s=e.graphics3DSymbolLayer.lodRenderer;if(null==s)return 0;const c=t.centerPointInElevationSR;a(c,h);const u="absolute-height"!==t.mode?h.sampledElevation:0,f=s.instanceData,g=e.instanceIndex,m=v;f.getGlobalTransform(g,m);const p=o.set(O,m[12],m[13],m[14]);l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=c.x,T[1]=c.y,T[2]=h.z,r.computeTranslationToOriginAndRotation(c.spatialReference,T,m,i.spatialReference)&&f.setGlobalTransform(g,m)):i.setAltitudeOfTransformation(h.z,m);const d=I/i.unitInMeters;return(l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(m[12]-p[0])>=d||Math.abs(m[13]-p[1])>=d||Math.abs(m[14]-p[2])>=d)&&f.setGlobalTransform(g,m),u}function b(e,t,n,o,a){const r=e.stageObject,i=r.geometries;if(0===i.length)return 0;let s=0,l=null,c=0,g=!1;for(const m of i){if(!u.isGeometryWithMapPositions(m))continue;const e=m.attributes.get(f.VertexAttribute.POSITION);if(e!==l){const{update:r,averageGeometrySampledElevation:i}=E(m,t,n,o,a);c=i,l=e,g=r}g&&r.geometryVertexAttributeUpdated(m,f.VertexAttribute.POSITION),s+=c}return s/i.length}const I=.01,T=a.create(),S=a.create(),A=a.create(),v=n.create(),O=a.create(),h=new s.SampleElevationInfo;function E(e,t,n,o,a){let r=!1;const s=e.transformation,u=t.requiresSampledElevationInfo;S[0]=s[12],S[1]=s[13],S[2]=s[14],e.invalidateBoundingInfo();const g=e.getMutableAttribute(f.VertexAttribute.POSITION),m=g.data,p=g.size,d=m.length/p,b=new c.SamplePosition(e.mapPositions,n);let v=0,O=0;for(let c=0;c<d;c++){if(A[0]=m[v],A[1]=m[v+1],A[2]=m[v+2],o(b,h),u&&(O+=h.sampledElevation),l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS)m[v]=b.array[b.offset],m[v+1]=b.array[b.offset+1],m[v+2]=h.z,i.projectBuffer(m,n,v,m,a.spatialReference,v,1),m[v]-=S[0],m[v+1]-=S[1],m[v+2]-=S[2],r=!0;else{T[0]=m[v]+S[0],T[1]=m[v+1]+S[1],T[2]=m[v+2]+S[2],a.setAltitude(T,h.z),m[v]=T[0]-S[0],m[v+1]=T[1]-S[1],m[v+2]=T[2]-S[2];const e=I/a.unitInMeters;(Math.abs(A[0]-m[v])>=e||Math.abs(A[1]-m[v+1])>=e||Math.abs(A[2]-m[v+2])>=e)&&(r=!0)}v+=p,b.offset+=3}return O/=d,{update:r,averageGeometrySampledElevation:O}}e.perLodInstanceElevationAligner=d,e.perObjectElevationAligner=m,e.perVertexElevationAligner=g,e.sharedGeometryElevationAligner=b,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
