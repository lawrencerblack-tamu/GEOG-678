/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../core/Error","../../../../core/maybe","../../../../core/MemCache","../../../../core/promiseUtils","../../../../core/uuid","../../../../core/libs/gl-matrix-2/math/mat3","../../../../core/libs/gl-matrix-2/factories/mat3f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/projection/projectBoundingSphere","../../../../geometry/support/meshVertexSpaceUtils","../../../../chunks/sphere","./I3SClientMaterialUtil"],(function(e,t,o,r,n,s,a,i,l,d,c,u,m,h){"use strict";class f{constructor(e,t,o,r){this._uid=e,this._worker=r,this._id2Meta=new Map,this._oid2Meta=new Map,this._indexSR=t.indexSR,this._vertexSR=t.vertexSR,this._renderSR=t.renderSR,this._localMode=t.localMode,this._memCache=o.newCache(`sl-client-mesh-data-${this._uid}`)}get uid(){return this._uid}get worker(){return this._worker}get indexSR(){return this._indexSR}get renderSR(){return this._renderSR}createMeshNodeInfo(e,t){const o=`mesh${t}`,r=e.extent,n=r.spatialReference,s=this._indexSR,a=p(r,e.origin);c.projectBoundingSphere(a,n,a,s);return{type:"mesh",id:o,version:M(e),oid:t,mbs:a,componentNodeIds:[],unloadedMesh:e,nodeIndex:null,loadMeshPromise:null}}addMeshNode(e,o){if(null!=this.getMeshNodeIndex(o.oid))throw new t(`I3SClientNodeLoader: client side mesh for feature oid=${o.oid} already exists`);o.nodeIndex=e,this._id2Meta.set(o.id,o),this._oid2Meta.set(o.oid,o)}getMeshNodeIndex(e){const t=this._oid2Meta.get(e);return null==t||"mesh"!==t.type?null:t.nodeIndex}removeNode(e){const t=this._id2Meta.get(e);null!=t&&(this._id2Meta.delete(e),"mesh"===t.type&&this._oid2Meta.delete(t.oid))}async loadNodeJSON(e){const o=this._id2Meta.get(e);if(null==o)throw new t(`I3SClientNodeLoader::loadNodeJSON unable to find node ${e}`);switch(o.type){case"mesh":return this._loadMeshNodeJSON(o);case"mesh-component":return this._loadMeshComponentNodeJSON(o);default:throw new t(`I3SClientNodeLoader::loadNodeJSON unable to handle node ${e}`)}}async _loadMeshNodeJSON(e){const t=e.id,o=(await this._getMeshData(e)).loadedMesh;if(null==o.components||0===o.components.length)return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null};const r=[],n=o.components;for(let s=0;s<n.length;++s){const o=`${t}-component${s}`,n={type:"mesh-component",id:o,mbs:e.mbs,componentIndex:s,meshNodeInfo:e,textureData:new Map};this._id2Meta.set(n.id,n),e.componentNodeIds.push(o),r.push({id:n.id,href:null,mbs:n.mbs,obb:null})}return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:r}}updateNodeIndex(e,t,o){const r=this._id2Meta.get(e);r&&"mesh"===r.type&&(r.nodeIndex=o)}async _loadMeshComponentNodeJSON(e){return{id:e.id,version:e.meshNodeInfo.version,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null,isEmpty:!1}}async loadNodeData(e,r){const s=this._id2Meta.get(e);if(null==s||"mesh-component"!==s.type)throw new t(`Failed to load client node data for node ${e} (unexpected node info)`);const a=s.meshNodeInfo,i=await this._getMeshData(a),l=i.loadedMesh,d=a.oid;if(null==l.components)throw new t(`Failed to load client node data for node ${e} (unexpected null reference)`);const c=l.components[s.componentIndex],{material:u,requiredTextures:m,textureData:f}=await h.convertMeshMaterialToPBRMaterial(c.material);if(null!=f)for(const t of f)null!=t&&s.textureData.set(t.id,t);const p={params:{material:u},type:"ArrayBufferView"},{vertexSpace:g,origin:M,transform:S}=l,b=[M.x,M.y,M.z??0],_={featureDataPosition:b,featureIds:[],geometries:[p]},w={attributeData:{},loadedAttributes:[]};i.projectionPromise||(o.assertIsSome(this._worker,"SceneLayerWorker is needed to project mesh"),i.projectionPromise=this._worker.project({positions:l.vertexAttributes.position,localMatrix:S?.localMatrix,vertexSpace:g.toJSON(),origin:b,inSpatialReference:l.spatialReference.toJSON(),outSpatialReference:this._vertexSR.toJSON(),localMode:this._localMode},r));const{projected:N,original:I}=await i.projectionPromise;l.vertexAttributes.position=I;const{transformed:v,original:D}=await x(c,i,this._worker,r);l.vertexAttributes.normal=D,n.throwIfAborted(r);const{geometryBuffer:R,geometryDescriptor:A}=y(N,c.faces,v,l.vertexAttributes.uv,l.vertexAttributes.color,d);return{geometryData:_,attributeDataInfo:w,geometryBuffer:R,geometryDescriptor:A,requiredTextures:m,textureData:f,normalReferenceFrame:this._vertexSR.isGeographic?"east-north-up":"vertex-reference-frame"}}async loadAttributes(e,t,o){const r=e.numFeatures,n={};for(const{field:{name:s}}of t)n[s]=new Array(r);return n}async loadTextures(e,t,o){const r=e.id,n=this._id2Meta.get(r);if(null==n||"mesh-component"!==n.type)throw new Error(`Failed to load textures for node ${e.id} (unexpected node info)`);const s=[];for(const a of t)s.push(n.textureData.get(a.id)||null);return s}async _getMeshData(e){const t=e.version,o=this._memCache.get(t);if(null==o){if(null!=e.loadMeshPromise)return e.loadMeshPromise;const o=async(o,n)=>{const s=e.unloadedMesh.clone();try{await s.load()}catch(l){n(l)}const a=s.memoryUsage,i={loadedMesh:s,projectionPromise:null,normalsTransformPromise:null,usedMemoryInBytes:a};this._memCache.put(t,i,a,r.MinPriority),e.loadMeshPromise=null,o(i)};return e.loadMeshPromise=new Promise(((e,t)=>o(e,t))),e.loadMeshPromise}return o}}function p(e,t){const{spatialReference:o}=e,r=[1,-1],n=[.5*e.width,.5*e.height,e.hasZ?.5*(e.zmax-e.zmin):0],s=o.isGeographic?o.metersPerUnit:1,a=e.center;let i=0;if(e.hasZ)for(let l=0;l<2;++l)for(let e=0;e<2;++e)for(let o=0;o<2;++o){const d=(a.x+r[l]*n[0]-t.x)*s,c=(a.y+r[e]*n[1]-t.y)*s,u=a.z+r[o]*n[2]-t.z;i=Math.max(d*d+c*c+u*u,i)}else for(let l=0;l<2;++l)for(let e=0;e<2;++e){const o=(a.x+r[l]*n[0]-t.x)*s,d=(a.y+r[e]*n[1]-t.y)*s;i=Math.max(o*o+d*d,i)}return m.fromCenterAndRadius([t.x,t.y,t.z],Math.sqrt(i))}async function x(e,t,r,n){const{transform:s,vertexAttributes:c}=t.loadedMesh,u="source"===e.shading?c.normal:null;if(!(null!=u&&null!=s&&(0!==s.rotationAngle||!l.exactEquals(s.scale,d.ONES))))return{transformed:u,original:c.normal};if(!t.normalsTransformPromise){o.assertIsSome(r,"SceneLayerWorker is needed to transform mesh normals");const e=i.create();a.normalFromMat4(e,s.localMatrix),t.normalsTransformPromise=r.transformNormals({normalMatrix:e,normals:u},n)}return t.normalsTransformPromise}function y(e,t,o,r,n,s){const a=1,i=t.length/3,l=3*i;let d=0,c=0,u=!1,m=0,h=!1,f=0,p=!1,x=0,y=0,M=0;d+=S,d+=S,c=d,d+=3*l*b,null!=o&&(u=!0,m=d,d+=3*l*b),null!=r&&(h=!0,f=d,d+=2*l*b),null!=n&&(p=!0,x=d,d+=4*l*_),y=d,d+=a*w,M=d,d+=2*a*S;const N=new ArrayBuffer(d),I=new Uint8Array(N);g(I,0,l),g(I,S,a);const v=new Float32Array(N,c),D=null!=o?new Float32Array(N,m):null,R=null!=r?new Float32Array(N,f):null,A=null!=n?new Uint8Array(N,x):null;for(let g=0;g<i;++g){const s=3*g;for(let a=0;a<3;++a){const i=t[s+a],l=3*i,d=9*g+3*a;if(v[d]=e[l],v[d+1]=e[l+1],v[d+2]=e[l+2],null!=D&&(D[d]=o[l],D[d+1]=o[l+1],D[d+2]=o[l+2]),null!=R){const e=2*i,t=6*g+2*a;R[t]=r[e],R[t+1]=r[e+1]}if(null!=A){const e=4*i,t=12*g+4*a;A[t]=n[e],A[t+1]=n[e+1],A[t+2]=n[e+2],A[t+3]=n[e+3]}}}g(I,y,s),g(I,y+S,s/2**32),g(I,M,0),g(I,M+S,i-1);return{geometryBuffer:N,geometryDescriptor:{isDraco:!1,isLegacy:!0,color:p,normal:u,uv0:h,uvRegion:!1,featureIndex:!0}}}function g(e,t,o){e[t]=255&o,e[t+1]=255&o>>8,e[t+2]=255&o>>16,e[t+3]=255&o>>24}function M(e){const t=e.metadata.displaySource?.source;if(null==t||!Array.isArray(t)||!t.length||t[0]instanceof File)return s.generateUUID();const o=t;let r="";for(const n of o)r+=n.makeHash();return r+JSON.stringify(null!=e.transform?e.transform.toJSON():"")+(u.isRelativeVertexSpace(e.vertexSpace)?JSON.stringify(e.vertexSpace.origin):"")}const S=4,b=4,_=1,w=8;e.I3SClientNodeLoader=f,e.createSphereFromExtent=p,e.sizeOfFloat32=b,e.sizeOfInt32=S,e.sizeOfUInt64=w,e.sizeOfUInt8=_,e.transformNormals=x,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
