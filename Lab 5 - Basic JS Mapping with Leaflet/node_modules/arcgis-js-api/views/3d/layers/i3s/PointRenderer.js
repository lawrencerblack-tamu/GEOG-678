/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/tslib.es6","../../../../core/maybe","../../../../core/PooledArray","../../../../core/accessorSupport/decorators/property","../../../../core/has","../../../../core/Logger","../../../../core/RandomLCG","../../../../core/accessorSupport/decorators/subclass","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../chunks/vec42","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/plane","../../../../geometry/support/ray","./Intersector","./PointHighlights","../../webgl-engine/core/shaderLibrary/ShaderOutput","../../webgl-engine/effects/RenderPlugin","../../webgl-engine/lib/DefaultVertexAttributeLocations","../../webgl-engine/lib/Intersector","../../webgl-engine/lib/IntersectorInterfaces","../../webgl-engine/lib/RenderSlot","../../webgl-engine/lib/VertexArrayObject","../../webgl-engine/lib/VertexAttribute","../../../../chunks/PointRenderer.glsl","../../webgl-engine/shaders/PointRendererTechnique","../../webgl-engine/shaders/PointRendererTechniqueConfiguration","../../../webgl/BufferObject","../../../webgl/enums","../../../webgl/VertexElementDescriptor"],(function(e,t,s,i,r,n,o,a,l,h,c,u,d,p,g,_,P,m,f,b,S,R,x,y,w,z,A,q,O,T,v){"use strict";const I={positions:[new v.VertexElementDescriptor(w.VertexAttribute.POSITION,3,T.DataType.FLOAT,0,12)],colors:[new v.VertexElementDescriptor(w.VertexAttribute.COLOR,3,T.DataType.UNSIGNED_BYTE,0,3,!0)]};e.PointRenderer=class extends f.SyncPrepareRenderPlugin{constructor(e){super(e),this.type=R.IntersectorType.PCL,this.isGround=!1,this._passParameters=new z.PointRendererPassParameters,this._highlights=new P.PointHighlights({forEachNode:e=>this.forEachNode(e),addHighlight:(e,t,s)=>this._addHighlight(e,t,s),removeHighlight:(e,t)=>this._removeHighlight(e,t)}),this.produces=new Map([[x.RenderSlot.OPAQUE_MATERIAL,e=>e!==m.ShaderOutput.LinearDepth&&(e!==m.ShaderOutput.Highlight||!this._highlights.empty)],[x.RenderSlot.OPAQUE_NO_SSAO_DEPTH,e=>e===m.ShaderOutput.LinearDepth]]),this.layerUid="",this._slicePlaneEnabled=!1,this._techniqueConfig=new q.PointRendererTechniqueConfiguration,this._nodes=new i}initializeRenderContext(e){this._context=e,e.requestRender()}uninitializeRenderContext(){}intersect(e,t,s,i){const r=c.create(),n=c.create(),o=c.create(),a=c.create(),l=p.create(),P=e.camera.perScreenPixelRatio/2,m=e.camera.near;h.subtract(n,i,s);const f=1/h.length(n);h.scale(n,n,f),h.negate(o,n),u.set(l,n[0],n[1],n[2],-h.dot(n,s));const b=new B,x=new B,y=new Array,w=d.create(),z=d.create(this._passParameters.clipBox);d.offset(z,-s[0],-s[1],-s[2],z),this._nodes.forAll((c=>{const u=c.splatSize*this._passParameters.scaleFactor;let p=c.obb.minimumDistancePlane(l),g=c.obb.maximumDistancePlane(l);p-=N(u,p+m,this._passParameters,P,c.isLeaf),g-=N(u,g+m,this._passParameters,P,c.isLeaf);const _=g<0,S=null!=b.dist&&null!=x.dist&&b.dist<p*f&&x.dist>g*f;if(_||S)return;const A=D(u,g+m,this._passParameters,P,c.isLeaf);if(!c.obb.intersectRay(s,n,A))return;const q=A*A;c.obb.toAaBoundingBox(w),d.offset(w,-s[0],-s[1],-s[2],w);const O=!d.contains(z,w);h.subtract(a,c.origin,s);const T=c.coordinates.length/3;for(let l=0;l<T;l++){if(r[0]=a[0]+c.coordinates[3*l],r[1]=a[1]+c.coordinates[3*l+1],r[2]=a[2]+c.coordinates[3*l+2],O&&!d.containsPoint(z,r))continue;const p=h.dot(r,n),g=h.squaredLength(r)-p*p;if(g>q)continue;let _=p+m;const S=N(u,_,this._passParameters,P,c.isLeaf);if(p-S<0)continue;_-=S;const w=D(u,_,this._passParameters,P,c.isLeaf);if(g>w*w)continue;const A=(p-S)*f,T=e=>(e.point=C(c,l,e.point),e.dist=A,e.normal=o,e.node=c,e.pointId=l,e.layerUid=this.layerUid,e);if((null==b.dist||A<b.dist)&&(null==t||t(s,i,A))&&T(b),e.options.store!==R.StoreResults.MIN&&(null==x.dist||A>x.dist)&&(null==t||t(s,i,A))&&T(x),e.options.store===R.StoreResults.ALL&&(null==t||t(s,i,A))){const e=new B;y.push(T(e))}}}));const A=e=>{const{layerUid:t,node:s,pointId:i}=e;return new _.PclTarget(e.point,t,i,(()=>this.createGraphic(s,i,e.point)))},q=(e,t)=>{const s=A(t);e.set(this.type,s,t.dist,t.normal)};if(V(b)){const t=e.results.min;(null==t.dist||b.dist<t.dist)&&q(t,b)}if(V(x)&&e.options.store!==R.StoreResults.MIN){const t=e.results.max;(null==t.dist||x.dist>t.dist)&&q(t,x)}if(e.options.store===R.StoreResults.ALL){const t=g.fromPoints(s,i);for(const s of y){const i=S.newIntersectorResult(t);q(i,s),e.results.all.push(i)}}}prepareTechnique(e){return 0===this._nodes.length||e.output!==m.ShaderOutput.Color&&(e.output!==m.ShaderOutput.LinearDepth||e.bindParameters.slot!==x.RenderSlot.OPAQUE_NO_SSAO_DEPTH)&&e.output!==m.ShaderOutput.Highlight?null:(this._nodes.forAll((t=>{null==t.vao&&this._initNode(e,t)})),this._techniqueConfig.drawScreenSize=this._passParameters.drawScreenSpace,this._techniqueConfig.useFixedSizes=this._passParameters.useFixedSizes,this._techniqueConfig.hasSlicePlane=this._slicePlaneEnabled,this._techniqueConfig.hasOccludees=e.bindParameters.hasOccludees,this._techniqueConfig.clippingEnabled=this._clippingEnabled,this._techniqueConfig.output=e.output,this._context.techniqueRepository.releaseAndAcquire(A.PointRendererTechnique,this._techniqueConfig,this._technique))}renderNode(e,t){const s=e.rctx,i=s.bindTechnique(t,e.bindParameters,this._passParameters),r=e.output===m.ShaderOutput.Highlight;this._nodes.forAll((t=>{0===t.coordinates.length||r&&!t.highlights||(i.bindDraw(t,e.bindParameters,this._passParameters),s.bindVAO(t.vao),r?this._renderHighlightFragments(s,t):s.drawArrays(T.PrimitiveType.POINTS,0,t.coordinates.length/3))}))}_renderHighlightFragments(e,t){const s=t.highlights;if(null==s)return;let i=s[0].component,r=i+1;for(let o=1;o<s.length;o++){const t=s[o].component;if(t!==r){const s=r-i;s>0&&e.drawArrays(T.PrimitiveType.POINTS,i,s),i=t}r=t+1}const n=r-i;n>0&&e.drawArrays(T.PrimitiveType.POINTS,i,n)}set useFixedSizes(e){this._passParameters.useFixedSizes!==e&&(this._passParameters.useFixedSizes=e,this._requestRender())}get useFixedSizes(){return this._passParameters.useFixedSizes}set scaleFactor(e){this._passParameters.scaleFactor!==e&&(this._passParameters.scaleFactor=e,this._requestRender())}get scaleFactor(){return this._passParameters.scaleFactor}set minSizePx(e){this._passParameters.minSizePx!==e&&(this._passParameters.minSizePx=e,this._requestRender())}get minSizePx(){return this._passParameters.minSizePx}set useRealWorldSymbolSizes(e){this._passParameters.useRealWorldSymbolSizes!==e&&(this._passParameters.useRealWorldSymbolSizes=e,this._requestRender())}get useRealWorldSymbolSizes(){return this._passParameters.useRealWorldSymbolSizes}set size(e){this._passParameters.size!==e&&(this._passParameters.size=e,this._requestRender())}get size(){return this._passParameters.size}set sizePx(e){this._passParameters.sizePx!==e&&(this._passParameters.sizePx=e,this._requestRender())}get sizePx(){return this._passParameters.sizePx}set clippingBox(e){d.set(this._passParameters.clipBox,e||d.positiveInfinity)}get _clippingEnabled(){return!d.equals(this._passParameters.clipBox,d.positiveInfinity,((e,t)=>e===t))}get slicePlaneEnabled(){return this._slicePlaneEnabled}set slicePlaneEnabled(e){this._slicePlaneEnabled!==e&&(this._slicePlaneEnabled=e,this._requestRender())}addNode(e){this._nodes.push(e),this._highlights.nodeAdded(e),this._requestRender()}removeNode(e){let t=null;return this._nodes.filterInPlace((i=>i.id!==e||(t=i,i.vao=s.disposeMaybe(i.vao),this._highlights.nodeRemoved(i),!1))),this._requestRender(),t}forEachNode(e){this._nodes.forAll(e)}removeAll(){this._nodes.forAll((e=>e.vao=s.disposeMaybe(e.vao))),this._highlights.removeAll(),this._nodes.clear(),this._requestRender()}highlight(e){return this._highlights.add(e)}_addHighlight(e,t,s){e.highlights=H(e.highlights,t,s),this._requestRender()}_removeHighlight(e,t){e.highlights=M(e.highlights,t),this._requestRender()}_initNode(e,t){const s=e.rctx;t.vao=new y.VertexArrayObject(s,b.Default3D,I,{positions:O.BufferObject.createVertex(s,T.Usage.STATIC_DRAW,t.coordinates),colors:O.BufferObject.createVertex(s,T.Usage.STATIC_DRAW,t.rgb)})}_requestRender(){this._context&&this._context.requestRender()}},t.__decorate([r.property({constructOnly:!0})],e.PointRenderer.prototype,"createGraphic",void 0),e.PointRenderer=t.__decorate([l.subclass("esri.views.3d.layers.i3s.PointRenderer")],e.PointRenderer);class E extends z.PointRendererDrawParameters{constructor(e,t,s,i,r,n,o,a,l=null,h=null){super(s,r,t),this.id=e,this.obb=i,this.coordinates=n,this.rgb=o,this.attributes=a,this.pointIdFilterMap=l,this.highlights=h}}function L(e){return e.hasOwnProperty("splatSize")}function D(e,t,s,i,r){if(s.drawScreenSpace)return s.fixedSize*t*i;const n=z.getMaxPointSizeScreenspace(r)*t*i;return s.useFixedSizes?Math.min(s.fixedSize/2,n):s.screenMinSize>0?Math.min(Math.max(s.screenMinSize*t*i,e/2),n):Math.min(e/2,n)}function N(e,t,s,i,r){return s.drawScreenSpace?0:D(e,t,s,i,r)}function C(e,t,s){return null==s&&(s=c.create()),s[0]=e.origin[0]+e.coordinates[3*t],s[1]=e.origin[1]+e.coordinates[3*t+1],s[2]=e.origin[2]+e.coordinates[3*t+2],s}function F(e){return null!=e.component?e.component:-1}function H(e,t,s){null==e&&(e=[]);const i={component:t,id:s};e.push(i);const r=F(i);let n=e.length-1;for(;n>0&&r<F(e[n-1]);)[e[n-1],e[n]]=[e[n],e[n-1]],--n;return e}function M(e,t){if(null==e)return e;const s=e.filter((e=>e.id!==t));return 0===s.length?null:s}class B{constructor(){this.node=null,this.pointId=null,this.point=null,this.dist=null,this.normal=null,this.layerUid=""}}function V(e){return null!=e.dist&&null!=e.point&&null!=e.pointId&&null!=e.node}e.PointRendererNode=E,e.isPointRendererNode=L,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
