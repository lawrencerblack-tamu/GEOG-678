/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../chunks/vec42","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../geometry/ellipsoidUtils","../../../../geometry/spatialReferenceEllipsoidUtils","../../../../geometry/projection/projectBoundingSphere","../../../../geometry/projection/projectors","../../../../geometry/support/frustum","../../../../geometry/support/spatialReferenceUtils","../../../../chunks/sphere","../../../../layers/graphics/dehydratedPoint","../../../ViewingMode","../graphics/elevationAlignmentUtils","../graphics/ElevationContext","../graphics/featureExpressionInfoUtils","./I3SNode","./I3SUtil","../../support/orientedBoundingBox"],(function(e,t,i,s,n,r,o,a,c,l,h,d,u,p,_,m,g,v,S){"use strict";const b=1e5;class R{constructor(e,i,o,h,u,p,_,m,g={}){this._indexSR=e,this._renderCoordsHelper=i,this._clippingArea=u,this._elevationProvider=p,this._viewingMode=_,this._options=g,this._frustum=c.create(),this._frustumMbs=s.create(),this._useFrustumCulling=!1,this._poi=t.create(),this._elevationContext=null,this.minDistance=1/0,this.maxDistance=0,this.maxLodLevel=2,this._tmpObb=new S.Obb,this._tmp1=t.create(),this._tmp2=t.create(),this._tmp3=t.create(),this._tmp0=t.create(),this._screenspaceErrorBias=g.screenspaceErrorBias||1,this._progressiveLoadFactor=g.progressiveLoadFactor||1,this.updateCamera(o,h);const v=this._renderCoordsHelper.spatialReference;this._renderSR=v,this._renderSRSphericalPCPF=r.getSphericalPCPF(v),this._isGlobalMode=v===this._renderSRSphericalPCPF,this.updateElevationInfo(m),this._tmpPoint=d.makeDehydratedPoint(0,0,0,e),this._isECEFOBBInLocalMode=this._indexSR.isWGS84&&(v.isWebMercator||l.isPlateCarree(v)),this._indexSREllipsoidRadius=n.getReferenceEllipsoid(this._indexSR).radius,this._indexSRSphericalPCPF=r.getSphericalPCPF(e),this._projectorIndexSRToIndexSRSphericalPCPF=a.getProjector(this._indexSR,this._indexSRSphericalPCPF)}updateElevationInfo(e){null!=e?(this._elevationContext=_.ElevationContext.fromElevationInfo(e),this._elevationContext.updateFeatureExpressionInfoContext(m.createContextWithoutExpressionSupport(m.extractExpressionInfo(e,!1)))):this._elevationContext=null}updateCamera(t,i){if(this._useFrustumCulling=i,i){c.fromMatrix(t.viewMatrix,t.projectionMatrix,this._frustum,x);{const i=t.eye,s=f;e.normalize(s,t.viewForward);const n=x,r=M;e.sub(r,n[4],i);const o=.5*e.dot(r,r)/e.dot(s,r),a=this._frustumMbs,c=a;e.scaleAndAdd(c,i,s,o);const l=1+o;a[3]=l}}this._screenSizeFactor=1/(t.perScreenPixelRatio/2),this._camPos=t.eye,this.minDistance=1/0,this.maxDistance=0}setPointOfInterest(e){this._poi=e}updateScreenSpaceErrorBias(e){const t=this._screenspaceErrorBias;return this._screenspaceErrorBias=e,t}updateClippingArea(e){this._clippingArea=e}expandElevationRange(e,t,i){if(null==this._elevationContext)return;const s=e.serviceMbsInIndexSR;if(!s)return;const n="relative-to-scene"===this._elevationContext.mode?"scene":"ground";if(this._elevationProvider.getSphereElevationBounds){const e=this._elevationProvider.getSphereElevationBounds(s,this._indexSR,n);return void(e&&i.expandElevationRange(e))}const r=s[0],o=s[1],a=s[2],c=this._elevationProvider.getElevation(r,o,a,this._indexSR,n);c&&i.expandElevationRangeValues(c,c);const l=t?null:this._elevationProvider.getRootElevationBounds?.();l&&i.expandElevationRange(l)}getServiceMbsInRenderSR(e){const t=e.serviceMbsInRenderSR;if(v.isValidMbs(t))return t;e.serviceMbsInIndexSR&&i.copy(t,e.serviceMbsInIndexSR);const s=e.elevationRangeMin;if(this._elevationContext&&Number.isFinite(s)){let i=0,n=0;const r=e.elevationRangeMax;switch(this._elevationContext.mode){case"relative-to-ground":i=this._elevationContext.geometryZWithOffset(t[2],this._renderCoordsHelper)+s-t[2],n=r-s;break;case"on-the-ground":i=s-t[2],n=r-s}t[2]+=i+.5*n,t[3]+=.5*n}else this._elevationContext&&t[3]<b&&(this._tmpPoint.x=t[0],this._tmpPoint.y=t[1],this._tmpPoint.z=t[2],t[2]=p.evaluateElevationAlignmentAtPoint(this._tmpPoint,this._elevationProvider,this._elevationContext,this._renderCoordsHelper));return o.projectBoundingSphere(t,this._indexSR,t,this._renderSR),t}getAndUpdateVisibilityObbInRenderSR(e){{const t=e.visibilityObbInRenderSR;if(t)return t}const t=.01*this._indexSREllipsoidRadius,{serviceMbsInIndexSR:i,serviceObbInIndexSR:s}=e;if(null==s||!i||!s.isValid||this._isECEFOBBInLocalMode&&(s.halfSizeX>t||s.halfSizeY>t||s.halfSizeZ>t))return null;{let t=e.serviceObbInRenderSR;if(null==t)t=new S.Obb,e.serviceObbInRenderSR=t;else if(t.isValid)return t;const n=i[3];let r=0,o=0;const a=s.centerZ,c=this._renderCoordsHelper,l=this._elevationContext;if(l&&e.elevationRangeValid){const t=e.elevationRangeMin,i=e.elevationRangeMax;switch(l.mode){case"relative-to-ground":r=l.geometryZWithOffset(a,c)+t-a,o=i-t;break;case"on-the-ground":r=t-a,o=i-t}}else if(l&&n<b){const e=this._tmpPoint;e.x=s.centerX,e.y=s.centerY,e.z=a,r=p.evaluateElevationAlignmentAtPoint(e,this._elevationProvider,l,c)-a}const h=o>0,d=h?this._tmpObb:t;return s.transform(d,this._indexSR,this._renderSR,r,this._renderSRSphericalPCPF,this._indexSRSphericalPCPF,this._projectorIndexSRToIndexSRSphericalPCPF),h&&S.computeOffsetObb(d,0,o,this._viewingMode,t),t}}getNodeObbInRenderSRIndependentOfElevationOffset(e){{const t=e.visibilityObbInRenderSR??e.serviceObbInRenderSR??null;if(t?.isValid)return t}const t=e.serviceObbInIndexSR;return t?(t.transform(I,this._indexSR,this._renderSR,void 0,this._renderSRSphericalPCPF,this._indexSRSphericalPCPF,this._projectorIndexSRToIndexSRSphericalPCPF),I):null}ensureElevationAgnosticBoundingVolume(e,t){-1===e.elevationAgnosticBoundingVolume[3]&&(t===u.ViewingMode.Global?this._updateElevationAgnosticBoundingVolumeGlobal(e):this._updateElevationAgnosticBoundingVolumeLocal(e))}_updateElevationAgnosticBoundingVolumeGlobal(t){const s=this.getNodeObbInRenderSRIndependentOfElevationOffset(t),n=t.elevationAgnosticBoundingVolume,r=P;let o=-1;if(s){s.getCenter(r),e.normalize(r,r),s.getCorners(E);for(const t of E){e.normalize(t,t);const i=e.dot(t,r);if(i<=0)return void(n[3]=-1);const s=Math.sqrt(1-i*i);o=Math.max(o,s)}}else{const i=t.serviceMbsInRenderSR;if(!v.isValidMbs(i))return void(n[3]=-1);{const t=e.copy(P,h.getCenter(i)),s=i[3],n=e.len(t);o=0===s?0:n<s?-1:s/n,e.normalize(t,t)}}i.copyVec3(n,r);const a=.001;n[3]=o+a}_updateElevationAgnosticBoundingVolumeLocal(t){const s=t.elevationAgnosticBoundingVolume,n=this.getNodeObbInRenderSRIndependentOfElevationOffset(t);if(n){const t=n.getCenter(P);t[2]=0,i.copyVec3(s,t);let r=0;const o=D;n.getCorners(E);for(const i of E){i[2]=0;const t=e.sqrDist(o,i);r=Math.max(r,t)}s[3]=Math.sqrt(r)}else{const n=t.serviceMbsInRenderSR;if(v.isValidMbs(n)){const t=e.copy(P,h.getCenter(n));t[2]=0,i.copyVec3(s,t),s[3]=n[3]}}}isNodeVisible(e){const t=this.getServiceMbsInRenderSR(e);if(!this._isMBSinClippingArea(t))return!1;if(!this._useFrustumCulling)return!0;const i=this.getAndUpdateVisibilityObbInRenderSR(e);return i?i.isVisible(this._frustum):c.intersectsSphere(this._frustum,h.wrap(t))}isElevationAgnosticBoundingVolumeVisible(e,t){return!this._useFrustumCulling||(-1===t[3]||(e===u.ViewingMode.Global?this._isConeVisibleInFrustum(t):this._isCylinderVisibleInFrustum(t)))}_isConeVisibleInFrustum(t){const i=this._frustumMbs,s=i,n=e.len(s),r=i[3],o=t,a=e.dot(o,s),c=t[3];if(c>.9)return!0;if(n<=r)return!0;{const t=e.scale(C,o,a);if(e.dist(t,s)<r)return!0}const l=a/n;if(a<=0){return-l<r}const h=Math.sqrt(1-l*l);if(h<c)return!0;const d=r/n;return h*Math.sqrt(1-d*d)-d*l<c}_isCylinderVisibleInFrustum(t){const i=this._frustumMbs,s=i,n=i[3],r=e.copy(C,s);r[2]=0;const o=t[3],a=t;return e.dist(r,a)<=o+n}isGeometryVisible(e){if(!this._useFrustumCulling)return!0;const t=e.geometryObbInRenderSR;return t?.isVisible(this._frustum)??this.isNodeVisible(e)}_isMBSinClippingArea(e){return null==this._clippingArea||v.intersectBoundingRectWithMbs(this._clippingArea,e)!==v.MbsIntersectResult.OUTSIDE}_screenSpaceDiameterMbs(t,i){const s=this.getServiceMbsInRenderSR(t),n=Math.sqrt(e.squaredDistance(h.getCenter(s),this._camPos)),r=n-s[3];return this._updateMinMaxDistance(n),r<0?.5*Number.MAX_VALUE:i/r*this._screenSizeFactor}calcCameraDistance(e){return this.calcCameraDistanceToCenter(e)-this.getServiceMbsInRenderSR(e)[3]}calcCameraDistanceToCenter(t){const i=this.getServiceMbsInRenderSR(t),s=e.distance(h.getCenter(i),this._camPos);return this._updateMinMaxDistance(s),s}calcAngleDependentLoD(t){const i=this.getServiceMbsInRenderSR(t),s=i[3],n=(Math.abs(i[0]*(i[0]-this._camPos[0])+i[1]*(i[1]-this._camPos[1])+i[2]*(i[2]-this._camPos[2]))/e.length(h.getCenter(i))+s)/e.distance(h.getCenter(i),this._camPos);return Math.min(1,n)}hasLOD(e){return e.lodMetric!==g.LodMetric.None}_getDistancePlanarMode(e,t){const i=e[0]-t[0],s=e[1]-t[1],n=e[2]-t[2],r=i*i+s*s,o=t[3];if(r<=o*o)return Math.abs(n);const a=Math.sqrt(r)-o;return Math.sqrt(n*n+a*a)}_getDistanceGlobeMode(t,i){const s=e.length(h.getCenter(i)),n=e.length(t)-s;e.scale(this._tmp0,t,e.dot(t,h.getCenter(i))/e.squaredLength(t));const r=e.squaredDistance(h.getCenter(i),this._tmp0),o=i[3];if(r<=o*o)return Math.abs(n);{const r=e.scale(this._tmp0,h.getCenter(i),1/s),a=s,c=o*o/2/a,l=e.scale(this._tmp1,r,a-c),d=t,u=e.subtract(this._tmp2,d,l),p=e.subtract(this._tmp2,u,e.scale(this._tmp3,r,e.dot(r,u))),_=e.add(this._tmp2,l,e.scale(this._tmp2,p,o/e.length(p)));let m=e.distance(d,_);if(n>=2e5){const t=e.subtract(this._tmp1,d,_);let i=e.dot(t,r)/e.length(t);i<.08&&(i=1e-4),m/=i}return m}}_getDistance(e,t){return this._isGlobalMode?this._getDistanceGlobeMode(e,t):this._getDistancePlanarMode(e,t)}_updateMinMaxDistance(e){e>0?(this.minDistance=Math.min(this.minDistance,e),this.maxDistance=Math.max(this.maxDistance,e)):(this.minDistance=0,this.maxDistance=Math.max(this.maxDistance,-e))}getLodLevel(e){if(e.lodMetric===g.LodMetric.None)return 0;if(0===e.childCount)return this.maxLodLevel;if(this._useFrustumCulling&&this._progressiveLoadFactor<1){const t=this._progressiveLoadFactor*this._screenspaceErrorBias,i=this._screenspaceErrorBias;return this.evaluateLODmetric(e,t)?this.evaluateLODmetric(e,i)?2:1:0}return this.evaluateLODmetric(e,this._screenspaceErrorBias)?this.maxLodLevel:0}evaluateLODmetric(e,t){switch(e.lodMetric){case g.LodMetric.ScreenSpaceRelative:{const i=this.getServiceMbsInRenderSR(e),s=this._getDistance(this._camPos,i),n=2*s/this._screenSizeFactor,r=s+i[3];return this._updateMinMaxDistance(r),e.maxError*t<=n}case g.LodMetric.MaxScreenThreshold:{let i=this._screenSpaceDiameterMbs(e,e.serviceMbsInIndexSR[3]*t);return this._options.angleDependentLoD&&(i*=this.calcAngleDependentLoD(e)),i<e.maxError}case g.LodMetric.RemovedFeatureDiameter:return this._screenSpaceDiameterMbs(e,e.maxError)*t<10;case g.LodMetric.DistanceRangeFromDefaultCamera:return this.calcCameraDistance(e)>e.maxError*t}return!1}distToPOI(t){const i=this.getServiceMbsInRenderSR(t);return e.distance(h.getCenter(i),this._poi)-i[3]}distCameraToPOI(){return e.distance(this._camPos,this._poi)}}const f=t.create(),x=c.createPoints(),M=t.create(),C=t.create(),I=new S.Obb,P=t.create(),E=[t.create(),t.create(),t.create(),t.create(),t.create(),t.create(),t.create(),t.create()],D=t.create();return R}));
