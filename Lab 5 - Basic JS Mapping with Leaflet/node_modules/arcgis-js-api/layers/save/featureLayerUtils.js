/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../core/arrayUtils","../../core/Error","../../core/accessorSupport/originUtils","./utils","../support/arcgisLayerUrl","../support/fetchService","../support/layerUtils","../support/lazyLayerLoader","../../portal/support/portalItemUtils"],(function(e,r,a,t,o,n,s,i,l,y){"use strict";const c="Feature Service",u="feature-layer-utils",p=`${u}-save`,d=`${u}-save-as`,f=`${u}-saveall`,m=`${u}-saveall-as`;function w(e){return{isValid:i.isLayerWithFeatureLayerSource(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function h(e){const r=[],a=[];for(const{layer:t,layerJSON:o}of e)t.isTable?a.push(o):r.push(o);return{layers:r,tables:a}}function v(e){return h([e])}async function g(e,r){return/\/\d+\/?$/.test(e.url)?v(r[0]):S(r,e)}async function S(e,r){if(e.reverse(),!r)return h(e);const a=await T(r,e);for(const t of e)$(t.layer,t.layerJSON,a);return b(a,e),a}async function T(e,r){let a=await e.fetchData("json");if(I(a))return a;a||={},L(a);const{layer:{url:t,customParameters:o,apiKey:n}}=r[0];return await E(a,{url:t??"",customParameters:o,apiKey:n},r.map((e=>e.layer.layerId))),a}function I(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}function L(e){e.layers||=[],e.tables||=[]}function b(e,r){const a=[],t=[];for(const{layer:o}of r){const{isTable:e,layerId:r}=o;e?t.push(r):a.push(r)}A(e.layers,a),A(e.tables,t)}function A(e,a){if(e.length<2)return;const t=[];for(const{id:r}of e)t.push(r);r.equals(t.sort(P),a.slice().sort(P))&&e.sort(((e,r)=>{const t=a.indexOf(e.id),o=a.indexOf(r.id);return t<o?-1:t>o?1:0}))}function P(e,r){return e<r?-1:e>r?1:0}async function E(e,r,a){const{url:t,customParameters:o,apiKey:n}=r,{serviceJSON:i,layersJSON:l}=await s.fetchFeatureService(t,{customParameters:o,apiKey:n}),y=K(e.layers,i.layers,a),c=K(e.tables,i.tables,a);e.layers=y.itemResources,e.tables=c.itemResources;const u=[...y.added,...c.added],p=l?[...l.layers,...l.tables]:[];await O(e,u,t,p)}function K(e,a,t){const o=r.difference(e,a,((e,r)=>e.id===r.id));e=e.filter((e=>!o.removed.some((r=>r.id===e.id))));const n=o.added;return n.forEach((({id:r})=>{e.push({id:r})})),{itemResources:e,added:n.filter((({id:e})=>!t.includes(e)))}}async function O(e,r,a,t){const o=await x(r),n=r.map((({id:e,type:r})=>new(o.get(r))({url:a,layerId:e,sourceJSON:t.find((({id:r})=>r===e))})));await Promise.allSettled(n.map((e=>e.load()))),n.forEach((r=>{const{layerId:a,loaded:t,defaultPopupTemplate:o}=r;if(!t||null==o)return;const n={id:a,popupInfo:o.toJSON()};"ArcGISFeatureLayer"!==r.operationalLayerType&&(n.layerType=r.operationalLayerType),$(r,n,e)}))}async function x(e){const r=[];e.forEach((({type:e})=>{const a=N(e),t=l.layerLookupMap[a];r.push(t())}));const a=await Promise.all(r),t=new Map;return e.forEach((({type:e},r)=>{t.set(e,a[r])})),t}function N(e){let r;switch(e){case"Feature Layer":case"Table":r="FeatureLayer";break;case"Oriented Imagery Layer":r="OrientedImageryLayer";break;case"Catalog Layer":r="CatalogLayer"}return r}function $(e,r,a){e.isTable?F(a.tables,r):F(a.layers,r)}function F(e,r){const a=e.findIndex((({id:e})=>e===r.id));-1===a?e.push(r):e[a]=r}function J(e,r){if(!e.length)throw new a(`${r}:missing-parameters`,"'layers' array should contain at least one feature layer")}function M(e,r){const t=e.map((e=>e.portalItem.id));if(new Set(t).size>1)throw new a(`${r}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(e,r){const t=e.map((e=>e.layerId));if(new Set(t).size!==t.length)throw new a(`${r}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function C(e){J(e,f),await Promise.all(e.map((e=>e.load())));for(const r of e)o.ensureLayerConfig(r,f,w),o.ensureItemConfig({layer:r,itemType:c,errorNamePrefix:f});M(e,f),U(e,f)}async function R(e,r){const{url:a,layerId:t,title:o,fullExtent:s,isTable:i}=e,l=n.parse(a);r.url="FeatureServer"===l?.serverType?a:`${a}/${t}`,r.title||=o,r.extent=null,i||null==s||(r.extent=await y.getWGS84ExtentForItem(s)),y.removeTypeKeyword(r,y.typeKeyword.METADATA),y.removeTypeKeyword(r,y.typeKeyword.MULTI_LAYER),y.addTypeKeyword(r,y.typeKeyword.SINGLE_LAYER),i&&y.addTypeKeyword(r,y.typeKeyword.TABLE)}function D(e,r){for(const l of e){const t=l.parsedUrl.path,s=n.parse(t),i=s?.url.path;if(!i)throw new a(`${r}:invalid-parameters`,o.createErrorMessage(l,`has unsupported url pattern: ${t}`),{layer:l});const y=s?.serverType;if("FeatureServer"!==y&&"MapServer"!==y)throw new a(`${r}:invalid-parameters`,o.createErrorMessage(l,`has unsupported server type: ${y}`),{layer:l});if("MapServer"===y&&e.length>1)throw new a(`${r}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=n.parse(e[0].parsedUrl.path),s=t?.url.path,i=e.every((e=>{const r=n.parse(e.parsedUrl.path);return r?.url.path===s}));if(!i)throw new a(`${r}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function G(e){J(e,m),await Promise.all(e.map((e=>e.load())));for(const r of e)o.ensureLayerConfig(r,m,w);D(e,m),U(e,m)}async function W(e,a){let t=0,s=0;for(const{isTable:r}of a)r?s++:t++;const i=a[0].parsedUrl.path,l=n.parse(i);if(e.url="FeatureServer"===l?.serverType?l.url.path:i,e.title||=l.title,e.extent=null,t>0){const t=a.map((e=>e.fullExtent)).filter(r.isSome).reduce(((e,r)=>e.clone().union(r)));t&&(e.extent=await y.getWGS84ExtentForItem(t))}y.removeTypeKeyword(e,y.typeKeyword.METADATA),y.toggleTypeKeyword(e,y.typeKeyword.MULTI_LAYER,a.length>1),y.toggleTypeKeyword(e,y.typeKeyword.SINGLE_LAYER,1===a.length),y.toggleTypeKeyword(e,y.typeKeyword.TABLE,s>0&&0===t),o.setCommonItemProperties(e)}async function Y(e,r){const a={layer:e,itemType:c,validateLayer:w,createItemData:(e,r)=>g(r,[e]),errorNamePrefix:p};return o.save(a,r)}async function _(e,r){await C(e);const a=e[0].portalItem,n=o.createJSONContextForWrite(a),s=await Promise.all(e.map((e=>o.getLayerJSON(e,n,r)))),i=await g(a,e.map(((e,r)=>({layer:e,layerJSON:s[r]}))));return o.setCommonItemProperties(a),await a.update({data:i}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),t.updateOrigins(n),a.clone()}async function k(e,r,a){const t={layer:e,itemType:c,validateLayer:w,createItemData:(e,r)=>Promise.resolve(v(e)),errorNamePrefix:d,newItem:r,setItemProperties:R};return o.saveAs(t,a)}async function z(e,r,a){await G(e);const n=o.getPortalItem({itemType:c,errorNamePrefix:m,newItem:r}),s=o.createJSONContextForWrite(n),i=await Promise.all(e.map((e=>o.getLayerJSON(e,s,a)))),l=await S(e.map(((e,r)=>({layer:e,layerJSON:i[r]}))));await W(n,e),await o.addItem(n,l,a);for(const t of e)t.portalItem=n.clone();return t.updateOrigins(s),n}e.save=Y,e.saveAll=_,e.saveAllAs=z,e.saveAs=k,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
