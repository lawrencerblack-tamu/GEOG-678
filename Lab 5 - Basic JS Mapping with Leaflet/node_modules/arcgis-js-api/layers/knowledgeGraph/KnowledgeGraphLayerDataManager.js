/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../chunks/tslib.es6","../../geometry","../../core/Accessor","../../core/Error","../../core/Logger","../../core/MapUtils","../../core/sql","../../core/accessorSupport/decorators/property","../../core/has","../../core/RandomLCG","../../core/accessorSupport/decorators/subclass","../../geohash/geohashUtils","../../geometry/Polygon","../../geometry/projection","../../geometry/support/spatialReferenceUtils","./SessionMemoryStorage","./supportUtils","../../rest/knowledgeGraphService","../../rest/knowledgeGraph/GraphQueryStreaming","../../rest/support/Query","../../geometry/Extent"],(function(e,t,n,i,o,a,r,s,p,d,l,h,c,m,y,u,g,f,w,b,T,D){"use strict";const M="ESRI__ID",I="ESRI__ORIGIN_ID",k="ESRI__DESTINATION_ID",L="ESRI__LAYOUT_GEOMETRY",E="ESRI__AGGREGATION_COUNT",C=12;e.KnowledgeGraphLayerDataManager=class extends i{constructor(e){super(e),this._processingCacheUpdatesLookup=new Map,this.knowledgeGraph=null,this.inclusionModeDefinition={generateAllSublayers:!0,namedTypeDefinitions:new Map},this.entityTypeNames=new Set,this.relationshipTypeNames=new Set,this.geographicLookup=new Map,this.sublayerCaches=new Map,this.nodeConnectionsLookup=new Map,this.relationshipConnectionsLookup=new Map,this.memberIdTypeLookup=new Map;const t=new Map;e.knowledgeGraph.dataModel.entityTypes?.forEach((n=>{n.name&&(t.set(n.name,"entity"),this._processingCacheUpdatesLookup.set(n.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.entityTypeNames.add(n.name),n.properties?.forEach((e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(n.name,{name:e.name??"",geometryType:e.geometryType})})))})),e.knowledgeGraph.dataModel.relationshipTypes?.forEach((n=>{n.name&&(t.set(n.name,"relationship"),this._processingCacheUpdatesLookup.set(n.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.relationshipTypeNames.add(n.name),n.properties?.forEach((e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(n.name,{name:e.name??"",geometryType:e.geometryType})})))})),e.inclusionModeDefinition?.namedTypeDefinitions.forEach(((n,i)=>{if("entity"===t.get(i))this.entityTypeNames.add(i);else{if("relationship"!==t.get(i))return a.getLogger(this).warn(`A named type, ${i}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(i);this.relationshipTypeNames.add(i)}const o=new Map;n.members?.forEach((e=>{r.getOrCreateMapValue(this.memberIdTypeLookup,e.id,(()=>new Set)).add(i);const t=this.getById(e.id);t&&o.set(e.id,t)})),this.sublayerCaches.set(i,o)}))}addToLayer(e){e.forEach((({typeName:e,id:t})=>{if(!this.inclusionModeDefinition)throw new o("knowledge-graph:layer-data-manager","You cannot add to a layer's exclusion list if it was not created with an exclusion list originally");if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){const n=this.inclusionModeDefinition.namedTypeDefinitions.get(e);n.members||(n.members=new Map),n.members.set(t,{id:t}),r.getOrCreateMapValue(this.memberIdTypeLookup,t,(()=>new Set)).add(e)}}else{const n=new Map;n.set(t,{id:t}),this.inclusionModeDefinition.namedTypeDefinitions.set(e,{useAllData:!1,members:n}),r.getOrCreateMapValue(this.memberIdTypeLookup,t,(()=>new Set)).add(e)}}))}getById(e){return g.getInstance().readFromStoreById(e)}async getData(e,t,n){if(t.objectType.name&&this.inclusionModeDefinition?.namedTypeDefinitions&&this.inclusionModeDefinition.namedTypeDefinitions.size>0&&!this.inclusionModeDefinition.namedTypeDefinitions.has(t.objectType.name))return[];let i;if(i=e||new T({where:"1=1",outFields:["*"]}),"link-chart"===t.parentCompositeLayer.type){const e=t.parentCompositeLayer,n=this._processingCacheUpdatesLookup.get(t.objectType.name??""),o=i.outFields,a=i.geometry;let r="",s="";a&&a.extent&&(r=c.encodeGeohash(a.extent.ymin,a.extent.xmin,C),s=c.encodeGeohash(a.extent.ymax,a.extent.xmax,C)),o&&1===o.length&&o[0]===M&&"1=1"===i.where||await Promise.all(n??[]);const p=this.sublayerCaches.has(t.objectType.name??"")?Array.from(this.sublayerCaches.get(t.objectType.name)?.values()):[],d=[];return p.forEach((n=>{if(this.relationshipTypeNames.has(t.objectType.name)?n.geometry=e.relationshipLinkChartDiagramLookup.get(n.attributes[t.objectIdField]):n.geometry=e.entityLinkChartDiagramLookup.get(n.attributes[t.objectIdField]),n.attributes[L]=n.geometry,r&&s){const i=e.linkChartGeohashLookup.get(n.attributes[t.objectIdField]);i?i>=r&&i<=s&&d.push(n):d.push(n)}else d.push(n)})),d}return this.retrieveDataFromService(i,t,n)}async getConnectedRecordIds(e,t){const n=[];let i="";const o=[],r=new Map;if(e.forEach((e=>{if(this.memberIdTypeLookup.has(e))for(const t of this.memberIdTypeLookup.get(e)){if(!this.entityTypeNames.has(t))return;r.has(t)?r.get(t)?.push(e):r.set(t,[e])}})),t&&0!==t?.length){for(const e of t)i=i+e+"|";i=i.slice(0,-1)}return r.forEach(((e,r)=>{let s;s=t&&0!==t?.length?`MATCH (n:${r})-[r:${i}]-(m) WHERE id(n) IN $ids RETURN id(r), type(r), id(m), labels(m)[0]`:`MATCH (n:${r})-[r]-(m) WHERE id(n) IN $ids RETURN id(r), type(r), id(m), labels(m)[0]`;const p=new Promise((t=>{(async()=>{const t=(await w.executeQueryStreaming(this.knowledgeGraph,new b({openCypherQuery:s,bindParameters:{ids:e}}))).resultRowsStream.getReader();try{for(;;){const{done:e,value:i}=await t.read();if(e)break;for(let t=0;t<i.length;t++){const e=i[t];n.push({id:e[0],typeName:e[1]}),n.push({id:e[2],typeName:e[3]})}}}catch(i){if("AbortError"!==i.name)throw i;a.getLogger(this).info("Request aborted as expected")}})().then((()=>{t()}))}));o.push(p)})),this.refreshCacheContent(),await Promise.all(o),n}async refreshCacheContent(e,t,n,i=!0){const a=g.getInstance(),s=[],p=new Map,d=new Map;this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&d.set(e.name,e)})),this.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&d.set(e.name,e)})),e||this.inclusionModeDefinition?e?e.forEach((e=>{if(this.memberIdTypeLookup.has(e))for(const t of this.memberIdTypeLookup.get(e))p.has(t)?p.get(t)?.push(e):p.set(t,[e])})):this.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((e,t)=>{e.useAllData?p.set(t,null):e.members&&e.members.forEach((e=>{p.has(t)&&null!==p.get(t)?p.get(t)?.push(e.id):p.set(t,[e.id])}))})):(this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&p.set(e.name,null)})),this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&p.set(e.name,null)})));for(const[l,h]of p){const e=new Promise((e=>{(async()=>{const e=new Set,s=[];let p,c="",m=!1;if(t||d.get(l)?.properties?.forEach((t=>{t.name&&e.add(t.name)})),n&&this.geographicLookup.has(l)){const t=this.geographicLookup.get(l)?.name;t&&e.add(t)}if(this.entityTypeNames.has(l))c=`MATCH (n:${l}) ${h?"WHERE id(n) IN $ids ":""}return ID(n)`,e.forEach((e=>{c+=`, n.${e}`,s.push(e)}));else{if(!this.relationshipTypeNames.has(l))throw new o("knowledge-graph:layer-data-manager",`The graph type of ${l} could not be determined. Was this type set in the KG data model and inclusion definition?`);m=!0,c=`MATCH ()-[n:${l}]->() ${h?"WHERE id(n) IN $ids ":""}return ID(n), id(startNode(n)), id(endNode(n))`,e.forEach((e=>{c+=`, n.${e}`,s.push(e)}))}p=new b(h?{openCypherQuery:c,bindParameters:{ids:h}}:{openCypherQuery:c});const y=(await w.executeQueryStreaming(this.knowledgeGraph,p)).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await y.read();if(e)break;const n=[];for(let i=0;i<t.length;i++){const e=t[i];let o=0,a=0;const p={properties:{}};for(p.id=e[o],o++,a++,m&&(p.originId=e[o],o++,a++,p.destinationId=e[o],o++,a++,r.getOrCreateMapValue(this.nodeConnectionsLookup,p.originId,(()=>new Set)).add(p.id),r.getOrCreateMapValue(this.nodeConnectionsLookup,p.destinationId,(()=>new Set)).add(p.id),r.getOrCreateMapValue(this.relationshipConnectionsLookup,p.id,(()=>[p.originId,p.destinationId])));o<e.length;o++)p.properties[s[o-a]]=e[o];n.push(p)}const o=a.writeToStore(n,M,this.geographicLookup.get(l)?.name);this.sublayerCaches.has(l)||this.sublayerCaches.set(l,new Map),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.has(l)&&this.inclusionModeDefinition?.namedTypeDefinitions.set(l,{useAllData:!1,members:new Map}),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(l).members&&(this.inclusionModeDefinition.namedTypeDefinitions.get(l).members=new Map);const p=this.sublayerCaches.get(l);o.forEach((e=>{p?.set(e.attributes[M],e),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(l).members.has(e.attributes[M])&&(this.inclusionModeDefinition?.namedTypeDefinitions.get(l).members.set(e.attributes[M],{id:e.attributes[M]}),r.getOrCreateMapValue(this.memberIdTypeLookup,e.attributes[M],(()=>new Set)).add(l))}))}})().then((()=>{e(null)}))}));s.push(e),this._processingCacheUpdatesLookup.get(l)?.push(e)}await Promise.all(s)}removeFromLayer(e){const t=new Set,n=new Set(e.map((e=>e.id)));for(const i of e)t.add(i.typeName),1===this.memberIdTypeLookup.get(i.id)?.size?this.memberIdTypeLookup.delete(i.id):this.memberIdTypeLookup.get(i.id)?.delete(i.typeName),this.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{t===i.typeName&&e.members?.has(i.id)&&e.members.delete(i.id)}));t.forEach((e=>{this.sublayerCaches.get(e)?.forEach(((t,i)=>{n.has(i)&&this.sublayerCaches.get(e)?.delete(i)}))}))}async retrieveDataFromService(e,t,n){const i=g.getInstance(),a=new Set,r=[];let p,d="",l=[];const h="relationship"===t.graphType,c=this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData,T=t.parentCompositeLayer.sublayerIdsCache.get(t.objectType.name);let I=!c&&T?Array.from(T).sort():null;if(this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData)this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData&&null!=e.objectIds&&(I=e.objectIds);else if(null!=e.objectIds&&I&&I.length>0){const t=e.objectIds;e.objectIds=I.filter((e=>t.includes(e)))}else if(null!=e.objectIds)I=e.objectIds;else{if(this.inclusionModeDefinition?.namedTypeDefinitions.has(t.objectType.name)&&(!this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members||this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members?.size<1))return e.objectIds=[],[];e.objectIds=I}if(null!=e.outFields){const n=e.outFields;n.includes("*")?t.fields.forEach((e=>{a.add(e.name)})):n.forEach((e=>{e!==M&&e!==t.geometryFieldName&&a.add(e)}))}if(null!=e.geometry){const n=e.geometry;let i;const l=t.parentCompositeLayer.dataManager.knowledgeGraph.serviceDefinition,c=l?.spatialReference,g=l?.serviceCapabilities?.geometryCapabilities;let w=g?.geometryMaxBoundingRectangleSizeX,T=g?.geometryMaxBoundingRectangleSizeY;if(n?.extent?.spatialReference&&!n.spatialReference?.isWGS84?(await y.initializeProjection(n.extent.spatialReference,u.wgs84),i=y.project(n.extent,u.wgs84)):i=n.extent,w&&T&&c){if(4326!==c.wkid){const e=new D({spatialReference:c,xmax:w,ymax:T}),t=y.project(e,u.wgs84);w=t.xmax,T=t.ymax}if(i.xmax-i.xmin>w)throw new o("knowledge-graph:layer-data-manager",`Extent x bounds should be within ${w}° latitude, limit exceeded`);if(i.ymax-i.ymin>T)throw new o("knowledge-graph:layer-data-manager",`Extent y bounds should be within ${T}° longitude, limit exceeded`)}if(null!=e.where&&"1=1"!==e.where){const n=await s.parseWhereClause(e.where.toUpperCase(),t.fieldsIndex);t.fields.forEach((e=>{n.fieldNames.includes(e.name)&&a.add(e.name)}))}d=h?`Match ()-[n:${t.objectType.name}]->() WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n), id(startNode(r)), id(endNode(r))`:`Match (n:${t.objectType.name}) WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n)`,t.geometryFieldName&&a.add(t.geometryFieldName),a.forEach((e=>{d+=`, n.${e}`,r.push(e)})),p=new b({openCypherQuery:d,bindParameters:{param_filter_geom:new m({rings:f.extentToInBoundsRings(i)})}})}else{let n="";if(null!=e.where&&"1=1"!==e.where){const i=await s.parseWhereClause(e.where,t.fieldsIndex);t.fields.forEach((e=>{i.fieldNames.includes(e.name)&&a.add(e.name)}));const o=new Set(["column-reference","string","number","binary-expression"]),r=new Set(["=","<","<=","<>",">",">=","AND","OR","LIKE"]);let p=!1;const d=e=>{if("column-reference"===e.type)return`n.${e.column}`;if("string"===e.type)return`'${e.value}'`;if("number"===e.type)return`${e.value}`;if("binary-expression"===e.type&&o.has(e.left.type)&&o.has(e.right.type)&&r.has(e.operator))return`${d(e.left)} ${e.operator} ${d(e.right)}`;if("binary-expression"===e.type&&"LIKE"===e.operator){let t="";if("function"===e.left.type&&"column-reference"===e.left.args.value[0].type)t+=`lower(n.${e.left.args.value[0].column})`;else{if("column-reference"!==e.left.type)return p=!0,"";t+=`lower(n.${e.left.column})`}if(t+=" CONTAINS (","string"!==e.right.type)return p=!0,"";{let n=e.right.value;"%"===n.charAt(0)&&(n=n.slice(1)),"%"===n.charAt(n.length-1)&&(n=n.slice(0,-1)),t+=`'${n.toLowerCase()}')`}return t}return p=!0,""};n=d(i.parseTree),p&&(n="")}let i="";i=h?`Match ()-[n:${t.objectType.name}]->()`:`Match (n:${t.objectType.name})`;let o=!1;I&&(o=!0,i+=" WHERE ID(n) IN $ids"),n&&(i+=o?" AND":" WHERE",i+=` ${n}`),i+=" return ID(n)",h&&(i+=", id(startNode(n)), id(endNode(n))"),e.returnGeometry&&t.geometryFieldName&&a.add(t.geometryFieldName),a.forEach((e=>{i+=`, n.${e}`,r.push(e)})),p=new b(I?{openCypherQuery:i,bindParameters:{ids:I}}:{openCypherQuery:i})}const k=(await w.executeQueryStreaming(t.parentCompositeLayer.dataManager.knowledgeGraph,p,n)).resultRowsStream.getReader();for(;;){const{done:e,value:n}=await k.read();if(e)break;const o=[];for(let t=0;t<n.length;t++){const e=n[t];let i=0,a=0;const s={properties:{}};for(s.id=e[i],i++,a++,h&&(s.originId=e[i],i++,a++,s.destinationId=e[i],i++,a++);i<e.length;i++)s.properties[r[i-a]]=e[i];o.push(s)}l=l.concat(i.writeToStore(o,M,t.parentCompositeLayer.dataManager.geographicLookup.get(t.objectType.name)?.name))}return l}},t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"knowledgeGraph",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"inclusionModeDefinition",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"entityTypeNames",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"relationshipTypeNames",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"geographicLookup",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"sublayerCaches",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"nodeConnectionsLookup",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"relationshipConnectionsLookup",void 0),t.__decorate([p.property()],e.KnowledgeGraphLayerDataManager.prototype,"memberIdTypeLookup",void 0),e.KnowledgeGraphLayerDataManager=t.__decorate([h.subclass("esri.rest.knowledgeGraph.knowledgeGraphLayer.KnowledgeGraphLayerDataManager")],e.KnowledgeGraphLayerDataManager),e.geohashEncodingPrecision=C,e.mockAggregationCountFieldName=E,e.mockDestinationIdFieldName=k,e.mockLayoutGeometryFieldName=L,e.mockOidFieldName=M,e.mockOriginIdFieldName=I,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
