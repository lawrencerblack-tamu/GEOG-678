/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/Error","../../../core/sql/WhereClauseCache","../../support/fieldType"],(function(e,i,t,r){"use strict";const s=new t.WhereClauseCache(50,500),n="unsupported-query",a=" as ",o=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),l=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),d=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...o,...l]);function p(e,t,r={}){const a=f(t,e);if(!a){const r=s.getError(t,e);throw new i(n,"invalid SQL expression",{expression:t,error:r})}const o=r.expressionName||"expression";if(r.validateStandardized&&!a.isStandardized)throw new i(n,`${o} is not standard`,{expression:t});if(r.validateAggregate&&!a.isAggregate)throw new i(n,`${o} does not contain a valid aggregate function`,{expression:t});return a.fieldNames}function c(e,i,t,r){if(!t)return!0;const s="where clause";return m(e,i,p(e,t,{validateStandardized:!0,expressionName:s}),{expressionName:s,query:r}),!0}function u(e,t,r,s,a){if(!r)return!0;const o="having clause",l=p(e,r,{validateAggregate:!0,expressionName:o});m(e,t,l,{expressionName:o,query:a});const d=f(r,e),c=d?.getExpressions().every((i=>{const{aggregateType:t,field:r}=i,n=e.get(r)?.name;return s.some((i=>{const{onStatisticField:r,statisticType:s}=i,a=e.get(r)?.name;return a===n&&s.toLowerCase().trim()===t}))}));if(!c)throw new i(n,"expressions in having clause should also exist in outStatistics",{having:r});return!0}function f(e,i){return e?s.get(e,i):null}function y(e){return/\((.*?)\)/.test(e)?e:e.split(a)[0]}function g(e){return e.split(a)[1]}function m(e,t,r,s={}){const a=new Map;if(T(a,e,t,s.allowedFieldTypes??d,r),a.size){const e=s.expressionName??"expression";throw new i(n,`${e} contains invalid or missing fields`,{errors:Array.from(a.values()),query:s.query})}}function T(e,i,t,r,s){const n=s.includes("*")?[...t,...s.filter((e=>"*"!==e))]:s;for(const o of n){if(i.get(o))F(e,i,t,r,o);else try{const s=p(i,y(o),{validateStandardized:!0});for(const n of s)F(e,i,t,r,n)}catch(a){e.set(o,{type:"expression-error",expression:o,error:a})}}}function F(e,i,t,s,n){const a=i.get(n);a?t.has(a.name)?"all"!==s&&!1===s?.has(a.type)&&e.set(n,{type:"invalid-type",fieldName:a.name,fieldType:r.kebabDict.fromJSON(a.type),allowedFieldTypes:Array.from(s,(e=>r.kebabDict.fromJSON(e)))}):e.set(n,{type:"missing-field",fieldName:a.name}):e.set(n,{type:"invalid-field",fieldName:n})}e.allDateAndTimeFieldTypes=l,e.getAliasFromFieldName=g,e.getExpressionFromFieldName=y,e.getWhereClause=f,e.numericFieldTypes=o,e.validateFields=m,e.validateHaving=u,e.validateWhere=c,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
