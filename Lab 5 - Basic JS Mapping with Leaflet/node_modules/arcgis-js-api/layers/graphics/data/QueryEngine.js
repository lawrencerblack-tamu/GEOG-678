/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/arrayUtils","../../../core/Error","../../../core/JSONSupport","../../../core/lang","../../../core/maybe","../../../core/MemCache","../../../core/promiseUtils","../../../core/unitUtils","../../../geometry/projection","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/boundsUtils","../../../geometry/support/jsonUtils","../../../geometry/support/normalizeUtils","../../../geometry/support/spatialReferenceUtils","../featureConversionUtils","./attributeSupport","./geometryUtils","./projectionSupport","./QueryEngineCapabilities","./QueryEngineResult","./queryUtils","./queryValidationUtils","./spatialQuerySupport","./timeSupport","../../support/FieldsIndex","../../../views/support/Scheduler"],(function(e,t,i,s,r,a,n,l,u,o,h,c,y,m,d,p,g,f,x,_,w,F,S,R,Q,E,I,O){"use strict";const b="unsupported-query";class A{constructor(e,t=null,i,s,r){this.attributes=e,this.geometry=i,this.centroid=s,this.filterFlags=r,this.groupId=-1,this.displayId=t}}const v=new n.MemCacheStorage(2e6);let T=0;class M{constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:w.queryCapabilities},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new n.MemCache(T+++"$$",v)),this.fieldsIndex=s.isSerializable(e.fieldsIndex)?e.fieldsIndex:I.fromJSON(e.fieldsIndex),!e.availableFields||1===e.availableFields.length&&"*"===e.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map((e=>e.name))):this.availableFields=new Set(e.availableFields.map((e=>this.fieldsIndex.get(e)?.name)).filter((e=>null!=e))),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=a.removeMaybe(this._frameTask),this.clearCache(),a.destroyMaybe(this._geometryQueryCache),this._changeHandle=a.removeMaybe(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){this._geometryQueryCache?.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){const i=l.signalFromSignalOrOptions(t);try{return(await this._executeQuery(e,{},i)).createQueryResponse()}catch(s){if(s!==S.queryEngineEmptyResult)throw s;return new F.QueryEngineResult([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){const i=l.signalFromSignalOrOptions(t);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},i)).createQueryResponseForCount()}catch(s){if(s!==S.queryEngineEmptyResult)throw s;return 0}}async executeQueryForExtent(e,t){const i=l.signalFromSignalOrOptions(t),s=e.outSR;try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),r=t.size;if(!r)return{count:0,extent:null};return{count:r,extent:await this._getBounds(t.items,t.spatialReference,s||this.spatialReference)}}catch(r){if(r===S.queryEngineEmptyResult)return{count:0,extent:null};throw r}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){const i=l.signalFromSignalOrOptions(t);try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=t.items,r=new Set;return await this._reschedule((()=>{for(const e of s)r.add(t.featureAdapter.getObjectId(e))}),i),r}catch(s){if(s===S.queryEngineEmptyResult)return new Set;throw s}}async executeQueryForSnapping(e,t){const i=l.signalFromSignalOrOptions(t),{point:s,distance:a,returnEdge:n,vertexMode:u}=e;if(!n&&"none"===u)return{candidates:[]};let o=r.clone(e.query);o=await this._schedule((()=>S.normalizeQueryLike(o,this.definitionExpression,this.spatialReference)),i),o=await this._reschedule((()=>R.validateQuery(o,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const h=!p.equals(s.spatialReference,this.spatialReference);h&&await _.checkProjectionSupport(s.spatialReference,this.spatialReference);const c="number"==typeof a?a:a.x,y="number"==typeof a?a:a.y,g={xmin:s.x-c,xmax:s.x+c,ymin:s.y-y,ymax:s.y+y,spatialReference:s.spatialReference},f=h?_.project(g,this.spatialReference):g;if(!f)return{candidates:[]};const x=(await d.normalizeCentralMeridian(m.fromJSON(s),null,{signal:i}))[0],w=(await d.normalizeCentralMeridian(m.fromJSON(f),null,{signal:i}))[0];if(null==x||null==w)return{candidates:[]};const Q=new F.QueryEngineResult(await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(w.toJSON()))),i),o,this);await this._reschedule((()=>this._executeObjectIdsQuery(Q)),i),await this._reschedule((()=>this._executeTimeQuery(Q)),i),await this._reschedule((()=>this._executeAttributesQuery(Q)),i),await this._reschedule((()=>this._executeGeometryQueryForSnapping(Q,i)),i);const E=x.toJSON(),I=h?_.project(E,this.spatialReference):E,O=h?Math.max(f.xmax-f.xmin,f.ymax-f.ymin)/2:a;return Q.createSnappingResponse({...e,point:I,distance:O},s.spatialReference)}async executeQueryForLatestObservations(e,t){const s=l.signalFromSignalOrOptions(t);if(!this.timeInfo?.trackIdField)throw new i(b,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const t=await this._executeQuery(e,{},s);return await this._reschedule((()=>this._filterLatest(t)),s),t.createQueryResponse()}catch(r){if(r!==S.queryEngineEmptyResult)throw r;return new F.QueryEngineResult([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const s=l.signalFromSignalOrOptions(i),{field:r,normalizationField:a,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:a,valueExpression:n},s)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const s=l.signalFromSignalOrOptions(i),{field:r,field2:a,field3:n,valueExpression:u}=t;return(await this._executeQueryForStatistics(e,{field:r,field2:a,field3:n,valueExpression:u},s)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const s=l.signalFromSignalOrOptions(i),{field:r,normalizationField:a,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:a,valueExpression:n},s)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const s=l.signalFromSignalOrOptions(i),{field:r,normalizationField:a,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:a,valueExpression:n},s)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const t=l.signalFromSignalOrOptions(e);this._timeExtentPromise||=E.getTimeExtent(this.timeInfo,this.featureStore);const[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return l.throwIfAborted(t),{fullExtent:i,timeExtent:s}}async _getBounds(e,t,i){const s=h.set(h.create(),h.negativeInfinity);await this.featureStore.forEachBounds(e,(e=>h.expandWithAABB(s,e)));const r={xmin:s[0],ymin:s[1],xmax:s[3],ymax:s[4],spatialReference:x.cleanFromGeometryEngine(this.spatialReference)};this.hasZ&&isFinite(s[2])&&isFinite(s[5])&&(r.zmin=s[2],r.zmax=s[5]);const a=_.project(r,t,i);if(a.spatialReference=x.cleanFromGeometryEngine(i),a.xmax-a.xmin==0){const e=u.getMetersPerUnitForSR(a.spatialReference);a.xmin-=e,a.xmax+=e}if(a.ymax-a.ymin==0){const e=u.getMetersPerUnitForSR(a.spatialReference);a.ymin-=e,a.ymax+=e}if(this.hasZ&&null!=a.zmin&&null!=a.zmax&&a.zmax-a.zmin==0){const e=u.getMetersPerUnitForSR(a.spatialReference);a.zmin-=e,a.zmax+=e}return a}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((e=>this._getBounds(e,this.spatialReference,this.spatialReference))),this._fullExtentPromise}async _schedule(e,t){return null!=this._frameTask?this._frameTask.schedule(e,t):e(O.noBudget)}async _reschedule(e,t){return null!=this._frameTask?this._frameTask.reschedule(e,t):e(O.noBudget)}async _getAllFeaturesQueryEngineResult(e){return new F.QueryEngineResult(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((t=>e.push(t)))})().then((()=>e))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=r.clone(e),e=await this._schedule((()=>S.normalizeQuery(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>R.validateQuery(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i),e={...e,...t};const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}async _executeSceneFilterQuery(e,t){if(null==e.sceneFilter)return null;const{outSR:i,returnGeometry:s,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,l=null==a||p.equals(a,n.spatialReference)?n:_.project(n,a);if(!l)return null;const u=s||r,o=p.isValid(i)&&!p.equals(this.spatialReference,i)&&u?async e=>this._project(e,i):e=>e,h=this.featureAdapter,c=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(l))),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!c.length)return null;const i=new Set;for(const e of c)i.add(h.getObjectId(e));const s=await this._reschedule((()=>this._getAllFeatures()),t),r=await this._reschedule((async()=>{const r=await Q.getSpatialQueryOperator("esriSpatialRelDisjoint",l,this.geometryType,this.hasZ,this.hasM),a=e=>!i.has(h.getObjectId(e))||r(h.getGeometry(e)),n=await this._runSpatialFilter(s,a,t);return new F.QueryEngineResult(n,e,this)}),t);return o(r)}if(!c.length)return new F.QueryEngineResult([],e,this);if(this._canExecuteSinglePass(l,e))return o(new F.QueryEngineResult(c,e,this));const y=await Q.getSpatialQueryOperator("esriSpatialRelContains",l,this.geometryType,this.hasZ,this.hasM),m=await this._runSpatialFilter(c,(e=>y(h.getGeometry(e))),t);return o(new F.QueryEngineResult(m,e,this))}async _executeGeometryQuery(e,i,s){if(null!=i&&0===i.items.length)return i;e=null!=i?i.query:e;const{geometry:r,outSR:a,spatialRel:n,returnGeometry:l,returnCentroid:u}=e,o=this.featureStore.featureSpatialReference,h=!r||null==o||p.equals(o,r.spatialReference)?r:_.project(r,o),c=l||u,y=p.isValid(a)&&!p.equals(this.spatialReference,a),m=this._geometryQueryCache&&null==i?y&&c?JSON.stringify({originalFilterGeometry:r,spatialRelationship:n,outSpatialReference:a}):JSON.stringify({originalFilterGeometry:r,spatialRelationship:n}):null,d=m?this._geometryQueryCache.get(m):null;if(null!=d)return new F.QueryEngineResult(d,e,this);const g=async e=>(y&&c&&await this._project(e,a),m&&this._geometryQueryCache.put(m,e.items,e.items.length+1),e);if(!h)return g(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const f=this.featureAdapter;let x=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(r))),s);if("esriSpatialRelDisjoint"===n){if(!x.length)return g(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const t=new Set;for(const e of x)t.add(f.getObjectId(e));const r=null!=i?i.items:await this._reschedule((()=>this._getAllFeatures()),s),a=await this._reschedule((async()=>{const i=await Q.getSpatialQueryOperator(n,h,this.geometryType,this.hasZ,this.hasM),a=e=>!t.has(f.getObjectId(e))||i(f.getGeometry(e)),l=await this._runSpatialFilter(r,a,s);return new F.QueryEngineResult(l,e,this)}),s);return g(a)}if(null!=i){const e=new t.PositionHint;x=x.filter((s=>t.indexOf(i.items,s,i.items.length,e)>=0))}if(!x.length){const t=new F.QueryEngineResult([],e,this);return m&&this._geometryQueryCache.put(m,t.items,1),t}if(this._canExecuteSinglePass(h,e))return g(new F.QueryEngineResult(x,e,this));const w=await Q.getSpatialQueryOperator(n,h,this.geometryType,this.hasZ,this.hasM),S=await this._runSpatialFilter(x,(e=>w(f.getGeometry(e))),s);return g(new F.QueryEngineResult(S,e,this))}async _executeGeometryQueryForSnapping(e,t){const{query:i}=e,{spatialRel:s}=i;if(!e?.items?.length||!i.geometry||!s)return;const r=await Q.getSpatialQueryOperator(s,i.geometry,this.geometryType,this.hasZ,this.hasM),a=await this._runSpatialFilter(e.items,(e=>r(e.geometry)),t);e.items=a}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds?.length||null==this.aggregateAdapter)return;const t=new Set;for(const s of e.query.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(s).forEach((e=>t.add(e)))}const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const t=E.getTimeOperator(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=f.getWhereClause(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,t,i){if(!t)return e;if(null==this._frameTask)return e.filter((e=>t(e)));let s=0;const r=new Array,a=async n=>{for(;s<e.length;){const l=e[s++];t(l)&&(r.push(l),n.madeProgress()),n.done&&await this._reschedule((e=>a(e)),i)}};return this._reschedule((e=>a(e)),i).then((()=>r))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,n=this.featureAdapter.getAttribute;for(const l of e.items){const e=n(l,t),i=n(l,r),s=a.get(e);(!s||i>n(s,r))&&a.set(e,l)}e.items=Array.from(a.values())}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return Q.canQueryWithRBush(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i))}async _project(e,t){if(!t||p.equals(this.spatialReference,t))return e;const i=this.featureAdapter;let s;try{const e=await this._getFullExtent();s=o.getTransformation(this.spatialReference,t,e)}catch{}const r=await _.projectMany(e.items.map((e=>x.getGeometry(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t,s);return e.items=r.map(((t,s)=>i.cloneWithGeometry(e.items[s],g.convertFromGeometry(t,this.hasZ,this.hasM)))),e}_getQueryBBoxes(e){if(Q.canQueryWithRBush(e)){if(m.isExtent(e))return[c.fromValues(Math.min(e.xmin,e.xmax),Math.min(e.ymin,e.ymax),Math.max(e.xmin,e.xmax),Math.max(e.ymin,e.ymax))];if(m.isPolygon(e))return e.rings.map((e=>c.fromValues(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[y.getBoundsXY(c.create(),e)]}async _searchFeatures(e){const t=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>t.add(e))))));const i=Array.from(t.values());return t.clear(),i}async _executeQueryForStatistics(e,t,i){e=r.clone(e);try{e=await this._schedule((()=>S.normalizeQuery(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>R.validateStatisticsQuery(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),r=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this._reschedule((()=>this._executeObjectIdsQuery(r)),i),await this._reschedule((()=>this._executeTimeQuery(r)),i),await this._reschedule((()=>this._executeAttributesQuery(r)),i),r}catch(s){if(s!==S.queryEngineEmptyResult)throw s;return new F.QueryEngineResult([],e,this)}}}e.Feature=A,e.QueryEngine=M,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
