/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../core/mathUtils","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../rasterFormats/pixelRangeUtils","./BaseRasterFunction","./pixelUtils","./RemapFunctionArguments"],(function(t,e,s,n,a,o,u,l,r,i,p){"use strict";let c=class extends r{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,t.colormap=null,t.histograms=null,t.bandCount=1,t.attributeTable=null;const{statistics:s}=t,{allowUnmatched:n,outputValues:a,inputRanges:o,noDataRanges:u,isLastInputRangeInclusive:l}=this.functionArguments;if(null!=s&&s.length&&a?.length)if(n){const e=Math.min.apply(null,[...a,s[0].min]),n=Math.max.apply(null,[...a,s[0].max]);t.statistics=[{...s[0],min:e,max:n}]}else{let e=a[0],n=e;for(let t=0;t<a.length;t++)e=e>a[t]?a[t]:e,n=n>a[t]?n:a[t];t.statistics=[{...s[0],min:e,max:n}]}this.rasterInfo=t,this.lookup=n?null:i.createRemapLUT({srcPixelType:e,inputRanges:o,outputValues:a,noDataRanges:u,allowUnmatched:n,isLastInputRangeInclusive:l,outputPixelType:this.outputPixelType});return{success:!0,supportsGPU:(!a||a.length<=i.maxMapSizeGpu)&&(!u||u.length<=i.maxMapSizeGpu)}}_processPixels(t){const e=t.pixelBlocks?.[0];if(null==e)return null;const{lookup:s,outputPixelType:n}=this;if(s){const t=i.lookupPixels(e,{lut:[s.lut],offset:s.offset,outputPixelType:n});return null!=t&&s.mask&&(t.mask=i.lookupBandValues(e.pixels[0],e.mask,s.mask,s.offset,"u8")),t}const{inputRanges:a,outputValues:o,noDataRanges:u,allowUnmatched:l,isLastInputRangeInclusive:r}=this.functionArguments;return i.remap(e,{inputRanges:a,outputValues:o,noDataRanges:u,outputPixelType:n,allowUnmatched:l,isLastInputRangeInclusive:r})}_getWebGLParameters(){const{allowUnmatched:t,noDataRanges:s,isLastInputRangeInclusive:n}=this.functionArguments,a=new Float32Array(3*i.maxMapSizeGpu),o=1e-5,u=this.functionArguments.inputRanges??[],r=this.functionArguments.outputValues??[],p=r.length;for(let l=0;l<i.maxMapSizeGpu;l++)a[3*l]=u[2*l]??e.numberMaxFloat32-1,a[3*l+1]=u[2*l+1]??e.numberMaxFloat32,a[3*l+2]=r[l]??0,l<p&&(l>0&&(a[3*l]-=o),(l<p-1||!n)&&(a[3*l+1]-=o));const c=new Float32Array(2*i.maxMapSizeGpu);c.fill(e.numberMaxFloat32),s?.length&&c.set(s);return{allowUnmatched:t,rangeMaps:a,noDataRanges:c,clampRange:l.getPixelValueRange(this.outputPixelType)}}};t.__decorate([s.property({json:{write:!0,name:"rasterFunction"}})],c.prototype,"functionName",void 0),t.__decorate([s.property({type:p,json:{write:!0,name:"rasterFunctionArguments"}})],c.prototype,"functionArguments",void 0),t.__decorate([s.property()],c.prototype,"rasterArgumentNames",void 0),t.__decorate([s.property({json:{write:!0}})],c.prototype,"lookup",void 0),c=t.__decorate([u.subclass("esri.layers.support.rasterFunctions.RemapFunction")],c);return c}));
