/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../../core/maybe","../PixelBlock","../rasterFormats/pixelRangeUtils","../../../renderers/support/stretchRendererUtils"],(function(t,e,n,s,i){"use strict";const o=1,a=[.299,.587,.114];function r(t,e=256){e=Math.min(e,256);const{size:n,counts:s}=t,i=new Uint8Array(n),o=s.reduce(((t,n)=>t+n/e),0);let a=0,r=0,l=0,u=o;for(let c=0;c<n;c++)if(l+=s[c],!(c<n-1&&l+s[c+1]<u)){for(;a<e-1&&u<l;)a++,u+=o;for(let t=r;t<=c;t++)i[t]=a;r=c+1}for(let c=r;c<n;c++)i[c]=e-1;return i}function l(t){const{minCutOff:e,maxCutOff:n,gamma:s,pixelType:i,rounding:o}=t,a=t.outMin||0,r=t.outMax||255;if(!["u8","u16","s8","s16"].includes(i))return null;const l=e.length;let c,f,m=0;"s8"===i?m=-127:"s16"===i&&(m=-32767);let h=256;["u16","s16"].includes(i)&&(h=65536);const g=[],d=[],p=r-a;for(c=0;c<l;c++)d[c]=n[c]-e[c],g[c]=0===d[c]?0:p/d[c];let x;const y=[];let b,v,C;if(s&&s.length>=l){const t=M(l,s);for(c=0;c<l;c++){for(C=[],f=0;f<h;f++)if(0!==d[c])if(b=f+m,x=(b-e[c])/d[c],v=1,s[c]>1&&(v-=(1/p)**(x*t[c])),b<n[c]&&b>e[c]){const t=v*p*x**(1/s[c])+a;C[f]="floor"===o?Math.floor(t):"round"===o?Math.round(t):t}else b>=n[c]?C[f]=r:C[f]=a;else C[f]=a;y[c]=C}}else for(c=0;c<l;c++){for(C=[],f=0;f<h;f++)if(b=f+m,b<=e[c])C[f]=a;else if(b>=n[c])C[f]=r;else{const t=(b-e[c])*g[c]+a;C[f]="floor"===o?Math.floor(t):"round"===o?Math.round(t):t}y[c]=C}if(null!=t.contrastOffset){const e=u(t.contrastOffset,t.brightnessOffset);for(c=0;c<l;c++)for(C=y[c],f=0;f<h;f++)C[f]=e[C[f]]}return{lut:y,offset:m}}function u(t,e){const n=Math.min(Math.max(t,-100),100),s=Math.min(Math.max(e??0,-100),100),i=255,o=128;let a=0,r=0;const l=new Uint8Array(256);for(a=0;a<256;a++)n>0&&n<100?r=(200*a-100*i+2*i*s)/(2*(100-n))+o:n<=0&&n>-100?r=(200*a-100*i+2*i*s)*(100+n)/2e4+o:100===n?(r=200*a-100*i+(i+1)*(100-n)+2*i*s,r=r>0?i:0):-100===n&&(r=o),l[a]=r>i?i:r<0?0:r;return l}function c(t,e,n){const s=[];for(let i=0;i<e.length;i++){let o=0,r=0,l=0;"min"in e[i]?({min:o,max:r,avg:l}=e[i]):[o,r,l]=e[i];let u=l??0;"u8"!==t&&(u=255*(u-o)/(r-o)),n&&(u*=a[i]),s.push(f(u))}return s}function f(t){if(t<=0||t>=255)return o;let e=0;150!==t&&(e=t<=150?45*Math.cos(.01047*t):17*Math.sin(.021*t));const n=255,s=t+e,i=Math.log(t/n),a=Math.log(s/n);if(0===a)return o;const r=i/a;return isNaN(r)?o:Math.min(9.9,Math.max(.01,r))}function m(t,e,n,s){let i=1/0,o=-1/0,a=0,r=0,l=0,u=0;const c=t.length,f=new Map,m=[];for(let k=0;k<c;k++){const n=t[k];if(!e||e[k]){m.push(n);const t=(f.get(n)??0)+1;f.set(n,t),t>u&&(u=t,l=n),i=n<i?n:i,o=n>o?n:o,a+=n,r++}}if(0===r)return{statistics:{min:0,max:0,avg:0,stddev:0,mode:0,median:0},histogram:null};const h=a/r;let g=0;for(let k=0;k<c;k++)e&&!e[k]||(g+=(t[k]-h)**2);const d=e?e.filter((t=>t)).length:c,p=d<=1?0:Math.sqrt(g/(d-1));m.sort(((t,e)=>t-e));const x=r>>>1,M={min:i,max:o,avg:h,stddev:p,mode:l,median:r%2?m[Math.floor(x)]:(m[x-1]+m[x])/2};if(!s)return{statistics:M,histogram:null};if(["u8","s8","u4","u2","u1"].includes(n)){const n=o-i+1,s=new Uint32Array(n);for(let o=0;o<c;o++)e&&!e[o]||s[t[o]-i]++;return{statistics:M,histogram:{min:i-.5,max:o+.5,size:n,counts:s}}}const y=256,b=new Uint32Array(y),v=(o-i)/y;if(0===v)return{statistics:M,histogram:{min:i,max:o,size:1,counts:new Uint32Array(1).fill(r)}};const C=new Uint32Array(y+1);for(let k=0;k<c;k++)e&&!e[k]||C[Math.floor((t[k]-i)/v)]++;for(let k=0;k<y-1;k++)b[k]=C[k];return b[y-1]=C[y-1]+C[y],{statistics:M,histogram:{min:i,max:o,size:y,counts:b}}}function h(t){const{pixels:e,mask:n,pixelType:s,bandMasks:i}=t,o=e.map(((t,e)=>m(t,i?.[e]??n,s,!0)));return{statistics:o.map((({statistics:t})=>t)),histograms:o.map((({histogram:t})=>t))}}function g(t){if(!t?.pixels?.length)return null;const{pixels:e,mask:n,bandMasks:s,pixelType:i}=t,o=t.width*t.height,a=e.length,r=[],l=[],u=256;let c,f,m,h;for(let g=0;g<a;g++){m=new Uint32Array(u);const a=e[g],d=s?.[g]??n;if("u8"===i){if(c=255,f=0,d){for(let t=0;t<o;t++)if(d[t]){const e=a[t];c=e<c?e:c,f=e>f?e:f,m[e]++}}else for(let t=0;t<o;t++){const e=a[t];c=e<c?e:c,f=e>f?e:f,m[e]++}m=m.slice(c,f+1)}else{let e=!1;t.statistics||(t.updateStatistics(),e=!0);const n=t.statistics;c=n[g].minValue,f=n[g].maxValue;const s=(f-c)/u;if(0===s){!n||t.validPixelCount||e||t.updateStatistics();const s=(t.validPixelCount||t.width*t.height)/u;for(let t=0;t<u;t++)m[t]=Math.round(s*(t+1))-Math.round(s*t)}else{h=new Uint32Array(u+1);for(let t=0;t<o;t++)d&&!d[t]||h[Math.floor((a[t]-c)/s)]++;for(let t=0;t<u-1;t++)m[t]=h[t];m[u-1]=h[u-1]+h[u]}}const p="u8"===i?c-.5:c,x="u8"===i?f+.5:f;r.push({min:p,max:x,size:m.length,counts:m});let M=0,y=0,b=0;for(let t=0;t<m.length;t++)M+=m[t],y+=t*m[t];const v=y/M;for(let t=0;t<m.length;t++)b+=m[t]*(t-v)**2;const C=Math.sqrt(b/(M-1)),k=(x-p)/m.length,w=(v+("u8"===i?0:.5))*k+c,z=C*k;l.push({min:c,max:f,avg:w,stddev:z})}return{statistics:l,histograms:r}}function d(t){const e=[];for(let n=0;n<t.length;n++){const{min:s,max:i,size:o,counts:a}=t[n];let r=0,l=0;for(let t=0;t<o;t++)r+=a[t],l+=t*a[t];const u=l/r;let c=0;for(let t=0;t<o;t++)c+=a[t]*(t-u)**2;const f=(i-s)/o,m=(u+.5)*f+s,h=Math.sqrt(c/(r-1))*f;e.push({min:s,max:i,avg:m,stddev:h})}return e}function p(t,n){const{pixelBlock:o,bandIds:a,returnHistogramLut:l,rasterInfo:u}=n;let c=null,f=null,m=t.stretchType;if("number"==typeof m&&(m=i.stretchTypeFunctionEnum[m]),t.dra)if("minMax"===m&&o?.statistics)c=o.statistics.map((t=>[t.minValue,t.maxValue,0,0]));else{const t=g(o);c=null!=t?t.statistics:null,f=null!=t?t.histograms:null}else c=t.statistics?.length?t.statistics:u.statistics,f="histograms"in t?t.histograms:void 0,f||(f=u.histograms);"percentClip"!==m&&"histogramEqualization"!==m||f?.length||(m="minMax");const h=c?.length||f?.length||u.bandCount,d=[],p=[];let M,y,b,v,C,k,w,z,O;c&&!Array.isArray(c[0])&&(c=c.map((t=>[t.min,t.max,t.avg,t.stddev])));const[S,U]=s.getPixelValueRange(u.pixelType);if(!c?.length){for(c=[],z=0;z<h;z++)c.push([S,U,1,1]);"standardDeviation"===m&&(m="minMax")}switch(m){case"none":for(z=0;z<h;z++)d[z]=S,p[z]=U;break;case"minMax":for(z=0;z<h;z++){const t=c[z];d[z]=t[0],p[z]=t[1]}break;case"standardDeviation":{const{numberOfStandardDeviations:e=2}=t;for(z=0;z<h;z++){const t=c[z];d[z]=t[2]-e*t[3],p[z]=t[2]+e*t[3],d[z]<t[0]&&(d[z]=t[0]),p[z]>t[1]&&(p[z]=t[1])}}break;case"histogramEqualization":for(e.assertIsSome(f),z=0;z<h;z++)d[z]=f[z].min,p[z]=f[z].max;break;case"percentClip":for(e.assertIsSome(f),z=0;z<f.length;z++){for(M=f[z],C=new Uint32Array(M.size),v=[...M.counts],v.length>=20&&(v[0]=v[1]=v[2]=v[v.length-1]=v[v.length-2]=0),b=0,y=(M.max-M.min)/M.size,w=-.5===M.min&&1===y?.5:0,O=0;O<M.size;O++)b+=v[O],C[O]=b;for(k=(t.minPercent||0)*b/100,d[z]=M.min+w,O=0;O<M.size;O++)if(C[O]>k){d[z]=M.min+y*(O+w);break}for(k=(1-(t.maxPercent||0)/100)*b,p[z]=M.max+w,O=M.size-2;O>=0;O--)if(C[O]<k){p[z]=M.min+y*(O+2-w);break}if(p[z]<d[z]){const t=d[z];d[z]=p[z],p[z]=t}}break;default:for(z=0;z<h;z++){const t=c[z];d[z]=t[0],p[z]=t[1]}}let A,T,P;"histogramEqualization"===m?(e.assertIsSome(f),T=f[0].size||256,A=0,l&&(P=f.map((t=>r(t))))):(T=t.max||255,A=t.min||0);return x({minCutOff:d,maxCutOff:p,outMax:T,outMin:A,histogramLut:P},a)}function x(t,e){if(null==e||0===e.length)return t;const n=Math.max.apply(null,e),{minCutOff:s,maxCutOff:i,outMin:o,outMax:a,histogramLut:r}=t;return s.length===e.length||s.length<=n?t:{minCutOff:e.map((t=>s[t])),maxCutOff:e.map((t=>i[t])),histogramLut:r?e.map((t=>r[t])):null,outMin:o,outMax:a}}function M(t,e){const n=new Float32Array(t);for(let s=0;s<t;s++)e[s]>1?e[s]>2?n[s]=6.5+(e[s]-2)**2.5:n[s]=6.5+100*(2-e[s])**4:n[s]=1;return n}function y(t,e){if(!t?.pixels?.length)return t;const{mask:s,bandMasks:i,width:o,height:a,pixels:r}=t,{minCutOff:l,maxCutOff:u,gamma:c}=e,f=e.outMin||0,m=e.outMax||255,h=o*a,g=e.outputPixelType||"u8",d=t.pixels.map((()=>n.createEmptyBand(g,h))),p=d.length,x=m-f,y=[],b=[];for(let n=0;n<p;n++)b[n]=u[n]-l[n],y[n]=0===b[n]?0:x/b[n];const v=g.startsWith("u")||g.startsWith("s"),C=c&&c.length>=p,k=!!e.isRenderer;if(C){const t=M(p,c);for(let e=0;e<p;e++){const n=i?.[e]??s;for(let s=0;s<h;s++)if(null==n||n[s]){if(0===b[e]){d[e][s]=f;continue}const n=r[e][s],i=(n-l[e])/b[e];let o=1;if(c[e]>1&&(o-=(1/x)**(i*t[e])),n<u[e]&&n>l[e]){const t=o*x*i**(1/c[e])+f;d[e][s]=k?Math.floor(t):v?Math.round(t):t}else n>=u[e]?d[e][s]=m:d[e][s]=f}}}else for(let n=0;n<p;n++){const t=i?.[n]??s;for(let e=0;e<h;e++)if(null==t||t[e]){const t=r[n][e];if(t<u[n]&&t>l[n]){const s=(t-l[n])*y[n]+f;d[n][e]=k?Math.floor(s):v?Math.round(s):s}else t>=u[n]?d[n][e]=m:d[n][e]=f}}const w=new n({width:o,height:a,mask:s,bandMasks:i,pixels:d,pixelType:g});return w.updateStatistics(),w}t.computeGammaCorrection=M,t.computeGammaValues=c,t.computeStatisticsHistograms=h,t.createContrastBrightnessLUT=u,t.createHistogramEqualizationLUT=r,t.createStretchLUT=l,t.estimateStatisticsFromHistograms=d,t.estimateStatisticsHistograms=g,t.getStretchCutoff=p,t.stretch=y,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
