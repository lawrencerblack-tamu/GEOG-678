/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../core/Error","./CloudRaster","./CovJSONRaster","./ImageAuxRaster","./ImageServerRaster","./InMemoryRaster","./MRFRaster","./TIFFRaster"],(function(e,t,r,s,o,a,c,n){"use strict";const u=new Map;u.set("CRF",{desc:"Cloud Raster Format",constructor:t}),u.set("MRF",{desc:"Meta Raster Format",constructor:c}),u.set("TIFF",{desc:"GeoTIFF",constructor:n}),u.set("RasterTileServer",{desc:"Raster Tile Server",constructor:o}),u.set("JPG",{desc:"JPG Raster Format",constructor:s}),u.set("PNG",{desc:"PNG Raster Format",constructor:s}),u.set("GIF",{desc:"GIF Raster Format",constructor:s}),u.set("BMP",{desc:"BMP Raster Format",constructor:s}),u.set("CovJSON",{desc:"COVJSON Raster Format",constructor:r}),u.set("MEMORY",{desc:"In Memory Raster Format",constructor:a});class l{static get supportedFormats(){const e=new Set;return u.forEach(((t,r)=>e.add(r))),e}static async open(t){const{url:r,ioConfig:s,source:o,sourceJSON:a}=t;let c=t.datasetFormat??s?.datasetFormat;null==c&&(r.includes(".")?c=r.slice(r.lastIndexOf(".")+1).toUpperCase():"coverage"===o?.type?.toLowerCase()?c="CovJSON":o?.extent&&o.pixelblocks&&(c="MEMORY")),"OVR"===c||"TIF"===c?c="TIFF":"JPG"===c||"JPEG"===c||"JFIF"===c?c="JPG":"COVJSON"===c&&(c="CovJSON"),r.toLowerCase().includes("/imageserver")&&!r.toLowerCase().includes("/wcsserver")&&(c="RasterTileServer");const n={url:r,source:o,sourceJSON:a,datasetFormat:c,ioConfig:s??{bandIds:null,sampling:null}};if(Object.keys(n).forEach((e=>{null==n[e]&&delete n[e]})),c){if(!this.supportedFormats.has(c))throw new e("rasterfactory:open","not a supported format "+c);if("CRF"===c&&!s?.enableCRF)throw new e("rasterfactory:open",`cannot open raster: ${r}`);const o=new(0,u.get(c).constructor)(n);return await o.open({signal:t.signal}),o}const l=Array.from(u.keys()).filter((e=>"CovJSON"!==e&&"Memory"!==e));let i=0;const F=()=>{if(c=l[i++],!c)return null;if("CRF"===c&&!s?.enableCRF)return null;const e=new(0,u.get(c).constructor)(n);return e.open({signal:t.signal}).then((()=>e)).catch((()=>F()))};return F()}static register(e,t,r){u.has(e.toUpperCase())||u.set(e.toUpperCase(),{desc:t,constructor:r})}}return l}));
