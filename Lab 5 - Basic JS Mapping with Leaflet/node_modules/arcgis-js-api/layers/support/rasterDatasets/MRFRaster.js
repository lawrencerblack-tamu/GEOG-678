/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../geometry","../../../core/Error","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../PixelBlock","../RasterInfo","../RasterStorageInfo","./BaseRaster","./pamParser","./xmlUtilities","../rasterFormats/utils","../rasterFunctions/stretchUtils","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Point"],(function(e,t,s,r,a,n,i,o,l,c,f,h,u,g,p,m,d,y,x){"use strict";const I=new Map;I.set("Int8","s8"),I.set("UInt8","u8"),I.set("Int16","s16"),I.set("UInt16","u16"),I.set("Int32","s32"),I.set("UInt32","u32"),I.set("Float32","f32"),I.set("Float64","f32"),I.set("Double64","f32");const w=new Map;w.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),w.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),w.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),w.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let b=class extends h{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(e){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const t=e?e.signal:null,s=await this.request(this.url,{responseType:"xml",signal:t}),{rasterInfo:r,files:a}=this._parseHeader(s.data),{skipMapInfo:n,skipExtensions:i=[]}=this.ioConfig;if(!i.includes("aux.xml")&&!n){const t=await this._fetchAuxiliaryData(e);null!=t&&(r.statistics=t.statistics??r.statistics,r.histograms=t.histograms,t.histograms&&null==r.statistics&&(r.statistics=m.estimateStatisticsFromHistograms(t.histograms)))}n&&this.updateImageSpaceRasterInfo(r),this._set("rasterInfo",r),this._files=a;const o=await this.request(a.index,{responseType:"array-buffer",signal:t});this._storageIndex=this._parseIndex(o.data);const{blockWidth:l,blockHeight:c}=this.rasterInfo.storageInfo,f=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:h,height:u}=this.rasterInfo,g=[],p=this._getBandSegmentCount();let d=0,y=-1;for(;d<this._storageIndex.length;){y++;const e=Math.ceil(h/l/f**y)-1,t=Math.ceil(u/c/f**y)-1;d+=(e+1)*(t+1)*p*4,g.push({maxRow:t,maxCol:e,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=g,y>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=y),this.updateTileInfo()}async fetchRawTile(e,t,s,r={}){const{blockWidth:a,blockHeight:n,blockBoundary:i}=this.rasterInfo.storageInfo,o=i[e];if(!o||o.maxRow<t||o.maxCol<s||o.minRow>t||o.minCol>s)return null;const{bandCount:c,pixelType:f}=this.rasterInfo,{ranges:h,actualTileWidth:u,actualTileHeight:g}=this._getTileLocation(e,t,s);if(!h||0===h.length)return null;if(0===h[0].from&&0===h[0].to){const e=new Uint8Array(a*n);return new l({width:a,height:n,pixels:null,mask:e,validPixelCount:0})}const{bandIds:p}=this.ioConfig,m=this._getBandSegmentCount(),d=[];let y=0;for(y=0;y<m;y++)p&&!p.includes(y)||d.push(this.request(this._files.data,{range:{from:h[y].from,to:h[y].to},responseType:"array-buffer",signal:r.signal}));const x=await Promise.all(d),I=x.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),b=new Uint8Array(I),_=[];let R=0;for(y=0;y<m;y++)_.push(R),b.set(new Uint8Array(x[y].data),R),R+=x[y].data.byteLength;const A=w.get(this.rasterInfo.storageInfo.compression).decoderFormat,F=await this.decodePixelBlock(b.buffer,{width:a,height:n,format:A,planes:p?.length||c,offsets:_,pixelType:f});if(null==F)return null;let{noDataValue:S}=this.rasterInfo;if(null!=S&&"lerc"!==A&&!F.mask&&(S=S[0],null!=S)){const e=F.width*F.height,t=new Uint8Array(e);if(Math.abs(S)>1e24)for(y=0;y<e;y++)Math.abs((F.pixels[0][y]-S)/S)>1e-6&&(t[y]=1);else for(y=0;y<e;y++)F.pixels[0][y]!==S&&(t[y]=1);F.mask=t}let E=0,M=0;if(u!==a||g!==n){let e=F.mask;if(e)for(y=0;y<n;y++)if(M=y*a,y<g)for(E=u;E<a;E++)e[M+E]=0;else for(E=0;E<a;E++)e[M+E]=0;else for(e=new Uint8Array(a*n),F.mask=e,y=0;y<g;y++)for(M=y*a,E=0;E<u;E++)e[M+E]=1}return F}_parseIndex(e){if(e.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let t,s,r,a,n,i;if(p.isPlatformLittleEndian){for(s=new Uint8Array(e),a=new ArrayBuffer(e.byteLength),r=new Uint8Array(a),n=0;n<e.byteLength/4;n++)for(i=0;i<4;i++)r[4*n+i]=s[4*n+3-i];t=new Uint32Array(a)}else t=new Uint32Array(e);return t}_getBandSegmentCount(){return w.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(e,t,s){const{blockWidth:r,blockHeight:a,pyramidScalingFactor:n}=this.rasterInfo.storageInfo,{width:i,height:o}=this.rasterInfo,l=this._getBandSegmentCount();let c,f,h,u=0,g=0;for(h=0;h<e;h++)g=n**h,c=Math.ceil(i/r/g),f=Math.ceil(o/a/g),u+=c*f;g=n**e,c=Math.ceil(i/r/g),f=Math.ceil(o/a/g),u+=t*c+s,u*=4*l;const p=this._storageIndex.subarray(u,u+4*l);let m=0,d=0;const y=[];for(let x=0;x<l;x++)m=p[4*x]*2**32+p[4*x+1],d=m+p[4*x+2]*2**32+p[4*x+3],y.push({from:m,to:d});return{ranges:y,actualTileWidth:s<c-1?r:Math.ceil(i/g)-r*(c-1),actualTileHeight:t<f-1?a:Math.ceil(o/g)-a*(f-1)}}_parseHeader(e){const t=g.getElement(e,"MRF_META/Raster");if(!t)throw new s("mrf:open","not a valid MRF format");const r=g.getElement(t,"Size"),a=parseInt(r.getAttribute("x"),10),n=parseInt(r.getAttribute("y"),10),i=parseInt(r.getAttribute("c"),10),o=(g.getElementValue(t,"Compression")||"none").toLowerCase();if(!w.has(o))throw new s("mrf:open","currently does not support compression "+o);const l=g.getElementValue(t,"DataType")||"UInt8",h=I.get(l);if(null==h)throw new s("mrf:open","currently does not support pixel type "+l);const p=g.getElement(t,"PageSize"),m=parseInt(p.getAttribute("x"),10),b=parseInt(p.getAttribute("y"),10),_=g.getElement(t,"DataValues");let R,A;_&&(A=_.getAttribute("NoData"),null!=A&&(R=A.trim().split(" ").map((e=>parseFloat(e)))));if(g.getElement(e,"MRF_META/CachedSource"))throw new s("mrf:open","currently does not support MRF referencing other data files");const F=g.getElement(e,"MRF_META/GeoTags"),S=g.getElement(F,"BoundingBox");let E,M=!1;if(null!=S){const e=parseFloat(S.getAttribute("minx")),t=parseFloat(S.getAttribute("miny")),s=parseFloat(S.getAttribute("maxx")),r=parseFloat(S.getAttribute("maxy")),a=g.getElementValue(F,"Projection")||"";let n=d.WGS84;if("LOCAL_CS[]"!==a)if(a.toLowerCase().startsWith("epsg:")){const e=Number(a.slice(5));isNaN(e)||0===e||(n=new d({wkid:e}))}else n=u.parseSpatialReference(a)??d.WGS84;else M=!0,n=new d({wkid:3857});E=new y(e,t,s,r),E.spatialReference=n}else M=!0,E=new y({xmin:-.5,ymin:.5-n,xmax:a-.5,ymax:.5,spatialReference:new d({wkid:3857})});const k=g.getElement(e,"MRF_META/Rsets"),C=parseInt(k?.getAttribute("scale")||"2",10),T=E.spatialReference,L=new f({origin:new x({x:E.xmin,y:E.ymax,spatialReference:T}),blockWidth:m,blockHeight:b,pyramidBlockWidth:m,pyramidBlockHeight:b,compression:o,pyramidScalingFactor:C}),U=new x({x:E.width/a,y:E.height/n,spatialReference:T}),B=new c({width:a,height:n,extent:E,isPseudoSpatialReference:M,spatialReference:T,bandCount:i,pixelType:h,pixelSize:U,noDataValue:R,storageInfo:L}),P=g.getElementValue(e,"datafile"),H=g.getElementValue(e,"IndexFile");return{rasterInfo:B,files:{mrf:this.url,index:H||this.url.replace(".mrf",".idx"),data:P||this.url.replace(".mrf",w.get(o).blobExtension)}}}async _fetchAuxiliaryData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return u.parsePAMInfo(t)}catch{return null}}};e.__decorate([r.property()],b.prototype,"_files",void 0),e.__decorate([r.property()],b.prototype,"_storageIndex",void 0),e.__decorate([r.property({type:String,json:{write:!0}})],b.prototype,"datasetFormat",void 0),b=e.__decorate([o.subclass("esri.layers.support.rasterIO.MRFRaster")],b);return b}));
