/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../../chunks/tslib.es6","../../../geometry","../../../core/arrayUtils","../../../core/Error","../../../core/Logger","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/accessorSupport/decorators/subclass","../RasterInfo","../RasterStorageInfo","./BaseRaster","./DBFParser","./pamParser","../rasterFormats/TiffDecoder","../rasterFormats/TiffTags","../rasterFunctions/stretchUtils","../rasterTransforms/PolynomialTransform","../../../rest/support/FeatureSet","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Point"],(function(e,t,a,r,i,s,n,o,l,f,u,c,p,h,d,m,y,g,T,x,I){"use strict";const w=(e,t)=>e.get(t)?.values,_=(e,t)=>e.get(t)?.values?.[0];let R=class extends u{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(e){await this.init();const t=e?e.signal:null,{data:a}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:t});if(!a)throw new r("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:s,firstIFDPos:n,isBigTiff:o}=h.parseSignature(a),l=[];await this._readIFDs(l,a,s,n,0,o?8:4,t);const{imageInfo:f,rasterInfo:u}=this._parseIFDs(l),c=h.getPyramidIFDs(l),p=h.getMaskIFDs(l);if(this._headerInfo={littleEndian:s,isBigTiff:o,ifds:l,pyramidIFDs:c,maskIFDs:p,...f},this._set("rasterInfo",u),!f.isSupported)throw new r("tiffraster:open","this tiff is not supported: "+f.message);if(!f.tileWidth)throw new r("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");u.isPseudoSpatialReference&&i.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const d=l[0].get("PREDICTOR")?.values?.[0],m=l[0].get("SAMPLEFORMAT")?.values?.[0];if(3===m&&2===d)throw new r("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:y,skipExtensions:g=[]}=this.ioConfig;if(!g.includes("aux.xml")&&!y){const t=await this._fetchAuxiliaryMetaData(e);null!=t&&this._processPAMInfo(t,u)}g.includes("vat.dbf")||1!==u.bandCount||"u8"!==u.pixelType||y||(u.attributeTable=await this._fetchAuxiliaryTable(e),null!=u.attributeTable&&(u.keyProperties.DataType="thematic")),y&&this.updateImageSpaceRasterInfo(u),this.updateTileInfo()}async fetchRawTile(e,t,a,r={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(e,t,a))return null;const i=await this._fetchRawTiffTile(e,t,a,!1,r);if(null!=i&&this._headerInfo.hasMaskBand){const s=await this._fetchRawTiffTile(e,t,a,!0,r);null!=s&&s.pixels[0]instanceof Uint8Array&&(i.mask=s.pixels[0])}return i}_parseIFDs(e){const t=h.getImageInfo(e),{width:a,height:r,tileWidth:i,tileHeight:s,planes:n,pixelType:o,compression:u,firstPyramidLevel:c,maximumPyramidLevel:d,pyramidBlockWidth:m,pyramidBlockHeight:g,tileBoundary:R,affine:b,metadata:S}=t,F=t.extent.spatialReference?.wkt||t.extent.spatialReference?.wkid;let E=p.parseSpatialReference(F),D=!!t.isPseudoGeographic;null==E&&(D=!0,E=new T({wkid:3857}));const P=new x({...t.extent,spatialReference:E}),k=new I(P?{x:P.xmin,y:P.ymax,spatialReference:E}:{x:0,y:0}),v=new f({blockWidth:i,blockHeight:s,pyramidBlockWidth:m,pyramidBlockHeight:g,compression:u,origin:k,firstPyramidLevel:c,maximumPyramidLevel:d,blockBoundary:R}),O=new I({x:(P.xmax-P.xmin)/a,y:(P.ymax-P.ymin)/r,spatialReference:E}),B=S?{BandProperties:S.bandProperties,DataType:S.dataType}:{};let L=null;const A=_(e[0],"PHOTOMETRICINTERPRETATION"),z=w(e[0],"COLORMAP");if(A<=3&&z?.length>3&&z.length%3==0){L=[];const e=z.length/3;for(let t=0;t<e;t++)L.push([t,z[t]>>>8,z[t+e]>>>8,z[t+2*e]>>>8])}const C=new l({width:a,height:r,bandCount:n,pixelType:o,pixelSize:O,storageInfo:v,spatialReference:E,isPseudoSpatialReference:D,keyProperties:B,extent:P,colormap:L,statistics:S?S.statistics:null});return b?.length&&(C.nativeExtent=new x({xmin:-.5,ymin:.5-r,xmax:a-.5,ymax:.5,spatialReference:E}),C.transform=new y({polynomialOrder:1,forwardCoefficients:[b[2]+b[0]/2,b[5]-b[3]/2,b[0],b[3],-b[1],-b[4]]}),C.extent=C.transform.forwardTransform(C.nativeExtent),C.pixelSize=new I({x:(P.xmax-P.xmin)/a,y:(P.ymax-P.ymin)/r,spatialReference:E}),v.origin.x=-.5,v.origin.y=.5),{imageInfo:t,rasterInfo:C}}_processPAMInfo(e,t){if(t.statistics=e.statistics??t.statistics,t.histograms=e.histograms,e.histograms&&null==t.statistics&&(t.statistics=m.estimateStatisticsFromHistograms(e.histograms)),e.transform&&null==t.transform){t.transform=e.transform,t.nativeExtent=t.extent;const a=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new I({x:(a.xmax-a.xmin)/t.width,y:(a.ymax-a.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=a}t.isPseudoSpatialReference&&e.spatialReference&&(t.spatialReference=e.spatialReference,t.extent.spatialReference=t.nativeExtent.spatialReference=t.storageInfo.origin.spatialReference=t.spatialReference)}async _readIFDs(e,t,a,r,i,s=4,n){if(!r)return null;if(r>=t.byteLength||r<0){t=(await this.request(this.url,{range:{from:r+i,to:r+i+this._bufferSize},responseType:"array-buffer",signal:n})).data,i=r+i,r=0}const o=await this._readIFD(t,a,r,i,d.tiffTags,s,n);if(e.push(o.ifd),!o.nextIFD)return null;await this._readIFDs(e,t,a,o.nextIFD-i,i,s,n)}async _readIFD(e,t,r,i,s=d.tiffTags,n=4,o){if(!e)return null;const l=h.parseIFD(e,t,r,i,s,n);if(l.success){const r=[];if(l.ifd?.forEach((e=>{e.values||r.push(e)})),r.length>0){const s=r.map((e=>e.offlineOffsetSize)).filter(a.isSome),n=Math.min.apply(null,s.map((e=>e[0])));if(Math.min.apply(null,s.map((e=>e[0]+e[1])))-n<=this._bufferSize){const{data:a}=await this.request(this.url,{range:{from:n,to:n+this._bufferSize},responseType:"array-buffer",signal:o});e=a,i=n,r.forEach((a=>h.parseFieldValues(e,t,a,i)))}}if(l.ifd?.has("GEOKEYDIRECTORY")){const a=l.ifd.get("GEOKEYDIRECTORY"),r=a?.values;if(r&&r.length>4){const s=r[0]+"."+r[1]+"."+r[2],n=await this._readIFD(e,t,a.valueOffset+6-i,i,d.geoKeys,2,o);a.data=n.ifd,a.data&&a.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[s]})}}return l}if(l.requiredBufferSize&&l.requiredBufferSize!==e.byteLength){const a=await this.request(this.url,{range:{from:i,to:i+l.requiredBufferSize+4},responseType:"array-buffer",signal:o});return(e=a.data).byteLength<l.requiredBufferSize?null:this._readIFD(e,t,0,i,d.tiffTags,4,o)}}async _fetchRawTiffTile(e,t,a,r,i={}){const s=this._getTileLocation(e,t,a,r);if(!s)return null;const{ranges:n,actualTileWidth:o,actualTileHeight:l,ifd:f}=s,u=n.map((e=>this.request(this.url,{range:e,responseType:"array-buffer",signal:i.signal}))),c=await Promise.all(u),p=c.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),h=1===c.length?c[0].data:new ArrayBuffer(p),d=[0],m=[0];if(c.length>1){const e=new Uint8Array(h);for(let t=0,a=0;t<c.length;t++){const r=c[t].data;e.set(new Uint8Array(r),a),d[t]=a,a+=r.byteLength,m[t]=r.byteLength}}const{blockWidth:y,blockHeight:g}=this.getBlockWidthHeight(e),T=await this.decodePixelBlock(h,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:f,offsets:d,sizes:m},width:y,height:g,planes:null,pixelType:null});if(null==T)return null;let x,I,w;if(o!==y||l!==g){let e=T.mask;if(e)for(x=0;x<g;x++)if(w=x*y,x<l)for(I=o;I<y;I++)e[w+I]=0;else for(I=0;I<y;I++)e[w+I]=0;else for(e=new Uint8Array(y*g),T.mask=e,x=0;x<l;x++)for(w=x*y,I=0;I<o;I++)e[w+I]=1}return T}_getTileLocation(e,t,a,r=!1){const{firstPyramidLevel:i,blockBoundary:s}=this.rasterInfo.storageInfo,n=0===e?0:e-(i-1),{_headerInfo:o}=this;if(!o)return null;const l=r?o.maskIFDs[n]:0===n?o?.ifds[0]:o?.pyramidIFDs[n-1];if(!l)return null;const f=h.isBSQConfig(l,o),u=w(l,"TILEOFFSETS");if(void 0===u)return null;const c=w(l,"TILEBYTECOUNTS"),{minRow:p,minCol:d,maxRow:m,maxCol:y}=s[n];if(t>m||a>y||t<p||a<d)return null;const g=_(l,"IMAGEWIDTH"),T=_(l,"IMAGELENGTH"),x=_(l,"TILEWIDTH"),I=_(l,"TILELENGTH"),R=[];if(f){const{bandCount:e}=this.rasterInfo;for(let r=0;r<e;r++){const e=r*(m+1)*(y+1)+t*(y+1)+a;R[r]={from:u[e],to:u[e]+c[e]-1}}}else{const e=t*(y+1)+a;R.push({from:u[e],to:u[e]+c[e]-1})}for(let h=0;h<R.length;h++)if(null==R[h].from||!R[h].to||R[h].to<0)return null;return{ranges:R,ifd:l,actualTileWidth:a===y&&g%x||x,actualTileHeight:t===m&&T%I||I}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return p.parsePAMInfo(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e?.signal}),a=c.parse(t);return a?.recordSet?g.fromJSON(a.recordSet):null}catch{return null}}};e.__decorate([s.property()],R.prototype,"_files",void 0),e.__decorate([s.property()],R.prototype,"_headerInfo",void 0),e.__decorate([s.property()],R.prototype,"_bufferSize",void 0),e.__decorate([s.property({type:String,json:{write:!0}})],R.prototype,"datasetFormat",void 0),R=e.__decorate([o.subclass("esri.layers.support.rasterDatasets.TIFFRaster")],R);return R}));
