/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["require","../../../chunks/tslib.es6","../../../core/Error","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../geometry/Polygon","./BaseRaster","../rasterFunctions/clipUtils","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../../../rest/support/FeatureSet"],(function(e,t,r,s,i,a,n,o,l,c,p,u,h,m){"use strict";const y=40;let d=class extends c{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async open(e){await this.init();const{rasterFunction:t}=this;this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((e=>e.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:i}=this.primaryRasters,a=s.map((t=>t.rasterInfo?void 0:t.open(e)));await Promise.all(a);const n=s.map((({rasterInfo:e})=>e)),o=t.bind({rasterInfos:n,rasterIds:i});if(t.rawSourceRasterInfos=n,!o.success||0===n.length)throw new r("raster-function:open",`cannot bind the function: ${o.error??""}`);const l="Table"===t.functionName?t:t.functionArguments?.raster;"Table"===l?.functionName&&(t.rasterInfo.attributeTable=m.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=n[0];this.hasUniqueSourceStorageInfo=1===n.length||n.slice(1).every((e=>this._hasSameStorageInfo(e,c))),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(e,t,r,s={}){const{rasters:i,rasterIds:a}=this.primaryRasters;let n=!1;const{interpolation:o}=s,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!s.requestRawData&&l&&(n=1===i.length&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:n});const c=i.map((i=>i.fetchPixels(e,t,r,s))),h=await Promise.all(c),m=h.map((e=>e.pixelBlock)),y=n||s.requestRawData?h.map((e=>e.srcTilePixelSize)):null;if(s.skipRasterFunction||m.every((e=>null==e)))return h[0];const d=h.find((e=>null!=e.pixelBlock))?.extent??e;let g=this.rasterJobHandler?await this.rasterJobHandler.process({extent:d,primaryPixelBlocks:m,primaryPixelSizes:y,primaryRasterIds:a}):this.rasterFunction.process({extent:d,primaryPixelBlocks:m,primaryPixelSizes:y,primaryRasterIds:a});const{transformGrid:f}=h[0];if(!n||null==g||null==f){const e=s.noClip?null:this.getClippingGeometry(d.spatialReference);return s.noClip||s.requestRawData||null==g||!e||(g=await p.clip(g,d,e)),{...h[0],pixelBlock:g}}const R={rows:f.spacing[0],cols:f.spacing[1]};let x;if(this.rasterJobHandler){x=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[g],srcMosaicSize:{width:g.width,height:g.height},destDimension:{width:t,height:r},coefs:f.coefficients,sampleSpacing:R,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock}else x=u.approximateTransform(g,{width:t,height:r},f.coefficients,R,o);const w=s.noClip?null:this.getClippingGeometry(e.spatialReference);return s.noClip||s.requestRawData||null==x||null==w||(x=await p.clip(x,e,w)),{extent:e,srcExtent:h[0].srcExtent,pixelBlock:x}}getClippingGeometry(e){const t=this._clippingGeometry.get("0");if(!e||!t)return t;const r=this._getSRKey(e);let s=this._clippingGeometry.get(r);return null!=s||(s=e.equals(t.spatialReference)?t:h.projectPolygon(t,e),this._clippingGeometry.set(r,s)),s}_hasSameStorageInfo(e,t){const{storageInfo:r,pixelSize:s,spatialReference:i,extent:a}=e,{storageInfo:n,pixelSize:o,spatialReference:l,extent:c}=t;return s.x===o.x&&s.y===o.y&&i.equals(l)&&a.equals(c)&&r.blockHeight===n.blockHeight&&r.blockWidth===n.blockWidth&&r.maximumPyramidLevel===n.maximumPyramidLevel}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let r=t?.clippingGeometry;if(r&&"inside"===t.clippingType){const{extent:t}=this.rasterInfo,{difference:s,densify:i}=await new Promise(((t,r)=>e(["../../../geometry/geometryEngine"],t,r)));let a=i(l.fromExtent(t),2*(t.width+t.height)/y);a=h.projectPolygon(a,r.spatialReference),r=s(a,r)}this._clippingGeometry.clear(),r&&this._clippingGeometry.set("0",r)}_getSRKey(e){return String(e.wkid??e.wkt??e.wkt2)}};t.__decorate([s.property({type:String,json:{write:!0}})],d.prototype,"datasetFormat",void 0),t.__decorate([s.property()],d.prototype,"tileType",void 0),t.__decorate([s.property()],d.prototype,"rasterFunction",void 0),t.__decorate([s.property()],d.prototype,"primaryRasters",void 0),d=t.__decorate([o.subclass("esri.layers.support.rasterDatasets.FunctionRaster")],d);return d}));
