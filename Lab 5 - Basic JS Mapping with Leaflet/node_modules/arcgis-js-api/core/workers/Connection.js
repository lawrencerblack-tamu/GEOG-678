/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../handleUtils","../promiseUtils","../Queue","./connectionRegistry","./InvokeHandler","./RemoteClient"],(function(e,t,s,n,i,o){"use strict";class r{constructor(){this._inUseClients=new Array,this._clients=new Array,this._clientPromises=new Array,this._ongoingJobsQueue=new s}destroy(){this.close()}get closed(){return!this._clients?.length}open(e,s){return new Promise(((n,i)=>{let r=!0;const l=e=>{t.throwIfAborted(s.signal),r&&(r=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length,this._inUseClients.length=e.length;for(let h=0;h<e.length;++h){const r=e[h];t.isPromiseLike(r)?this._clientPromises[h]=r.then((e=>(this._clients[h]=new o(e,s,this._ongoingJobsQueue),l(n),this._clients[h])),(()=>(l(i),null))):(this._clients[h]=new o(r,s,this._ongoingJobsQueue),this._clientPromises[h]=Promise.resolve(this._clients[h]),l(n))}}))}broadcast(e,t,s){const n=new Array(this._clientPromises.length);for(let i=0;i<this._clientPromises.length;++i){const o=this._clientPromises[i];n[i]=o.then((n=>n?.invoke(e,t,s)))}return n}close(){let e;for(;e=this._ongoingJobsQueue.pop();)e.resolver.reject(t.createAbortError(`Worker closing, aborting job calling '${e.methodName}'`));for(const t of this._clientPromises)t.then((e=>e?.close()));this._clients.length=0,this._clientPromises.length=0,this._inUseClients.length=0,n.unregister(this)}invoke(e,t,s){return this.apply(e,[t],s)}apply(e,s,n){const i=t.createResolver();this._ongoingJobsQueue.push({methodName:e,data:s,invokeOptions:n,resolver:i});for(let t=0;t<this._clientPromises.length;t++){const e=this._clients[t];e?e.jobAdded():this._clientPromises[t].then((e=>e?.jobAdded()))}return i.promise}createInvokeProxy(e){return i.createInvokeProxy(this,e)}on(t,s){return Promise.all(this._clientPromises).then((()=>e.handlesGroup(this._clients.map((e=>e.on(t,s))))))}openPorts(){return new Promise((e=>{const t=new Array(this._clientPromises.length);let s=t.length;for(let n=0;n<this._clientPromises.length;++n){this._clientPromises[n].then((i=>{i&&(t[n]=i.openPort()),0==--s&&e(t)}))}}))}get test(){return{numClients:this._clients.length}}}return r}));
