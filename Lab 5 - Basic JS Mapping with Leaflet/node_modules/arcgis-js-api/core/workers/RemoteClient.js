/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["../../kernel","../Error","../events","../handleUtils","../maybe","../promiseUtils","./InvokeHandler","./registry","./utils","../../support/revision"],(function(e,s,t,o,r,n,i,a,l,h){"use strict";const{CLOSE:c,ABORT:p,INVOKE:_,RESPONSE:u,OPEN_PORT:d,ON:b}=l.MessageType,g=2;class v{constructor(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this)}push(e){e.type===l.MessageType.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))}clear(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null}_process(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0}}class m{static connect(e){const s=new MessageChannel;let t;t="function"==typeof e?new e:"default"in e&&"function"==typeof e.default?new e.default:e;const o=new m(s.port1,{channel:s,client:t});return"object"==typeof t&&"remoteClient"in t&&(t.remoteClient=o),m.clients.set(o,t),s.port2}static loadWorker(e){const s=a.registry[e];return s?s():Promise.resolve(null)}constructor(e,s,t){this._port=e,this._jobQueue=t,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new v((e=>this._onInvokeMessage(e))),this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,this._schedule=s.schedule,this._port.addEventListener("message",this._onMessage),this._port.start()}close(){this._post({type:c}),this._close()}isBusy(){return this._outJobs.size>0}invoke(e,s,t){return this.apply(e,[s],t)}apply(e,t,o){const i=o?.signal,a=o?.transferList;if(!this._port)return Promise.reject(new s(l.portClosedErrorName,`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:t}));const h=l.newJobId();return new Promise(((s,o)=>{if(n.isAborted(i))return this._processWork(),void o(n.createAbortError());const l=n.onAbort(i,(()=>{const e=this._outJobs.get(h);e&&(this._outJobs.delete(h),this._processWork(),r.removeMaybe(e.abortHandle),this._post({type:p,jobId:h}),o(n.createAbortError()))})),c={resolve:s,reject:o,abortHandle:l,debugInfo:e};this._outJobs.set(h,c),this._post({type:_,jobId:h,methodName:e,abortable:null!=i},t,a)}))}createInvokeProxy(e,s){return i.createInvokeProxy(this,e,s)}on(e,s){const t=new MessageChannel;function r(e){s(e.data)}return this._port.postMessage({type:l.MessageType.ON,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",r),t.port1.start(),o.makeHandle((()=>{t.port1.postMessage({type:l.MessageType.CLOSE}),t.port1.close(),t.port1.removeEventListener("message",r)}))}jobAdded(){this._processWork()}openPort(){const e=new MessageChannel;return this._post({type:d,port:e.port2}),e.port1}_processWork(){if(this._outJobs.size>=g)return;const e=this._jobQueue?.pop();if(!e)return;const{methodName:s,data:t,invokeOptions:o,resolver:r}=e;this.apply(s,t,o).then((e=>r.resolve(e))).catch((e=>r.reject(e)))}_close(){this._channel&&(this._channel=void 0),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{r.removeMaybe(e.abortHandle),e.reject(n.createAbortError(`Worker closing, aborting job calling '${e.debugInfo}'`))})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=null,this._client=null,this._schedule=null}_onMessage(e){null!=this._schedule?this._schedule((()=>this._processMessage(e))):this._processMessage(e)}_processMessage(e){const s=l.receiveMessage(e);if(s)switch(s.type){case u:this._onResponseMessage(s);break;case _:this._invokeQueue.push(s);break;case p:this._onAbortMessage(s);break;case c:this._onCloseMessage();break;case d:this._onOpenPortMessage(s);break;case b:this._onOnMessage(s)}}_onAbortMessage(e){const s=this._inJobs,t=e.jobId,o=s.get(t);this._invokeQueue.push(e),o&&(o.controller&&o.controller.abort(),s.delete(t))}_onCloseMessage(){const e=this._client;this._close(),e&&"destroy"in e&&m.clients.get(this)===e&&e.destroy(),m.clients.delete(this),e?.remoteClient&&(e.remoteClient=null)}_onInvokeMessage(e){const{methodName:s,jobId:t,data:o=[],abortable:r}=e,i=r?new AbortController:null,a=this._inJobs;let h,c=this._client,p=c[s];try{if(!p&&s&&s.includes(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)c=c[e[s]],p=c[e[s+1]]}if("function"!=typeof p)throw new TypeError(`${s} is not a function`);o.push({client:this,signal:i?i.signal:null}),h=p.apply(c,o)}catch(_){return void this._post({type:u,jobId:t,error:l.toInvokeError(_)})}n.isPromiseLike(h)?(a.set(t,{controller:i,promise:h}),h.then((e=>{a.has(t)&&(a.delete(t),this._post({type:u,jobId:t},e))}),(e=>{a.has(t)&&(a.delete(t),n.isAbortError(e)||this._post({type:u,jobId:t,error:l.toInvokeError(e||{message:`Error encountered at method ${s}`})}))}))):this._post({type:u,jobId:t},h)}_onOpenPortMessage(e){new m(e.port,{client:this._client})}_onOnMessage(e){const{port:s}=e,o=this._client.on(e.eventType,(e=>{s.postMessage(e)})),r=t.on(e.port,"message",(e=>{const t=l.receiveMessage(e);t?.type===l.MessageType.CLOSE&&(r.remove(),o.remove(),s.close())}))}_onResponseMessage(e){const{jobId:t,error:o,data:n}=e,i=this._outJobs;if(!i.has(t))return;const a=i.get(t);i.delete(t),this._processWork(),r.removeMaybe(a.abortHandle),o?a.reject(s.fromJSON(JSON.parse(o))):a.resolve(n)}_post(e,s,t){return l.postMessage(this._port,e,s,t)}}return m.kernelInfo={buildDate:h.buildDate,fullVersion:e.fullVersion,revision:h.commitHash},m.clients=new Map,m}));
