/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../../Color","../../core/colorUtils","../../core/lang","../../support/arcadeOnDemand","./utils","../../views/2d/arcade/callExpressionWithFeature"],(function(e,r,i,t,s,o,a){"use strict";const c=e=>{if(!e)return[0,0,0,0];const{r,g:i,b:t,a:s}=e;return[r,i,t,255*s]};class l{static findApplicableOverrides(e,r,i){if(e&&r){if(e.primitiveName){let t=!1;for(const r of i)if(r.primitiveName===e.primitiveName){t=!0;break}if(!t)for(const s of r)s.primitiveName===e.primitiveName&&i.push(s)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)l.findApplicableOverrides(t,r,i);if(e.symbolLayers)for(const t of e.symbolLayers)l.findApplicableOverrides(t,r,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const t of e.effects)l.findApplicableOverrides(t,r,i);if(e.markerPlacement&&l.findApplicableOverrides(e.markerPlacement,r,i),"CIMVectorMarker"===e.type){if(e.markerGraphics)for(const t of e.markerGraphics)l.findApplicableOverrides(t,r,i),l.findApplicableOverrides(t.symbol,r,i)}else"CIMCharacterMarker"===e.type?l.findApplicableOverrides(e.symbol,r,i):"CIMHatchFill"===e.type?l.findApplicableOverrides(e.lineSymbol,r,i):"CIMPictureMarker"===e.type&&l.findApplicableOverrides(e.animatedSymbolProperties,r,i)}}}static findEffectOverrides(e,r){if(!e)return null;if("CIMGeometricEffectDashes"===e.type&&o.normalizeDashTemplate(e),!r||!e.primitiveName)return{type:"cim-effect-info",effect:e,overrides:[]};const i=e.primitiveName,t=[];for(const s of r)s.primitiveName===i&&t.push({...s,propertyName:o.uncapitalize(s.propertyName)});return{type:"cim-effect-info",effect:e,overrides:t}}static async resolveSymbolOverrides(e,r,i,s,a,c,n){if(!e?.symbol)return null;let{symbol:p,primitiveOverrides:f}=e;const m=!!f;if(!m&&!s)return p;p=t.clone(p),f=t.clone(f);let y=!0;if(r||(r={attributes:{}},y=!1),m){if(y||(f=f.filter((e=>!e.valueExpressionInfo?.expression.includes("$feature")))),n||(f=f.filter((e=>!e.valueExpressionInfo?.expression.includes("$view")))),f.length>0){const e={spatialReference:i,fields:o.attributesToFields(r.attributes),geometryType:a};await l.createRenderExpressions(f,e),l.evaluateOverrides(f,r,a??"esriGeometryPoint",c,n)}l.applyOverrides(p,f)}return s&&l.applyDictionaryTextOverrides(p,r,s,null),p}static async createRenderExpressions(e,r){const i=[];for(const t of e){const e=t.valueExpressionInfo;if(!e||l._expressionToRenderExpression.has(e.expression))continue;const o=s.createRendererExpression(e.expression,r.spatialReference,r.fields);i.push(o),o.then((r=>l._expressionToRenderExpression.set(e.expression,r)))}i.length>0&&await Promise.all(i)}static evaluateOverrides(e,r,t,s,o){const n={$view:{scale:o?.scale}};for(const p of e){p.value&&"object"==typeof p.value&&i.isRGB(p.value)&&("Color"===p.propertyName||"StrokeColor"===p.propertyName)&&(p.value=c(p.value));const e=p.valueExpressionInfo;if(!e)continue;const o=l._expressionToRenderExpression.get(e.expression);o&&(p.value=a(o,r,n,t,s))}}static applyDictionaryTextOverrides(e,r,i,t,s="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const a of o)a&&"CIMVectorMarker"===a.type&&l.applyDictionaryTextOverrides(a,r,i,t,"CIMTextSymbol"===e.type?e.textCase:s)}break;case"CIMVectorMarker":{const s=e.markerGraphics;if(!s)return;for(const e of s)e&&l.applyDictionaryTextOverrides(e,r,i,t)}break;case"CIMMarkerGraphic":{const a=e.textString;if(a&&a.includes("[")){const c=o.analyzeTextParts(a,i);e.textString=o.assignTextValuesFromFeature(r,c,t,s)}}}}static applyOverrides(e,r,i,t){if(e.primitiveName)for(const s of r)if(s.primitiveName===e.primitiveName){const r=o.uncapitalize(s.propertyName);if(t&&t.push({cim:e,nocapPropertyName:r,value:e[r]}),i){let r=!1;for(const t of i)t.primitiveName===e.primitiveName&&(r=!0);r||i.push(s)}null!=s.value&&(e[r]=s.value)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)l.applyOverrides(s,r,i,t);if(e.symbolLayers)for(const s of e.symbolLayers)l.applyOverrides(s,r,i,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const s of e.effects)l.applyOverrides(s,r,i,t);if("CIMVectorMarker"===e.type&&e.markerGraphics)for(const s of e.markerGraphics)l.applyOverrides(s,r,i,t),l.applyOverrides(s.symbol,r,i,t)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const i of e)void 0!==i.value&&(r+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return r}static toValue(e,i){if("DashTemplate"===e)return i.split(" ").map((e=>Number(e)));if("Color"===e){const e=new r(i).toRgba();return e[3]*=255,e}return i}}l._expressionToRenderExpression=new Map,e.OverrideHelper=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
