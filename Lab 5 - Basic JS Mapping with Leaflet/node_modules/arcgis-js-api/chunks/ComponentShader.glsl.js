/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
define(["exports","../geometry/support/Ellipsoid","../views/3d/terrain/OverlayContent","../views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration","../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl","../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl","../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl","../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput","../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl","../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl","../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl","../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl","../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl","../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl","../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl","../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl","../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl","../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl","../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl","../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff","../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl","../views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode","../views/3d/webgl-engine/core/shaderModules/interfaces","../views/3d/webgl-engine/core/shaderModules/ShaderBuilder","../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform","../views/3d/webgl-engine/lib/TransparencyPassType"],(function(e,o,r,a,l,t,i,d,n,s,c,g,u,v,h,m,p,C,w,b,y,x,M,f,S,O,L,T,P,N,B,R,A,D){"use strict";function W(e){const W=new R.ShaderBuilder;W.include(v.VertexPosition,e),W.include(u.VertexNormal,e),W.include(g.VertexColor,e),W.include(c.TextureCoordinateAttribute,e),W.include(i.ForwardLinearDepth,e),W.include(l.ComponentData,e),W.include(P.DiscardOrAdjustAlphaDraw,e),W.include(n.SlicePass,e),W.include(S.ReadBaseColorTexture,e),W.include(t.VertexDiscardByOpacity,e);const{vertex:$,fragment:j}=W;e.pbrMode!==f.PBRMode.Normal&&e.pbrMode!==f.PBRMode.Schematic||(W.include(f.PhysicallyBasedRenderingParameters,e),e.hasNormalTexture&&W.include(w.ComputeNormalTexture,e));const E=e.output===d.ShaderOutput.Shadow||e.output===d.ShaderOutput.ShadowHighlight||e.output===d.ShaderOutput.ShadowExcludeHighlight;E&&e.componentData===l.ComponentDataType.Varying?$.code.add(B.glsl`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`):$.code.add(B.glsl`#define discardShadows(castShadows) {}`);const I=e.integratedMeshMode===a.IntegratedMeshMode.ColorOverlay||e.integratedMeshMode===a.IntegratedMeshMode.ColorOverlayWithWater,z=I&&e.output===d.ShaderOutput.Color&&e.pbrMode===f.PBRMode.WaterOnIntegratedMesh;return I&&(W.include(y.EvaluateSceneLighting,e),W.include(L.OverlayIM,e),e.spherical?$.code.add(B.glsl`
      const float invEllipsoidRadius = ${B.glsl.float(1/(e.ellipsoidMode===N.EllipsoidMode.Earth?o.earth.radius:e.ellipsoidMode===N.EllipsoidMode.Mars?o.mars.radius:o.moon.radius))};
      vec2 projectOverlay(vec3 pos) {
        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);
      }
      `):$.code.add(B.glsl`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)),z&&(W.varyings.add("tbnTangent","vec3"),W.varyings.add("tbnBiTangent","vec3"),W.varyings.add("groundNormal","vec3")),$.code.add(B.glsl`
    void main() {
      bool castShadows;
      vec4 externalColor = forwardExternalColor(castShadows);
      discardShadows(castShadows);

      vertexDiscardByOpacity(externalColor.a);

      ${e.output===d.ShaderOutput.ObjectAndLayerIdColor?B.glsl`externalColor.a = 1.0;`:""}

      if (externalColor.a < ${B.glsl.float(T.symbolAlphaCutoff)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      forwardPosition(readElevationOffset());
      forwardNormal();
      forwardTextureCoordinates();
      forwardVertexColor();
      forwardLinearDepth();
      ${e.output===d.ShaderOutput.ObjectAndLayerIdColor?B.glsl`forwardObjectAndLayerIdColor();`:""}
      ${z?e.spherical?B.glsl`
                groundNormal = normalize(positionWorld());
                tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
                tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:B.glsl`
                groundNormal = vec3(0.0, 0.0, 1.0);
                tbnTangent = vec3(1.0, 0.0, 0.0);
                tbnBiTangent = vec3(0.0, 1.0, 0.0);`:""}
      ${I?B.glsl`setOverlayVTC(projectOverlay(position));`:""}
    }
  `),e.output===d.ShaderOutput.Alpha&&(j.include(p.ReadLinearDepth),W.include(M.multipassTerrainTest,e),W.include(C.ComputeMaterialColor,e),I&&j.uniforms.add(new A.Texture2DPassUniform("ovColorTex",((e,o)=>L.getIMColorTexture(e,o)))),j.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${e.multipassEnabled?B.glsl`terrainDepthTest(vPosition_view.z);`:""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${I?B.glsl`
                vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);
                materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}

        fragColor = vec4(materialColor.a);
      }
    `)),e.output===d.ShaderOutput.Color&&(j.include(p.ReadLinearDepth),W.include(M.multipassTerrainTest,e),W.include(C.ComputeMaterialColor,e),W.include(b.ComputeShadingNormal,e),W.include(y.EvaluateSceneLighting,e),e.receiveShadows?(W.include(O.ReadShadowMapPass,e),j.code.add(B.glsl`float evaluateShadow() {
return readShadowMap(vPositionWorldCameraRelative, linearDepth);
}`)):j.code.add(B.glsl`float evaluateShadow() { return 0.0; }`),I&&j.uniforms.add(new A.Texture2DPassUniform("ovColorTex",((e,o)=>L.getIMColorTexture(e,o)))),j.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${e.multipassEnabled?B.glsl`terrainDepthTest(vPosition_view.z);`:""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${I?B.glsl`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);`:""}
    `),e.pbrMode===f.PBRMode.Normal||e.pbrMode===f.PBRMode.Schematic||e.pbrMode===f.PBRMode.Simplified?(x.addMainLightIntensity(j),j.code.add(B.glsl`
        ${e.pbrMode===f.PBRMode.Normal?B.glsl`
                applyPBRFactors();
                if (int(externalColorMixMode) == 3) {
                  mrr = vec3(0.0, 0.6, 0.2);
                }`:""}
        vec3 normalVertex = shadingNormalWorld();
        float additionalIrradiance = 0.02 * mainLightIntensity[2];
      `),e.hasNormalTexture?j.code.add(B.glsl`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);
vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`):j.code.add(B.glsl`vec3 shadingNormal = normalVertex;`),j.code.add(B.glsl`${e.spherical?B.glsl`vec3 normalGround = normalize(positionWorld());`:B.glsl`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}
      `),j.code.add(B.glsl`
        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        ${e.pbrMode===f.PBRMode.Simplified?B.glsl` float ssao = 1.0 - evaluateAmbientOcclusionInverse();`:B.glsl` float ssao = 1.0 - occlusion * evaluateAmbientOcclusionInverse();`}
        ${e.snowCover?B.glsl`
                vec3 surfaceNormal = normalize(shadingNormalWorld());
                float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
                materialColor.rgb = mix(materialColor.rgb, vec3(1.1), snow);
                ssao = mix(ssao, 0.5 * ssao, snow);
                shadingNormal = mix(shadingNormal, surfaceNormal, snow);`:""}

        ${I?B.glsl` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        ${e.pbrMode===f.PBRMode.Simplified?B.glsl` vec4 shadedColor = vec4(evaluatePBRSimplifiedLighting(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround), materialColor.a);`:"vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);"}
        `)):(e.receiveShadows?j.code.add(B.glsl`float shadow = evaluateShadow();`):e.spherical?(y.addLightingGlobalFactor(j),j.code.add(B.glsl`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());
float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`)):j.code.add(B.glsl`float shadow = 0.0;`),z&&j.uniforms.add(new A.Texture2DPassUniform("ovNormalTex",((e,o)=>o.overlay?.getTexture(r.OverlayContent.WaterNormal)))),e.snowCover&&j.code.add(B.glsl`vec3 surfaceNormal = normalize(cross(dFdx(vPositionWorldCameraRelative), dFdy(vPositionWorldCameraRelative)));
float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`),j.code.add(B.glsl`
        float ambientOcclusion = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());

        ${I?B.glsl` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}

        vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);
      ${z?B.glsl`
              vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
              float waterNormalLength = length(overlayWaterMask);
              if (waterNormalLength > 0.95) {
                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                // un-gamma the ground color to mix in linear space
                shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
              }`:""}
      `)),j.code.add(B.glsl`
        fragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);
        ${e.transparencyPassType===D.TransparencyPassType.Color?"fragColor = premultiplyAlpha(fragColor);":""}
      }
    `)),(e.output===d.ShaderOutput.LinearDepth||E)&&(W.include(h.OutputDepth,e),j.code.add(B.glsl`void main() {
discardBySlice(vPositionWorldCameraRelative);
vec4 textureColor = readBaseColorTexture();
discardOrAdjustAlpha(textureColor);
outputDepth(linearDepth);
}`)),e.output===d.ShaderOutput.Normal&&(W.include(b.ComputeShadingNormal,e),j.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        // note: the alpha component needs to be 1.0 in order for this material to influence ambient occlusion,
        // see the ssao fragment shader
        float alpha = ${e.normalType===s.NormalType.Ground?"0.0":"1.0"};
        fragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);
      }
    `)),e.output===d.ShaderOutput.ObjectAndLayerIdColor&&W.fragment.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${I?B.glsl`fragColor = getOverlayColorTexel(vtcOverlay);`:"outputObjectAndLayerIdColor();"}
      }
    `),e.output===d.ShaderOutput.Highlight&&(W.include(m.OutputHighlight),j.code.add(B.glsl`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${I?B.glsl`
                vec4 overlayColor = getCombinedOverlayColor();
                if (overlayColor.a == 0.0) {
                  fragColor = vec4(0.0);
                  return;
                }`:""}

        outputHighlight();
      }
    `)),W}const $=Object.freeze(Object.defineProperty({__proto__:null,build:W},Symbol.toStringTag,{value:"Module"}));e.ComponentShader=$,e.build=W}));
